This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.git2gus/
  config.json
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    automerge.yml
    create-github-release.yml
    external-test.yml
    failureNotifications.yml
    notify-slack-on-pr-open.yml
    onRelease.yml
    stale.yml
    test.yml
  CODE_OF_CONDUCT.md
  CODEOWNERS
  dependabot.yml
.husky/
  .gitignore
  commit-msg
  pre-commit
guides/
  PRE_CORE_MIGRATION.md
  V2_MIGRATION.md
  V3_MIGRATION.md
src/
  config/
    config.ts
    index.ts
    plugin-loader.ts
    plugin.ts
    ts-path.ts
    util.ts
  errors/
    errors/
      cli.ts
      exit.ts
      module-load.ts
      pretty-print.ts
    error.ts
    exit.ts
    handle.ts
    index.ts
    warn.ts
  help/
    command.ts
    docopts.ts
    formatter.ts
    index.ts
    root.ts
    util.ts
  interfaces/
    alphabet.ts
    args.ts
    config.ts
    errors.ts
    flags.ts
    help.ts
    hooks.ts
    index.ts
    logger.ts
    manifest.ts
    parser.ts
    pjson.ts
    plugin.ts
    s3-manifest.ts
    theme.ts
    topic.ts
    ts-config.ts
  parser/
    errors.ts
    help.ts
    index.ts
    parse.ts
    validate.ts
  util/
    aggregate-flags.ts
    cache-command.ts
    cache-default-value.ts
    determine-priority.ts
    ensure-arg-object.ts
    find-root.ts
    fs.ts
    ids.ts
    os.ts
    read-pjson.ts
    read-tsconfig.ts
    util.ts
  ux/
    action/
      base.ts
      simple.ts
      spinner.ts
      types.ts
    colorize-json.ts
    index.ts
    list.ts
    README.md
    supports-color.ts
    theme.ts
    write.ts
  args.ts
  cache.ts
  command.ts
  execute.ts
  flags.ts
  flush.ts
  index.ts
  logger.ts
  main.ts
  module-loader.ts
  performance.ts
  screen.ts
  settings.ts
  symbols.ts
test/
  command/
    fixtures/
      bundled-cli/
        src/
          commands/
            foo/
              bar.ts
              baz.ts
          hooks/
            init.ts
          index.ts
        package.json
        tsconfig.json
      esm/
        src/
          commands/
            foo/
              bar/
                fail.js
                succeed.js
              baz.js
        package.json
      single-cmd-cli/
        src/
          index.ts
        package.json
        tsconfig.json
      typescript/
        src/
          commands/
            foo/
              bar/
                fail.ts
                succeed.ts
              baz.ts
        package.json
        tsconfig.json
    helpers/
      test-help-in-lib/
        lib/
          test-help-plugin.js
      test-help-in-src/
        src/
          test-help-plugin.ts
    command.test.ts
    explicit-command-strategy.test.ts
    main-esm.test.ts
    main.test.ts
    single-command-cli.test.ts
  config/
    fixtures/
      esm/
        src/
          commands/
            foo/
              bar/
                baz.js
                fail.js
                test-result.js
          hooks/
            init.js
            postrun.js
            prerun.js
        package.json
      help/
        src/
          commands/
            foo/
              bar/
                baz.js
        package.json
      mixed-cjs-esm/
        src/
          commands/
            foo/
              bar/
                baz.mjs
                fail.cjs
                test-result.js
          hooks/
            init.js
            postrun.mjs
            prerun.cjs
        package.json
      mixed-esm-cjs/
        src/
          commands/
            foo/
              bar/
                baz.js
                fail.cjs
                test-result.js
          hooks/
            init.js
            postrun.js
            prerun.cjs
        package.json
      typescript/
        src/
          commands/
            foo/
              bar/
                baz.ts
                fail.ts
                test-result.ts
          hooks/
            init.ts
            postrun.ts
            prerun.ts
        package.json
        tsconfig.json
      wildcard/
        src/
          commands/
            foo.ts
        package.json
        tsconfig.json
    config.flexible.test.ts
    config.shell.test.ts
    config.test.ts
    esm.test.ts
    help.config.test.ts
    mixed-cjs-esm.test.ts
    mixed-esm-cjs.test.ts
    ts-path.test.ts
    typescript.test.ts
    util.test.ts
    wildcard-plugins.test.ts
  errors/
    error.test.ts
    handle.test.ts
    pretty-print.test.ts
    warn.test.ts
  help/
    fixtures/
      fixtures.ts
    _test-help-class-identifier.ts
    _test-help-class.ts
    docopts.test.ts
    format-command-with-options.test.ts
    format-command.test.ts
    format-commands.test.ts
    format-root.test.ts
    format-topic.test.ts
    format-topics.test.ts
    help-test-utils.ts
    show-customized-help.test.ts
    show-help.test.ts
    util.test.ts
  helpers/
    init.js
  integration/
    fixtures/
      tsconfig-tests/
        package.json
        tsconfig-local-extends-local-extends-node-modules.json
        tsconfig-local-extends-local.json
        tsconfig-local-extends-node-modules-extends-node-modules.json
        tsconfig-local-extends-node-modules.json
        tsconfig-local-extends-non-existent.json
        tsconfig-local-no-extends.json
    interop-plugins-matrix.ts
    interop.ts
    sf.integration.ts
    tsconfig.integration.ts
    util.ts
  interfaces/
    args.test-types.ts
    flags.test-types.ts
  module-loader/
    fixtures/
      cjs/
        errors/
          bad_reference.cjs
        package.json
        success-ext.cjs
        success.js
      esm/
        empty-package/
          package.json
          success-ext.mjs
        errors/
          bad_reference.js
        index/
          js/
            index.js
          mjs/
            index.mjs
        package.json
        success.js
      package.json
    module-loader.test.ts
  parser/
    fixtures/
      preparse-plugin/
        src/
          commands/
            test.ts
          hooks/
            preparse.ts
        package.json
        tsconfig.json
      test-plugin/
        src/
          commands/
            invalid.ts
            test.ts
        package.json
        tsconfig.json
    error-codes.test.ts
    help.test.ts
    parse.test.ts
    preparse.test.ts
    validate.test.ts
  perf/
    parser.perf.ts
  util/
    cache-command.test.ts
    cache-default-value.test.ts
    determine-priority.test.ts
    ensure-arg-object.ts
    fs.test.ts
    os.test.ts
    util.test.ts
  ux/
    action/
      simple.test.ts
      spinner.test.ts
    colorize-json.test.ts
    theme.test.ts
    write.test.ts
  logger.test.ts
  tsconfig.json
.commitlintrc.json
.gitattributes
.gitignore
.lintstagedrc.json
.mocharc.json
.nycrc.json
.prettierrc.json
CHANGELOG.md
CONRTIBUTING.md
eslint.config.mjs
LICENSE
package.json
README.md
tsconfig.json
```

# Files

## File: .git2gus/config.json
````json
{
  "productTag": "a1aB0000000ce2IIAQ",
  "defaultBuild": "offcore.tooling.60",
  "issueTypeLabels": {"enhancement": "USER STORY", "bug": "BUG P3"},
  "hideWorkItemUrl": true,
  "statusWhenClosed": "CLOSED"
}
````

## File: .github/ISSUE_TEMPLATE/bug_report.md
````markdown
---
name: Bug report
about: Create a report to help us improve
title: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment (please complete the following information):**
 - OS & version: [e.g. MacOS Monterey, Ubuntu 20.04.4 LTS, Windows 10]
 - Shell/terminal & version [e.g. bash-3.2, bash-5.0, zsh 5.8, powershell 7.2.4, cmd.exe, Windows Terminal w/ powershell, etc... ]

**Additional context**
Add any other context about the problem here.
````

## File: .github/ISSUE_TEMPLATE/feature_request.md
````markdown
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
````

## File: .github/workflows/automerge.yml
````yaml
name: automerge
on:
  workflow_dispatch:
  schedule:
    - cron: "17 2,5,8,11 * * *"

jobs:
  automerge:
    uses: salesforcecli/github-workflows/.github/workflows/automerge.yml@main
    secrets:
      SVC_CLI_BOT_GITHUB_TOKEN: ${{ secrets.SVC_CLI_BOT_GITHUB_TOKEN }}
````

## File: .github/workflows/create-github-release.yml
````yaml
name: create-github-release

on:
  push:
    branches:
      - main
      - prerelease/**
    tags-ignore:
      - "*"
  workflow_dispatch:
    inputs:
      prerelease:
        type: string
        description: "Name to use for the prerelease: beta, dev, etc. NOTE: If this is already set in the package.json, it does not need to be passed in here."

jobs:
  release:
    uses: salesforcecli/github-workflows/.github/workflows/create-github-release.yml@main
    secrets:
      SVC_CLI_BOT_GITHUB_TOKEN: ${{ secrets.SVC_CLI_BOT_GITHUB_TOKEN }}
    with:
      prerelease: ${{ inputs.prerelease }}
      # If this is a push event, we want to skip the release if there are no semantic commits
      # However, if this is a manual release (workflow_dispatch), then we want to disable skip-on-empty
      # This helps recover from forgetting to add semantic commits ('fix:', 'feat:', etc.)
      skip-on-empty: ${{ github.event_name == 'push' }}
      generate-readme: false
  # docs:
  #   # Most repos won't use this
  #   # Depends on the 'release' job to avoid git collisions, not for any functionality reason
  #   needs: release
  #   secrets: inherit
  #   if: ${{ github.ref_name == 'main' }}
  #   uses: salesforcecli/github-workflows/.github/workflows/publishTypedoc.yml@main
````

## File: .github/workflows/external-test.yml
````yaml
on:
  workflow_call:
    inputs:
      os:
        required: false
        description: "runs-on property, ex: ubuntu-latest, windows-latest"
        type: string
        default: "ubuntu-latest"
      repo:
        required: true
        description: "Repository name, ex: 'owner/repo'"
        type: string
      command:
        required: true
        description: "Command to run, ex: 'yarn test'"
        type: string
      other-setup:
        required: false
        description: "Setup command, ex: 'yarn install'"
        type: string

jobs:
  external-test:
    name: ${{ inputs.repo }} ${{ inputs.command }}
    runs-on: ${{ inputs.os }}
    steps:
      - uses: actions/setup-node@v4
      - uses: actions/checkout@v4
      - uses: salesforcecli/github-workflows/.github/actions/yarnInstallWithRetries@main
      - run: yarn build
      - run: yarn link
      - run: ${{ inputs.other-setup }}
      - uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: main
          path: test
      - name: Build plugin
        working-directory: test
        run: |
          yarn install --network-timeout 600000 --ignore-scripts
          yarn link @oclif/core
          yarn build
      - name: Run tests in plugin
        working-directory: test
        run: ${{ inputs.command }}
````

## File: .github/workflows/failureNotifications.yml
````yaml
name: failureNotifications
on:
  workflow_run:
    workflows:
      - publish
      - create-github-release
    types:
      - completed
jobs:
  failure-notify:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    steps:
      - name: Announce Failure
        id: slack
        uses: slackapi/slack-github-action@v1.26.0
        env:
          # for non-CLI-team-owned plugins, you can send this anywhere you like
          SLACK_WEBHOOK_URL: ${{ secrets.CLI_ALERTS_SLACK_WEBHOOK }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
        with:
          payload: |
            {
              "text": "${{ github.event.workflow_run.name }} failed: ${{ github.event.workflow_run.repository.name }}",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": ":bh-alert: ${{ github.event.workflow_run.name }} failed: ${{ github.event.workflow_run.repository.name }} :bh-alert:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Repo: ${{ github.event.workflow_run.repository.html_url }}\nWorkflow name: `${{ github.event.workflow_run.name }}`\nJob url: ${{ github.event.workflow_run.html_url }}"
                  }
                }
              ]
            }
````

## File: .github/workflows/notify-slack-on-pr-open.yml
````yaml
name: Pull Request Slack Notification

on:
  pull_request:
    types: [opened, reopened]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Notify Slack on PR open
      env: 
        WEBHOOK_URL : ${{ secrets.CLI_TEAM_SLACK_WEBHOOK_URL }}
        PULL_REQUEST_AUTHOR_ICON_URL : ${{ github.event.pull_request.user.avatar_url }}
        PULL_REQUEST_AUTHOR_NAME : ${{ github.event.pull_request.user.login }}
        PULL_REQUEST_AUTHOR_PROFILE_URL: ${{ github.event.pull_request.user.html_url }}
        PULL_REQUEST_BASE_BRANCH_NAME : ${{ github.event.pull_request.base.ref }}
        PULL_REQUEST_COMPARE_BRANCH_NAME : ${{ github.event.pull_request.head.ref }}
        PULL_REQUEST_NUMBER : ${{ github.event.pull_request.number }}
        PULL_REQUEST_REPO: ${{ github.event.pull_request.head.repo.name }}
        PULL_REQUEST_TITLE : ${{ github.event.pull_request.title }}
        PULL_REQUEST_URL : ${{ github.event.pull_request.html_url }}
      uses: salesforcecli/github-workflows/.github/actions/prNotification@main
````

## File: .github/workflows/onRelease.yml
````yaml
name: publish
on:
  release:
    # both release and prereleases
    types: [published]
  # support manual release in case something goes wrong and needs to be repeated or tested
  workflow_dispatch:
    inputs:
      tag:
        description: github tag that needs to publish
        type: string
        required: true
jobs:
  # parses the package.json version and detects prerelease tag (ex: beta from 4.4.4-beta.0)
  getDistTag:
    outputs:
      tag: ${{ steps.distTag.outputs.tag }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name || inputs.tag  }}
      - uses: salesforcecli/github-workflows/.github/actions/getPreReleaseTag@main
        id: distTag
  npm:
    uses: salesforcecli/github-workflows/.github/workflows/npmPublish.yml@main
    needs: [getDistTag]
    with:
      tag: ${{ needs.getDistTag.outputs.tag || 'latest' }}
      githubTag: ${{ github.event.release.tag_name || inputs.tag }}
    secrets:
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
````

## File: .github/workflows/stale.yml
````yaml
name: 'Close stale issues'
on:
  schedule:
    - cron: '30 1 * * *'
  workflow_dispatch:

jobs:
  stale:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/stale@v9
        with:
          stale-issue-message: 'This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 7 days.'
          days-before-stale: 30
          days-before-close: 7
          exempt-issue-labels: 'bug,enhancement,announcement,help wanted,good first issue,waiting for interest,needs response,next major'
          # Disable marking PRs as stale
          days-before-pr-stale: -1
````

## File: .github/workflows/test.yml
````yaml
name: tests
on:
  push:
    branches-ignore: [main]
  workflow_dispatch:

jobs:
  yarn-lockfile-check:
    uses: salesforcecli/github-workflows/.github/workflows/lockFileCheck.yml@main
  linux-unit-tests:
    needs: yarn-lockfile-check
    uses: salesforcecli/github-workflows/.github/workflows/unitTestsLinux.yml@main
  windows-unit-tests:
    needs: linux-unit-tests
    uses: salesforcecli/github-workflows/.github/workflows/unitTestsWindows.yml@main
  integration:
    needs: linux-unit-tests
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node_version: [lts/*, latest]
        exclude:
          - os: windows-latest
            node_version: lts/*
      fail-fast: false
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node_version }}
          cache: yarn
      - uses: salesforcecli/github-workflows/.github/actions/yarnInstallWithRetries@main
      - run: yarn build
      - if: runner.os == 'Windows'
        run: yarn mocha --forbid-only "test/**/*.integration.ts" --exclude "test/integration/sf.integration.ts" --parallel --timeout 1200000
      - if: runner.os == 'Linux'
        run: yarn test:integration --retries 3
  windows-sf-integration:
    # For whatever reason the windows-latest runner doesn't like it when you shell yarn commands in the sf repo
    # which is an integral part of the setup for the tests. Instead, we replicate the setup here.
    needs: linux-unit-tests
    strategy:
      fail-fast: false
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: latest
          cache: yarn
      - uses: salesforcecli/github-workflows/.github/actions/yarnInstallWithRetries@main
      - run: yarn build
      - run: yarn link
      - run: New-Item -Path D:\a -Name "integration" -ItemType "directory"
      - run: New-Item -Path D:\a\integration -Name "sf.integration.ts" -ItemType "directory"
      - run: |
          git clone https://github.com/salesforcecli/cli.git
          cd cli

          $Json = Get-Content package.json | ConvertFrom-Json
          $Json.dependencies | Add-Member -Force -MemberType NoteProperty -Name "@oclif/core" -Value "file:D:\a\core\core"
          $Json.resolutions | Add-Member -MemberType NoteProperty -Name "@oclif/core" -Value "D:\a\core\core"
          $Json | ConvertTo-Json -Depth 9 | Out-File package.json

          yarn install --network-timeout 600000
          yarn link @oclif/core
          yarn build
        working-directory: D:\a\integration\sf.integration.ts
      - run: yarn mocha --forbid-only "test/integration/sf.integration.ts" --parallel --timeout 1200000
        env:
          OCLIF_CORE_INTEGRATION_SKIP_SETUP: true
          OCLIF_CORE_INTEGRATION_TEST_DIR: D:\a\integration
          DEBUG: integration:*
  interoperability:
    needs: linux-unit-tests
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node_version: [lts/*, latest]
        test: [esm, cjs, precore, coreV1, coreV2, coreV3, esbuild]
        dev_runtime: [default, bun, tsx]
        exclude:
          - os: windows-latest
            node_version: lts/*
          - os: windows-latest
            dev_runtime: tsx
          - os: windows-latest
            dev_runtime: bun
          - test: precore
            dev_runtime: tsx
          - test: precore
            dev_runtime: bun
          - test: coreV1
            dev_runtime: tsx
          - test: coreV1
            dev_runtime: bun
          - test: coreV2
            dev_runtime: tsx
          - test: coreV2
            dev_runtime: bun
          - test: coreV3
            dev_runtime: tsx
          - test: coreV3
            dev_runtime: bun
      fail-fast: false
    runs-on: ${{ matrix.os }}
    timeout-minutes: 75
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node_version }}
          cache: yarn
      - if: matrix.dev_runtime == 'bun'
        uses: oven-sh/setup-bun@v1
      - if: matrix.dev_runtime == 'tsx'
        run: 'npm install -g tsx'
      - uses: salesforcecli/github-workflows/.github/actions/yarnInstallWithRetries@main
      - run: yarn build
      - run: yarn test:interoperability --test=${{ matrix.test }} --dev-run-time=${{ matrix.dev_runtime }}
  nuts:
    needs: linux-unit-tests
    uses: salesforcecli/github-workflows/.github/workflows/externalNut.yml@main
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
        externalProjectGitUrl:
          - https://github.com/salesforcecli/plugin-auth
          - https://github.com/salesforcecli/plugin-data
          - https://github.com/salesforcecli/plugin-org
          - https://github.com/salesforcecli/plugin-schema
          - https://github.com/salesforcecli/plugin-user
          - https://github.com/salesforcecli/plugin-settings
    with:
      packageName: '@oclif/core'
      externalProjectGitUrl: ${{ matrix.externalProjectGitUrl }}
      command: 'yarn test:nuts'
      os: ${{ matrix.os }}
      useCache: false
      preSwapCommands: 'npx yarn-deduplicate; yarn install'
      preExternalBuildCommands: 'shx rm -rf node_modules/@salesforce/sf-plugins-core/node_modules/@oclif/core'
      ignoreScripts: true
    secrets:
      TESTKIT_AUTH_URL: ${{ secrets.TESTKIT_AUTH_URL }}
      TESTKIT_HUB_USERNAME: ${{ secrets.TESTKIT_HUB_USERNAME }}
      TESTKIT_JWT_CLIENT_ID: ${{ secrets.TESTKIT_JWT_CLIENT_ID }}
      TESTKIT_JWT_KEY: ${{ secrets.TESTKIT_JWT_KEY }}
      TESTKIT_HUB_INSTANCE: ${{ secrets.TESTKIT_HUB_INSTANCE }}
  external-unit-tests:
    needs: linux-unit-tests
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
        repo:
          - oclif/plugin-autocomplete
          - oclif/plugin-commands
          - oclif/plugin-help
          - oclif/plugin-not-found
          - oclif/plugin-plugins
          - oclif/plugin-update
          - oclif/plugin-which
          - oclif/plugin-warn-if-update-available
          - oclif/plugin-version
          - oclif/plugin-test-esbuild
    uses: ./.github/workflows/external-test.yml
    with:
      repo: ${{ matrix.repo }}
      os: ${{ matrix.os }}
      command: 'yarn mocha test/**/*.test.ts --timeout 1200000'
  plugin-plugins-integration:
    needs: linux-unit-tests
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest]
    uses: ./.github/workflows/external-test.yml
    with:
      repo: oclif/plugin-plugins
      os: ${{ matrix.os }}
      command: yarn test:integration --retries 3
      # plugin-plugins integration tests depend on sf being installed globally
      other-setup: npm install -g @salesforce/cli@nightly
  plugin-update-integration:
    needs: linux-unit-tests
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
    uses: ./.github/workflows/external-test.yml
    with:
      repo: oclif/plugin-update
      os: ${{ matrix.os }}
      command: yarn test:integration:sf --retries 3
  plugin-esbuild-integration:
    needs: linux-unit-tests
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
    uses: ./.github/workflows/external-test.yml
    with:
      repo: oclif/plugin-test-esbuild-single
      os: ${{ matrix.os }}
      command: yarn test
````

## File: .github/CODE_OF_CONDUCT.md
````markdown
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

- Using welcoming and inclusive language
- Being respectful of differing viewpoints and experiences
- Gracefully accepting constructive criticism
- Focusing on what is best for the community
- Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

- The use of sexualized language or imagery and unwelcome sexual attention or advances
- Trolling, insulting/derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or electronic address, without explicit permission
- Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at heroku-cli@salesforce.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/4/
````

## File: .github/CODEOWNERS
````
* @oclif/admins
````

## File: .github/dependabot.yml
````yaml
version: 2
updates:
  - package-ecosystem: 'npm'
    directory: '/'
    schedule:
      interval: 'weekly'
      day: 'saturday'
    versioning-strategy: 'increase'
    labels:
      - 'dependencies'
    open-pull-requests-limit: 5
    pull-request-branch-name:
      separator: '-'
    commit-message:
      # cause a release for non-dev-deps
      prefix: fix(deps)
      # no release for dev-deps
      prefix-development: chore(dev-deps)
    ignore:
      - dependency-name: '@salesforce/dev-scripts'
      - dependency-name: '*'
        update-types: ['version-update:semver-major']
````

## File: .husky/.gitignore
````
_
````

## File: .husky/commit-msg
````
yarn run commitlint --edit $1
````

## File: .husky/pre-commit
````
yarn lint-staged --concurrent false
````

## File: guides/PRE_CORE_MIGRATION.md
````markdown
Migrating to @oclif/core from deprecated libraries
==============

Migrating to `@oclif/core` from the deprecated oclif libraries (`@oclif/config`, `@oclif/command`, `@oclif/error`, `@oclif/parser`) is relatively straight forward.

- [Migrating to @oclif/core from deprecated libraries](#migrating-to-oclifcore-from-deprecated-libraries)
  - [Update Imports](#update-imports)
  - [Update Command Args](#update-command-args)
  - [Update your bin scripts](#update-your-bin-scripts)
  - [Add `main` to your package.json](#add-main-to-your-packagejson)
  - [Restore `-h`, `-v`, and `version`](#restore--h--v-and-version)
  - [Configure the `topicSeparator`](#configure-the-topicseparator)
  - [Update `this.parse` to `await this.parse`](#update-thisparse-to-await-thisparse)
  - [Update `default` property on flag definitions](#update-default-property-on-flag-definitions)
  - [Replace cli-ux library with `ux`](#replace-cli-ux-library-with-ux)
  - [Single command CLIs](#single-command-clis)

## Update Imports

Replace imports from the old libraries with `@oclif/core`. For example,

```typescript
import Help from '@oclif/plugin-help';
import {Topic} from '@oclif/config';
import {Command, Flags} from '@oclif/command'
```

With this import:

```typescript
import {Command, Flags, Topic, Help} from '@oclif/core';
```

## Update Command Args

We updated the `Command.args` to more closely resemble flags

**Before**

```typescript
import { Command } from '@oclif/core'

export default MyCommand extends Command {
  static args = [{name: arg1, description: 'an argument', required: true}]

  public async run(): Promise<void> {
    const {args} = await this.parse(MyCommand) // args is useless {[name: string]: any}
  }
}
```

**After**

```typescript
import { Command, Args } from '@oclif/core'

export default MyCommand extends Command {
  static args = {
    arg1: Args.string({description: 'an argument', required: true})
  }

  public async run(): Promise<void> {
    const {args} = await this.parse(MyCommand) // args is { arg1: string }
  }
}
```

These are the available Args:
- string
- integer
- boolean
- url
- file
- directory
- custom


## Update your bin scripts

`@oclif/core` now supports separate bin scripts for production and development.

You can copy these new bin scripts directly from our [example repository](https://github.com/oclif/hello-world/tree/main/bin).

## Add `main` to your package.json

We recommend that all oclif plugins specify the `main` field in their package.json so that we can begin working on supporting Yarn v2.

```json
{
  "main": "lib/index.js"
}
```

All plugins will be required to have this field in the next major version of `@oclif/core`.

## Restore `-h`, `-v`, and `version`

`@oclif/config` automatically added `-h` as a short flag for `--help`, `-v` as a short flag for `--version`, and `version` as an alias for `--version`.

`@oclif/core` removes these so you can now use those flags for whatever you want! However, we've added a way to restore that functionality if you want to keep it.

Simply add the `additionalHelpFlags` and `additionalVersionFlags` properties to the oclif section of your package.json:

```json
{
  "oclif": {
    "additionalHelpFlags": ["-h"],
    "additionalVersionFlags": ["-v"]
  }
}
```

To get the `version` command, install `@oclif/plugin-version` into your CLI:

```json
{
  "dependencies": {
    "@oclif/plugin-version": "^3"
  },
  "oclif": {
    "plugins": [
      "@oclif/plugin-version"
    ]
  }
}
```

## Configure the `topicSeparator`

By default, the `topicSeparator` is set to a colon (`:`) to maintain backwards compatibility with existing CLIs. If you prefer, you can now set it to a space.

For colons:
```json
{
  "oclif": {
    "topicSeparator": ":"
  }
}
```

For spaces:
```json
{
  "oclif": {
    "topicSeparator": " "
  }
}
```

**NOTE: Using colons always works, even if you set the `topicSeparator` to spaces.** This means that you can enable spaces in your CLI without introducing a breaking change to your users.

## Update `this.parse` to `await this.parse`

The `parse` method on `Command` is now asynchronous (more [here](https://oclif.io/blog/#async-command-parsing)). So you'll now need to `await` any calls to `this.parse`:

`const { args, flags } = this.parse(MyCommand)` => `const { args, flags } = await this.parse(MyCommand)`

## Update `default` property on flag definitions

The `default` property on flag definitions is now asynchronous. So you'll now need to await those.

Example:

```typescript
import {Command, Flags} from '@oclif/core'
import {readFile} from 'fs/promises'

function getTeam(): Promise<string> {
  return readFile('team.txt', 'utf-8')
}

export const team = Flags.build({
  char: 't',
  description: 'team to use',
  default: () => getTeam(),
})

export class MyCLI extends Command {
  static flags = {
    team: team(),
  }

  async run() {
    const {flags} = this.parse(MyCLI)
    if (flags.team) console.log(`--team is ${flags.team}`)
  }
}
```

## Replace cli-ux library with `ux`

The [`cli-ux` library](https://github.com/oclif/cli-ux) has also been moved into `@oclif/core` in order to break a complex circular dependency between the two projects.

All the exports that were available from `cli-ux` are now available under the `ux` namespace, with the exception of the `cli` export which was identical to the `ux` export.

Old:

```typescript
import { cli } from 'cli-ux`

cli.log('hello world')
cli.action.start('doing things')
cli.action.stop()
```

New:

```typescript
import { ux } from '@oclif/core`

ux.log('hello world')
ux.action.start('doing things')
ux.action.stop()
```

## Single command CLIs

Single command CLIs now are configured in a different way. To ensure your migrated CLI work as before, you have to add the following to your `oclif` configuration in the `package.json`:

```json
"oclif": {
  "default": ".",
  "commands": "./lib"
}
```

Where `./lib` points to the folder in which your `tsconfig.json` is configured to output to (if you are using TypeScript), and your single command CLI entrypoint `index.(ts|js)` is located.
````

## File: guides/V2_MIGRATION.md
````markdown
Migrating to @oclif/core@V2
==============

## Breaking Changes

### Command Args

We updated the `Command.args` to more closely resemble flags

**Before**

```typescript
import { Command } from '@oclif/core'

export default MyCommand extends Command {
  static args = [{name: arg1, description: 'an argument', required: true}]

  public async run(): Promise<void> {
    const {args} = await this.parse(MyCommand) // args is useless {[name: string]: any}
  }
}
```

**After**

```typescript
import { Command, Args } from '@oclif/core'

export default MyCommand extends Command {
  static args = {
    arg1: Args.string({description: 'an argument', required: true})
  }

  public async run(): Promise<void> {
    const {args} = await this.parse(MyCommand) // args is { arg1: string }
  }
}
```

These are the available Args:
- string
- integer
- boolean
- url
- file
- directory
- custom

### Interfaces

- Removed `Interfaces.Command` since they were not usable for tests. These are replaced by types that are available under the `Command` namespace

```
Interfaces.Command => Command.Cached
Interfaces.Command.Class => Command.Class
Interfaces.Command.Loadable => Command.Lodable
```

- Removed the following interfaces from the export. Exporting all of these made it difficult to make non-breaking changes when modifying types and/or fixing compilation bugs. We are open to PRs to reintroduce these to the export if they are needed for your project
  - Arg
  - ArgInput
  - ArgToken
  - CLIParseErrorOptions
  - CompletableFlag
  - CompletableOptionFlag
  - Completion
  - CompletionContext
  - Default
  - DefaultContext
  - Definition
  - EnumFlagOptions
  - FlagBase
  - FlagInput
  - FlagOutput
  - FlagToken
  - FlagUsageOptions
  - Input
  - List
  - ListItem
  - Metadata
  - OptionalArg
  - OptionFlagProps
  - OutputArgs
  - OutputFlags
  - ParseFn
  - ParserArg
  - ParserInput
  - ParserOutput
  - ParsingToken
  - RequiredArg

### CliUx

We flattened `CliUx.ux` into `ux` for ease of use

**Before**

```typescript
import {CliUx} from '@oclif/core'

CliUx.ux.log('Hello World')
```

**After**

```typescript
import {ux} from '@oclif/core'

ux.log('Hello World')
```

#### CliUx.ux.open

We removed the `open` method since it was a direct import/export of the [`open`](https://www.npmjs.com/package/open) package. If you need this functionality, then you should import `open` yourself.

### Flags

- Flags.custom replaces Flags.build, Flags.enum, and Flags.option
- Removed builtin `color` flag
- Renamed `globalFlags` to `baseFlags`
  - `globalFlags` was a misleading name because the flags added there weren't actually global to the entire CLI. Instead, they were just flags that would be inherited by any command that extended the command class they were defined in.

### Flag and Arg Parsing

- In v1, any input that didn't match a flag definition was assumed to be an argument. This meant that misspelled flags, e.g. `--hekp` were parsed as arguments, instead of throwing an error. In order to handle this, oclif now assumes that anything that starts with a hyphen must be a flag and will throw an error if no corresponding flag definition is found. **In other words, your command can no longer accept arguments that begin with a hyphen** (fixes https://github.com/oclif/core/issues/526)
- v1 allowed you to return an array from a flag's `parse`. This was added to support backwards compatibility for flags that separated values by commas (e.g. `my-flag=val1,val2`). However, this was problematic because it didn't allow the `parse` to manipulate the individual values. If you need this functionality, you can now set a `delimiter` option on your flags. By doing so, oclif will split the string on the delimiter before parsing.

## ESM/CJS Friendliness

Writing plugins with ESM has always been possible, but it requires [a handful of modifications](https://oclif.io/docs/esm) for it to work, especially in the bin scripts. In v2 we've introduced an `execute` method that the bin scripts can use to avoid having to make changes for ESM of CJS.

**CJS `bin/dev` before**
```typescript
#!/usr/bin/env node

const oclif = require('@oclif/core')

const path = require('path')
const project = path.join(__dirname, '..', 'tsconfig.json')

// In dev mode -> use ts-node and dev plugins
process.env.NODE_ENV = 'development'

require('ts-node').register({project})

// In dev mode, always show stack traces
oclif.settings.debug = true;


// Start the CLI
oclif.run().then(oclif.flush).catch(oclif.Errors.handle)
```

**CJS `bin/dev.js` after**
```typescript
#!/usr/bin/env node
// eslint-disable-next-line node/shebang
(async () => {
  const oclif = await import('@oclif/core')
  await oclif.execute({type: 'cjs', development: true, dir: __dirname})
})()
```

**ESM `bin/dev.js` before**
```typescript
#!/usr/bin/env ts-node

/* eslint-disable node/shebang */

import oclif from '@oclif/core'
import path from 'node:path'
import url from 'node:url'
// eslint-disable-next-line node/no-unpublished-import
import {register} from 'ts-node'

// In dev mode -> use ts-node and dev plugins
process.env.NODE_ENV = 'development'

register({
  project: path.join(path.dirname(url.fileURLToPath(import.meta.url)), '..', 'tsconfig.json'),
})

// In dev mode, always show stack traces
oclif.settings.debug = true

// Start the CLI
oclif
.run(process.argv.slice(2), import.meta.url)
.then(oclif.flush)
.catch(oclif.Errors.handle)
```

**ESM `bin/dev.js` after**
```typescript
#!/usr/bin/env node
// eslint-disable-next-line node/shebang
(async () => {
  const oclif = await import('@oclif/core')
  await oclif.execute({type: 'esm', dir: import.meta.url})
})()
```

Note that ESM and CJS plugins still require different settings in the tsconfig.json - you will still need to make those modifications yourself.

## Other Changes
- Removed dependency on `@oclif/screen`
- Replaced `@oclif/linewrap` with `wordwrap`
````

## File: guides/V3_MIGRATION.md
````markdown
# Migrating to @oclif/core@V3

- [Migrating to @oclif/core@V3](#migrating-to-oclifcorev3)
  - [BREAKING CHANGES â—](#breaking-changes-)
    - [Dropping node 14 and node 16 support](#dropping-node-14-and-node-16-support)
    - [Bin Scripts for ESM/CJS Interoperability](#bin-scripts-for-esmcjs-interoperability)
    - [Dropped `ts-node` as a dependency](#dropped-ts-node-as-a-dependency)
    - [`Config.plugins`](#configplugins)
    - [Readonly properties on `Config`](#readonly-properties-on-config)
    - [Private methods on `Plugin`](#private-methods-on-plugin)
    - [`global['cli-ux']` -\> `global.ux`](#globalcli-ux---globalux)
    - [`handle`](#handle)
    - [`noCacheDefault` flag property replaces `isWritingManifest`](#nocachedefault-flag-property-replaces-iswritingmanifest)
    - [Removed Unnecessary Exports](#removed-unnecessary-exports)
  - [Features ðŸŽ‰](#features-)
    - [Performance Improvements](#performance-improvements)
    - [charAliases Flag Property](#charaliases-flag-property)
    - [Flags.option](#flagsoption)
    - [Set spinner styles](#set-spinner-styles)

## BREAKING CHANGES â—

### Dropping node 14 and node 16 support

The end-of-life date for Node.js 14 was [April 30, 2023](https://nodejs.org/en/about/releases/).

The end-of-life date for Node.js 16 was [September 11, 2023](https://nodejs.org/en/about/releases/). This date is earlier than previously published. Node.jsâ€™s [blog](https://nodejs.org/en/blog/announcements/nodejs16-eol/) explains why they chose this earlier end-of-life date.

### Bin Scripts for ESM/CJS Interoperability

In order to support ESM and CommonJS plugin interoperability you will need to update your bin scripts to match these:

[CJS Template](https://github.com/oclif/hello-world/tree/main/bin)

[ESM Template](https://github.com/oclif/hello-world-esm/tree/main/bin)

**You will also need to update any references to the bin scripts to include the .js extension.**

If you'd like to migrate your plugin to ESM, please read our guide [here](https://oclif.io/docs/esm)

### Dropped `ts-node` as a dependency

We removed `ts-node` as a dependency to reduce the package size. By doing this, it means that linked plugin **must** have `ts-node` as a `devDependency` in order for auto-transpilation to work.

### `Config.plugins`

`Config.plugins` is now a `Map` where the keys are the plugin names and the values are the loaded `Plugin` instances. Previously it was an array of loaded `Plugin` instances.

By using a `Map` we can now do more efficient lookups during command execution. `Config.getPluginsList` was added in case you still would like a flat array of `Plugin` instances.

### Readonly properties on `Config`

Various properties on `Config` are now `readonly` - `name` - `version` - `channel` - `pjson` - `root` - `arch` - `bin` - `cacheDir` - `configDir` - `dataDir` - `dirname` - `errLog` - `home` - `platform` - `shell` - `userAgent` - `windows` - `debug` - `npmRegistry` - `userPJSON` - `plugins` - `binPath` - `binAliases` - `nsisCustomization` - `valid` - `flexibleTaxonomy` - `commands`

### Private methods on `Plugin`

The `_manifest` and `warn` methods on `Plugin` are now `private`

### `global['cli-ux']` -> `global.ux`

The global `cli-ux` object has been renamed to `ux` to be consistent with the module's name

### `handle`

The exported `handle` function for handling errors in bin scripts is now asynchronous

### `noCacheDefault` flag property replaces `isWritingManifest`

Version 2 allowed you to optionally return non-sensitive input if the `default` or `defaultHelp` flag/arg properties were called during manifest creation. This is helpful if you don't want sensitive data to be put into the `oclif.manifest.json` and then released to npm. To do this you had to handle the `isWritingManifest` parameter passed in to the `default` and `defaultHelp` callbacks.

```typescript
export const mySensitiveFlag = Flags.string({
  default: async (context, isWritingManifest) => {
    if (isWritingManifest) {
      return undefined
    }

    return 'sensitive info'
  },
})
```

Version 3 removes the `isWritingManifest` parameter in favor of a flag and arg property, `noCacheDefault`. Setting it to true will automatically keep it from being cached in the manifest.

```typescript
export const mySensitiveFlag = Flags.string({
  noCacheDefault: true,
  default: async (context) => {
    return 'sensitive info'
  },
})
```

### Removed Unnecessary Exports

The following exports have been removed:

- `toCached`
- `tsPath`

## Features ðŸŽ‰

### Performance Improvements

- Cache command permutations for flexible taxonomy in the `oclif.manifest.json`
- Cache additional command properties (`isESM`, `relativePath`) in the `oclif.manifest.json`
- Improved accuracy in the `DEBUG=perf` output.
- Remove `ts-node` from `dependencies` to reduce the package size.

### charAliases Flag Property

You can now define single character flag aliases using the `charAliases` property.

### Flags.option

There's a new flag type that infers the flag's type from the provided options.

In v2 you would have needed to do something like this,

```typescript
type Options = 'foo' | 'bar'
export default class MyCommand extends Command {
  static flags = {
    name: Flags.custom<Options>({
      options: ['foo', 'bar'],
    })(),
  }
}
```

Now in v3 you can do this,

```typescript
export default class MyCommand extends Command {
  static flags = {
    name: Flags.option({
      options: ['foo', 'bar'] as const,
    })(),
  }
}
```

### Set spinner styles

You can now configure the style of the spinner when using `ux.action.start`. See [spinners](https://github.com/oclif/core/blob/main/src/cli-ux/action/spinners.ts) for all the different options.

```typescript
ux.action.start('starting spinner', 'spinning', {style: 'arc'})
await ux.wait(2500)
ux.action.status = 'still going'
await ux.wait(2500)
ux.action.stop()
```
````

## File: src/config/config.ts
````typescript
import * as ejs from 'ejs'
import WSL from 'is-wsl'
import {arch, userInfo as osUserInfo, release, tmpdir, type} from 'node:os'
import {join, resolve, sep} from 'node:path'
import {fileURLToPath, URL} from 'node:url'

import Cache from '../cache'
import {Command} from '../command'
import {CLIError, error, exit, warn} from '../errors'
import {getHelpFlagAdditions} from '../help/util'
import {Hook, Hooks, OclifConfiguration, PJSON, S3Templates, Topic, UserPJSON} from '../interfaces'
import {ArchTypes, Config as IConfig, LoadOptions, PlatformTypes, VersionDetails} from '../interfaces/config'
import {Plugin as IPlugin, Options} from '../interfaces/plugin'
import {Theme} from '../interfaces/theme'
import {makeDebug as loggerMakeDebug, setLogger} from '../logger'
import {loadWithData} from '../module-loader'
import {OCLIF_MARKER_OWNER, Performance} from '../performance'
import {settings} from '../settings'
import {determinePriority} from '../util/determine-priority'
import {safeReadJson} from '../util/fs'
import {toStandardizedId} from '../util/ids'
import {getHomeDir, getPlatform} from '../util/os'
import {compact, isProd} from '../util/util'
import {ux} from '../ux'
import {parseTheme} from '../ux/theme'
import PluginLoader from './plugin-loader'
import {tsPath} from './ts-path'
import {collectUsableIds, getCommandIdPermutations, makeDebug} from './util'

const debug = makeDebug()

const _pjson = Cache.getInstance().get('@oclif/core')
const BASE = `${_pjson.name}@${_pjson.version}`
const ROOT_ONLY_HOOKS = new Set<keyof Hooks>(['preparse'])

function displayWarnings() {
  if (process.listenerCount('warning') > 1) return
  process.on('warning', (warning: any) => {
    console.error(warning.stack)
    if (warning.detail) console.error(warning.detail)
  })
}

function channelFromVersion(version: string) {
  const m = version.match(/[^-]+(?:-([^.]+))?/)
  return (m && m[1]) || 'stable'
}

function isConfig(o: any): o is Config {
  return o && Boolean(o._base)
}

class Permutations extends Map<string, Set<string>> {
  private validPermutations = new Map<string, string>()

  public add(permutation: string, commandId: string): void {
    this.validPermutations.set(permutation, commandId)
    for (const id of collectUsableIds([permutation])) {
      if (this.has(id)) {
        this.set(id, this.get(id).add(commandId))
      } else {
        this.set(id, new Set([commandId]))
      }
    }
  }

  public get(key: string): Set<string> {
    return super.get(key) ?? new Set()
  }

  public getAllValid(): string[] {
    return [...this.validPermutations.keys()]
  }

  public getValid(key: string): string | undefined {
    return this.validPermutations.get(key)
  }

  public hasValid(key: string): boolean {
    return this.validPermutations.has(key)
  }
}

export class Config implements IConfig {
  public arch!: ArchTypes
  public bin!: string
  public binAliases?: string[] | undefined
  public binPath?: string | undefined
  public cacheDir!: string
  public channel!: string
  public configDir!: string
  public dataDir!: string
  public dirname!: string
  public flexibleTaxonomy!: boolean
  public home!: string
  public isSingleCommandCLI = false
  public name!: string
  public npmRegistry?: string | undefined
  public nsisCustomization?: string | undefined
  public pjson!: PJSON
  public platform!: PlatformTypes
  public plugins: Map<string, IPlugin> = new Map()
  public root!: string
  public shell!: string
  public theme?: Theme | undefined
  public topicSeparator: ' ' | ':' = ':'
  public updateConfig!: NonNullable<OclifConfiguration['update']>
  public userAgent!: string
  public userPJSON?: UserPJSON | undefined
  public valid!: boolean
  public version!: string
  protected warned = false
  public windows!: boolean
  private _base = BASE
  private _commandIDs!: string[]
  private _commands = new Map<string, Command.Loadable>()
  private _topics = new Map<string, Topic>()
  private commandPermutations = new Permutations()
  private pluginLoader!: PluginLoader
  private rootPlugin!: IPlugin
  private topicPermutations = new Permutations()

  constructor(public options: Options) {}

  static async load(opts: LoadOptions = module.filename || __dirname): Promise<Config> {
    setLogger(opts)
    // Handle the case when a file URL string is passed in such as 'import.meta.url'; covert to file path.
    if (typeof opts === 'string' && opts.startsWith('file://')) {
      opts = fileURLToPath(opts)
    }

    if (typeof opts === 'string') opts = {root: opts}
    if (isConfig(opts)) {
      /**
       * Reload the Config based on the version required by the command.
       * This is needed because the command is given the Config instantiated
       * by the root plugin, which may be a different version than the one
       * required by the command.
       *
       * Doing this ensures that the command can freely use any method on Config that
       * exists in the version of Config required by the command but may not exist on the
       * root's instance of Config.
       */
      if (BASE !== opts._base) {
        debug(`reloading config from ${opts._base} to ${BASE}`)
        const config = new Config({...opts.options, plugins: opts.plugins})
        await config.load()
        return config
      }

      return opts
    }

    const config = new Config(opts)
    await config.load()
    return config
  }

  public get commandIDs(): string[] {
    if (this._commandIDs) return this._commandIDs
    this._commandIDs = this.commands.map((c) => c.id)
    return this._commandIDs
  }

  public get commands(): Command.Loadable[] {
    return [...this._commands.values()]
  }

  protected get isProd(): boolean {
    return isProd()
  }

  static get rootPlugin(): IPlugin | undefined {
    return this.rootPlugin
  }

  public get topics(): Topic[] {
    return [...this._topics.values()]
  }

  public get versionDetails(): VersionDetails {
    const [cliVersion, architecture, nodeVersion] = this.userAgent.split(' ')
    return {
      architecture,
      cliVersion,
      nodeVersion,
      osVersion: `${type()} ${release()}`,
      pluginVersions: Object.fromEntries(
        [...this.plugins.values()].map((p) => [p.name, {root: p.root, type: p.type, version: p.version}]),
      ),
      rootPath: this.root,
      shell: this.shell,
    }
  }

  protected _shell(): string {
    let shellPath
    const {COMSPEC} = process.env
    const SHELL = process.env.SHELL ?? osUserInfo().shell?.split(sep)?.pop()
    if (SHELL) {
      shellPath = SHELL.split('/')
    } else if (this.windows && process.title.toLowerCase().includes('powershell')) {
      shellPath = ['powershell']
    } else if (this.windows && process.title.toLowerCase().includes('command prompt')) {
      shellPath = ['cmd.exe']
    } else if (this.windows && COMSPEC) {
      shellPath = COMSPEC.split(/\\|\//)
    } else {
      shellPath = ['unknown']
    }

    return shellPath.at(-1) ?? 'unknown'
  }

  protected dir(category: 'cache' | 'config' | 'data'): string {
    const base =
      process.env[`XDG_${category.toUpperCase()}_HOME`] ||
      (this.windows && process.env.LOCALAPPDATA) ||
      join(this.home, category === 'data' ? '.local/share' : '.' + category)
    return join(base, this.dirname)
  }
  public findCommand(id: string, opts: {must: true}): Command.Loadable

  public findCommand(id: string, opts?: {must: boolean}): Command.Loadable | undefined

  public findCommand(id: string, opts: {must?: boolean} = {}): Command.Loadable | undefined {
    const lookupId = this.getCmdLookupId(id)
    const command = this._commands.get(lookupId)
    if (opts.must && !command) error(`command ${lookupId} not found`)
    return command
  }

  /**
   * Find all command ids that include the provided command id.
   *
   * For example, if the command ids are:
   * - foo:bar:baz
   * - one:two:three
   *
   * `bar` would return `foo:bar:baz`
   *
   * @param partialCmdId string
   * @param argv string[] process.argv containing the flags and arguments provided by the user
   * @returns string[]
   */
  public findMatches(partialCmdId: string, argv: string[]): Command.Loadable[] {
    const flags = argv
      .filter((arg) => !getHelpFlagAdditions(this).includes(arg) && arg.startsWith('-'))
      .map((a) => a.replaceAll('-', ''))
    const possibleMatches = [...this.commandPermutations.get(partialCmdId)].map((k) => this._commands.get(k)!)

    const matches = possibleMatches.filter((command) => {
      const cmdFlags = Object.entries(command.flags).flatMap(([flag, def]) =>
        def.char ? [def.char, flag] : [flag],
      ) as string[]

      // A command is a match if the provided flags belong to the full command
      return flags.every((f) => cmdFlags.includes(f))
    })

    return matches
  }

  public findTopic(id: string, opts: {must: true}): Topic

  public findTopic(id: string, opts?: {must: boolean}): Topic | undefined

  public findTopic(name: string, opts: {must?: boolean} = {}): Topic | undefined {
    const lookupId = this.getTopicLookupId(name)
    const topic = this._topics.get(lookupId)
    if (topic) return topic
    if (opts.must) throw new Error(`topic ${name} not found`)
  }

  /**
   * Returns an array of all command ids. If flexible taxonomy is enabled then all permutations will be appended to the array.
   * @returns string[]
   */
  public getAllCommandIDs(): string[] {
    return this.getAllCommands().map((c) => c.id)
  }

  /**
   * Returns an array of all commands. If flexible taxonomy is enabled then all permutations will be appended to the array.
   * @returns Command.Loadable[]
   */
  public getAllCommands(): Command.Loadable[] {
    const commands = [...this._commands.values()]
    const validPermutations = [...this.commandPermutations.getAllValid()]
    for (const permutation of validPermutations) {
      if (!this._commands.has(permutation)) {
        const cmd = this._commands.get(this.getCmdLookupId(permutation))!
        commands.push({...cmd, id: permutation})
      }
    }

    return commands
  }

  public getPluginsList(): IPlugin[] {
    return [...this.plugins.values()]
  }

  // eslint-disable-next-line complexity
  public async load(): Promise<void> {
    settings.performanceEnabled =
      (settings.performanceEnabled === undefined ? this.options.enablePerf : settings.performanceEnabled) ?? false
    if (settings.debug) displayWarnings()
    setLogger(this.options)
    const marker = Performance.mark(OCLIF_MARKER_OWNER, 'config.load')
    this.pluginLoader = new PluginLoader({plugins: this.options.plugins, root: this.options.root})
    this.rootPlugin = await this.pluginLoader.loadRoot({pjson: this.options.pjson})

    // Cache the root plugin so that we can reference it later when determining if
    // we should skip ts-node registration for an ESM plugin.
    const cache = Cache.getInstance()
    cache.set('rootPlugin', this.rootPlugin)
    cache.set('exitCodes', this.rootPlugin.pjson.oclif.exitCodes ?? {})

    this.root = this.rootPlugin.root
    this.pjson = this.rootPlugin.pjson

    this.plugins.set(this.rootPlugin.name, this.rootPlugin)
    this.root = this.rootPlugin.root
    this.pjson = this.rootPlugin.pjson
    this.name = this.pjson.name
    this.version = this.options.version || this.pjson.version || '0.0.0'
    this.channel = this.options.channel || channelFromVersion(this.version)
    this.valid = this.rootPlugin.valid

    this.arch = arch() === 'ia32' ? 'x86' : (arch() as any)
    this.platform = WSL ? 'wsl' : getPlatform()
    this.windows = this.platform === 'win32'
    this.bin = this.pjson.oclif.bin || this.name
    this.binAliases = this.pjson.oclif.binAliases
    this.nsisCustomization = this.pjson.oclif.nsisCustomization
    this.dirname = this.pjson.oclif.dirname || this.name
    this.flexibleTaxonomy = this.pjson.oclif.flexibleTaxonomy || false
    // currently, only colons or spaces are valid separators
    if (this.pjson.oclif.topicSeparator && [' ', ':'].includes(this.pjson.oclif.topicSeparator))
      this.topicSeparator = this.pjson.oclif.topicSeparator!
    if (this.platform === 'win32') this.dirname = this.dirname.replace('/', '\\')

    this.userAgent = `${this.name}/${this.version} ${this.platform}-${this.arch} node-${process.version}`
    this.shell = this._shell()

    this.home = process.env.HOME || (this.windows && this.windowsHome()) || getHomeDir() || tmpdir()
    this.cacheDir = this.scopedEnvVar('CACHE_DIR') || this.macosCacheDir() || this.dir('cache')
    this.configDir = this.scopedEnvVar('CONFIG_DIR') || this.dir('config')
    this.dataDir = this.scopedEnvVar('DATA_DIR') || this.dir('data')
    this.binPath = this.scopedEnvVar('BINPATH')

    this.npmRegistry = this.scopedEnvVar('NPM_REGISTRY') || this.pjson.oclif.npmRegistry

    this.theme = await this.loadTheme()

    this.updateConfig = {
      ...this.pjson.oclif.update,
      node: this.pjson.oclif.update?.node ?? {},
      s3: this.buildS3Config(),
    }

    this.isSingleCommandCLI = Boolean(
      typeof this.pjson.oclif.commands !== 'string' &&
        this.pjson.oclif.commands?.strategy === 'single' &&
        this.pjson.oclif.commands?.target,
    )

    this.maybeAdjustDebugSetting()
    await this.loadPluginsAndCommands()

    debug('config done')
    marker?.addDetails({
      commandPermutations: this.commands.length,
      commands: [...this.plugins.values()].reduce((acc, p) => acc + p.commands.length, 0),
      plugins: this.plugins.size,
      topics: this.topics.length,
    })
    marker?.stop()
  }

  async loadPluginsAndCommands(opts?: {force: boolean}): Promise<void> {
    const pluginsMarker = Performance.mark(OCLIF_MARKER_OWNER, 'config.loadAllPlugins')
    const {errors, plugins} = await this.pluginLoader.loadChildren({
      dataDir: this.dataDir,
      devPlugins: this.options.devPlugins,
      force: opts?.force ?? false,
      pluginAdditions: this.options.pluginAdditions,
      rootPlugin: this.rootPlugin,
      userPlugins: this.options.userPlugins,
    })

    this.plugins = plugins
    pluginsMarker?.stop()

    const commandsMarker = Performance.mark(OCLIF_MARKER_OWNER, 'config.loadAllCommands')
    for (const plugin of this.plugins.values()) {
      this.loadCommands(plugin)
      this.loadTopics(plugin)
    }

    commandsMarker?.stop()

    for (const error of errors) {
      this.warn(error)
    }
  }

  public async loadTheme(): Promise<Theme | undefined> {
    if (this.scopedEnvVarTrue('DISABLE_THEME')) return

    const userThemeFile = resolve(this.configDir, 'theme.json')
    const getDefaultTheme = async () => {
      if (!this.pjson.oclif.theme) return
      if (typeof this.pjson.oclif.theme === 'string') {
        return safeReadJson<Record<string, string>>(resolve(this.root, this.pjson.oclif.theme))
      }

      return this.pjson.oclif.theme
    }

    const [defaultTheme, userTheme] = await Promise.all([
      getDefaultTheme(),
      safeReadJson<Record<string, string>>(userThemeFile),
    ])

    // Merge the default theme with the user theme, giving the user theme precedence.
    const merged = {...defaultTheme, ...userTheme}
    return Object.keys(merged).length > 0 ? parseTheme(merged) : undefined
  }

  protected macosCacheDir(): string | undefined {
    return (this.platform === 'darwin' && join(this.home, 'Library', 'Caches', this.dirname)) || undefined
  }

  public async runCommand<T = unknown>(
    id: string,
    argv: string[] = [],
    cachedCommand: Command.Loadable | null = null,
  ): Promise<T> {
    const marker = Performance.mark(OCLIF_MARKER_OWNER, `config.runCommand#${id}`)
    debug('runCommand %s %o', id, argv)
    let c = cachedCommand ?? this.findCommand(id)
    if (!c) {
      const matches = this.flexibleTaxonomy ? this.findMatches(id, argv) : []
      const hookResult =
        this.flexibleTaxonomy && matches.length > 0
          ? await this.runHook('command_incomplete', {argv, id, matches})
          : await this.runHook('command_not_found', {argv, id})

      if (hookResult.successes[0]) return hookResult.successes[0].result as T
      if (hookResult.failures[0]) throw hookResult.failures[0].error
      throw new CLIError(`command ${id} not found`)
    }

    if (this.isJitPluginCommand(c)) {
      const pluginName = c.pluginName!
      const pluginVersion = this.pjson.oclif.jitPlugins![pluginName]
      const jitResult = await this.runHook('jit_plugin_not_installed', {
        argv,
        command: c,
        id,
        pluginName,
        pluginVersion,
      })
      if (jitResult.failures[0]) throw jitResult.failures[0].error
      if (jitResult.successes[0]) {
        await this.loadPluginsAndCommands({force: true})
        c = this.findCommand(id) ?? c
      } else {
        // this means that no jit_plugin_not_installed hook exists, so we should run the default behavior
        const result = await this.runHook('command_not_found', {argv, id})
        if (result.successes[0]) return result.successes[0].result as T
        if (result.failures[0]) throw result.failures[0].error
        throw new CLIError(`command ${id} not found`)
      }
    }

    const command = await c.load()
    await this.runHook('prerun', {argv, Command: command})

    const result = (await command.run(argv, this)) as T
    // If plugins:uninstall was run, we need to remove all the uninstalled plugins
    // from this.plugins so that the postrun hook doesn't attempt to run any
    // hooks that might have existed in the uninstalled plugins.
    if (c.id === 'plugins:uninstall') {
      for (const arg of argv) this.plugins.delete(arg)
    }

    await this.runHook('postrun', {argv, Command: command, result})

    marker?.addDetails({command: id, plugin: c.pluginName!})
    marker?.stop()
    return result
  }

  public async runHook<T extends keyof Hooks, P extends Hooks = Hooks>(
    event: T,
    opts: P[T]['options'],
    timeout?: number,
    captureErrors?: boolean,
  ): Promise<Hook.Result<P[T]['return']>> {
    const marker = Performance.mark(OCLIF_MARKER_OWNER, `config.runHook#${event}`)
    debug('start %s hook', event)
    const search = (m: any): Hook<T> => {
      if (typeof m === 'function') return m
      if (m.default && typeof m.default === 'function') return m.default
      return Object.values(m).find((m: any) => typeof m === 'function') as Hook<T>
    }

    const withTimeout = async (ms: number, promise: any) => {
      let id: NodeJS.Timeout
      const timeout = new Promise((_, reject) => {
        id = setTimeout(() => {
          reject(new Error(`Timed out after ${ms} ms.`))
        }, ms).unref()
      })

      return Promise.race([promise, timeout]).then((result) => {
        clearTimeout(id)
        return result
      })
    }

    const final: Hook.Result<P[T]['return']> = {
      failures: [],
      successes: [],
    }

    const plugins = ROOT_ONLY_HOOKS.has(event) ? [this.rootPlugin] : [...this.plugins.values()]
    const promises = plugins.map(async (p) => {
      const debug = loggerMakeDebug([p.name, 'hooks', event].join(':'))
      const context: Hook.Context = {
        config: this,
        debug,
        error(message, options: {code?: string; exit?: number} = {}) {
          error(message, options)
        },
        exit(code = 0) {
          exit(code)
        },
        log(message?: any, ...args: any[]) {
          ux.stdout(message, ...args)
        },
        warn(message: string) {
          warn(message)
        },
      }

      const hooks = p.hooks[event] || []

      for (const hook of hooks) {
        const marker = Performance.mark(OCLIF_MARKER_OWNER, `config.runHook#${p.name}(${hook.target})`)
        try {
          /* eslint-disable no-await-in-loop */
          const {filePath, isESM, module} = await loadWithData(p, await tsPath(p.root, hook.target, p))
          debug('start', isESM ? '(import)' : '(require)', filePath)
          // If no hook is found using the identifier, then we should `search` for the hook but only if the hook identifier is 'default'
          // A named identifier (e.g. MY_HOOK) that isn't found indicates that the hook isn't implemented in the plugin.
          const hookFn = module[hook.identifier] ?? (hook.identifier === 'default' ? search(module) : undefined)
          if (!hookFn) {
            debug('No hook found for hook definition:', hook)
            continue
          }

          const result = timeout
            ? await withTimeout(timeout, hookFn.call(context, {...(opts as any), config: this, context}))
            : await hookFn.call(context, {...(opts as any), config: this, context})
          final.successes.push({plugin: p, result})

          if (p.name === '@oclif/plugin-legacy' && event === 'init') {
            this.insertLegacyPlugins(result as IPlugin[])
          }

          debug('done')
        } catch (error: any) {
          final.failures.push({error: error as Error, plugin: p})
          debug(error)
          // Do not throw the error if
          // captureErrors is set to true
          // error.oclif.exit is undefined or 0
          // error.code is MODULE_NOT_FOUND
          if (
            !captureErrors &&
            error.oclif?.exit !== undefined &&
            error.oclif?.exit !== 0 &&
            error.code !== 'MODULE_NOT_FOUND'
          )
            throw error
        }

        marker?.addDetails({
          event,
          hook: hook.target,
          plugin: p.name,
        })
        marker?.stop()
      }
    })

    await Promise.all(promises)

    debug('%s hook done', event)

    marker?.stop()
    return final
  }

  public s3Key(
    type: keyof S3Templates,
    ext?: '.tar.gz' | '.tar.xz' | IConfig.s3Key.Options,
    options: IConfig.s3Key.Options = {},
  ): string {
    if (typeof ext === 'object') options = ext
    else if (ext) options.ext = ext
    const template = this.updateConfig.s3?.templates?.[options.platform ? 'target' : 'vanilla'][type] ?? ''
    return ejs.render(template, {...(this as any), ...options})
  }

  public s3Url(key: string): string {
    const {host} = this.updateConfig.s3 ?? {host: undefined}
    if (!host) throw new Error('no s3 host is set')
    const url = new URL(host)
    url.pathname = join(url.pathname, key)
    return url.toString()
  }

  public scopedEnvVar(k: string): string | undefined {
    return process.env[this.scopedEnvVarKeys(k).find((k) => process.env[k]) as string]
  }

  /**
   * this DOES NOT account for bin aliases, use scopedEnvVarKeys instead which will account for bin aliases
   * @param k {string}, the unscoped key you want to get the value for
   * @returns {string} returns the env var key
   */
  public scopedEnvVarKey(k: string): string {
    return [this.bin, k]
      .map((p) => p.replaceAll('@', '').replaceAll(/[/-]/g, '_'))
      .join('_')
      .toUpperCase()
  }

  /**
   * gets the scoped env var keys for a given key, including bin aliases
   * @param k {string}, the env key e.g. 'debug'
   * @returns {string[]} e.g. ['SF_DEBUG', 'SFDX_DEBUG']
   */
  public scopedEnvVarKeys(k: string): string[] {
    return [this.bin, ...(this.binAliases ?? [])]
      .filter(Boolean)
      .map((alias) => [alias.replaceAll('@', '').replaceAll(/[/-]/g, '_'), k].join('_').toUpperCase())
  }

  public scopedEnvVarTrue(k: string): boolean {
    const v = this.scopedEnvVar(k)
    return v === '1' || v === 'true'
  }

  protected windowsHome(): string | undefined {
    return this.windowsHomedriveHome() || this.windowsUserprofileHome()
  }

  protected windowsHomedriveHome(): string | undefined {
    return process.env.HOMEDRIVE && process.env.HOMEPATH && join(process.env.HOMEDRIVE!, process.env.HOMEPATH!)
  }

  protected windowsUserprofileHome(): string | undefined {
    return process.env.USERPROFILE
  }

  private buildS3Config() {
    const s3 = this.pjson.oclif.update?.s3
    const bucket = this.scopedEnvVar('S3_BUCKET') ?? s3?.bucket
    const host = s3?.host ?? (bucket && `https://${bucket}.s3.amazonaws.com`)
    const templates = {
      ...s3?.templates,
      target: {
        baseDir: '<%- bin %>',
        manifest: "<%- channel === 'stable' ? '' : 'channels/' + channel + '/' %><%- platform %>-<%- arch %>",
        unversioned:
          "<%- channel === 'stable' ? '' : 'channels/' + channel + '/' %><%- bin %>-<%- platform %>-<%- arch %><%- ext %>",
        versioned:
          "<%- channel === 'stable' ? '' : 'channels/' + channel + '/' %><%- bin %>-v<%- version %>/<%- bin %>-v<%- version %>-<%- platform %>-<%- arch %><%- ext %>",
        ...(s3?.templates && s3?.templates.target),
      },
      vanilla: {
        baseDir: '<%- bin %>',
        manifest: "<%- channel === 'stable' ? '' : 'channels/' + channel + '/' %>version",
        unversioned: "<%- channel === 'stable' ? '' : 'channels/' + channel + '/' %><%- bin %><%- ext %>",
        versioned:
          "<%- channel === 'stable' ? '' : 'channels/' + channel + '/' %><%- bin %>-v<%- version %>/<%- bin %>-v<%- version %><%- ext %>",
        ...(s3?.templates && s3?.templates.vanilla),
      },
    }
    return {
      bucket,
      host,
      templates,
    }
  }

  private getCmdLookupId(id: string): string {
    if (this._commands.has(id)) return id
    if (this.commandPermutations.hasValid(id)) return this.commandPermutations.getValid(id)!
    return id
  }

  private getTopicLookupId(id: string): string {
    if (this._topics.has(id)) return id
    if (this.topicPermutations.hasValid(id)) return this.topicPermutations.getValid(id)!
    return id
  }

  /**
   * Insert legacy plugins
   *
   * Replace invalid CLI plugins (cli-engine plugins, mostly Heroku) loaded via `this.loadPlugins`
   * with oclif-compatible ones returned by @oclif/plugin-legacy init hook.
   *
   * @param plugins array of oclif-compatible plugins
   */
  private insertLegacyPlugins(plugins: IPlugin[]) {
    for (const plugin of plugins) {
      this.plugins.set(plugin.name, plugin)

      // Delete all commands from the legacy plugin so that we can re-add them.
      // This is necessary because determinePriority will pick the initial
      // command that was added, which won't have been converted by PluginLegacy yet.
      for (const cmd of plugin.commands ?? []) {
        this._commands.delete(cmd.id)
        for (const alias of [...(cmd.aliases ?? []), ...(cmd.hiddenAliases ?? [])]) {
          this._commands.delete(alias)
        }
      }

      this.loadCommands(plugin)
    }
  }

  private isJitPluginCommand(c: Command.Loadable): boolean {
    // Return true if the command's plugin is listed under oclif.jitPlugins AND if the plugin hasn't been loaded to this.plugins
    return (
      Object.keys(this.pjson.oclif.jitPlugins ?? {}).includes(c.pluginName ?? '') &&
      Boolean(c?.pluginName && !this.plugins.has(c.pluginName))
    )
  }

  private loadCommands(plugin: IPlugin) {
    const marker = Performance.mark(OCLIF_MARKER_OWNER, `config.loadCommands#${plugin.name}`, {plugin: plugin.name})
    for (const command of plugin.commands) {
      // set canonical command id
      if (this._commands.has(command.id)) {
        const prioritizedCommand = determinePriority(this.pjson.oclif.plugins ?? [], [
          this._commands.get(command.id)!,
          command,
        ])
        this._commands.set(prioritizedCommand.id, prioritizedCommand)
      } else {
        this._commands.set(command.id, command)
      }

      // v3 moved command id permutations to the manifest, but some plugins may not have
      // the new manifest yet. For those, we need to calculate the permutations here.
      const permutations =
        this.flexibleTaxonomy && command.permutations === undefined
          ? getCommandIdPermutations(command.id)
          : (command.permutations ?? [command.id])
      // set every permutation
      for (const permutation of permutations) {
        this.commandPermutations.add(permutation, command.id)
      }

      const handleAlias = (alias: string, hidden = false) => {
        const aliasWithDefaultTopicSeparator = toStandardizedId(alias, this)
        if (this._commands.has(aliasWithDefaultTopicSeparator)) {
          const prioritizedCommand = determinePriority(this.pjson.oclif.plugins ?? [], [
            this._commands.get(aliasWithDefaultTopicSeparator)!,
            command,
          ])
          this._commands.set(aliasWithDefaultTopicSeparator, {
            ...prioritizedCommand,
            id: aliasWithDefaultTopicSeparator,
          })
        } else {
          this._commands.set(aliasWithDefaultTopicSeparator, {...command, hidden, id: aliasWithDefaultTopicSeparator})
        }

        // set every permutation of the aliases
        // v3 moved command alias permutations to the manifest, but some plugins may not have
        // the new manifest yet. For those, we need to calculate the permutations here.
        const aliasPermutations =
          this.flexibleTaxonomy && command.aliasPermutations === undefined
            ? getCommandIdPermutations(aliasWithDefaultTopicSeparator)
            : (command.permutations ?? [aliasWithDefaultTopicSeparator])
        // set every permutation
        for (const permutation of aliasPermutations) {
          this.commandPermutations.add(permutation, command.id)
        }
      }

      // set command aliases
      for (const alias of command.aliases ?? []) {
        handleAlias(alias)
      }

      // set hidden command aliases
      for (const alias of command.hiddenAliases ?? []) {
        handleAlias(alias, true)
      }
    }

    marker?.addDetails({commandCount: plugin.commands.length})
    marker?.stop()
  }

  private loadTopics(plugin: IPlugin) {
    const marker = Performance.mark(OCLIF_MARKER_OWNER, `config.loadTopics#${plugin.name}`, {plugin: plugin.name})
    for (const topic of compact(plugin.topics)) {
      const existing = this._topics.get(topic.name)
      if (existing) {
        existing.description = topic.description || existing.description
        existing.hidden = existing.hidden || topic.hidden
      } else {
        this._topics.set(topic.name, topic)
      }

      const permutations = this.flexibleTaxonomy ? getCommandIdPermutations(topic.name) : [topic.name]
      for (const permutation of permutations) {
        this.topicPermutations.add(permutation, topic.name)
      }
    }

    // Add missing topics for displaying help when partial commands are entered.
    for (const c of plugin.commands.filter((c) => !c.hidden)) {
      const parts = c.id.split(':')
      while (parts.length > 0) {
        const name = parts.join(':')
        if (name && !this._topics.has(name)) {
          this._topics.set(name, {description: c.summary || c.description, name})
        }

        parts.pop()
      }
    }

    marker?.stop()
  }

  private maybeAdjustDebugSetting(): void {
    if (this.scopedEnvVarTrue('DEBUG')) {
      settings.debug = true
      displayWarnings()
    }
  }

  private warn(err: {detail: string; name: string} | Error | string, scope?: string): void {
    if (this.warned) return

    if (typeof err === 'string') {
      process.emitWarning(err)
      return
    }

    if (err instanceof Error) {
      const modifiedErr: any = err
      modifiedErr.name = `${err.name} Plugin: ${this.name}`
      modifiedErr.detail = compact([
        (err as any).detail,
        `module: ${this._base}`,
        scope && `task: ${scope}`,
        `plugin: ${this.name}`,
        `root: ${this.root}`,
        'See more details with DEBUG=*',
      ]).join('\n')
      process.emitWarning(err)
      return
    }

    // err is an object
    process.emitWarning('Config.warn expected either a string or Error, but instead received an object')
    err.name = `${err.name} Plugin: ${this.name}`
    err.detail = compact([
      err.detail,
      `module: ${this._base}`,
      scope && `task: ${scope}`,
      `plugin: ${this.name}`,
      `root: ${this.root}`,
      'See more details with DEBUG=*',
    ]).join('\n')

    process.emitWarning(JSON.stringify(err))
  }
}
````

## File: src/config/index.ts
````typescript
export {Config} from './config'
export {Plugin} from './plugin'
export {tsPath} from './ts-path'
````

## File: src/config/plugin-loader.ts
````typescript
import {minimatch} from 'minimatch'
import {join} from 'node:path'

import {PJSON} from '../interfaces'
import {Plugin as IPlugin, Options} from '../interfaces/plugin'
import {OCLIF_MARKER_OWNER, Performance} from '../performance'
import {readJson} from '../util/fs'
import {isProd} from '../util/util'
import {Plugin} from './plugin'
import {makeDebug} from './util'

const debug = makeDebug()

type PluginLoaderOptions = {
  plugins?: IPlugin[] | PluginsMap | undefined
  root: string
}

type LoadOpts = {
  dataDir: string
  devPlugins?: boolean | undefined
  force?: boolean | undefined
  rootPlugin: IPlugin
  userPlugins?: boolean | undefined
  pluginAdditions?:
    | {
        core?: string[]
        dev?: string[]
        path?: string
      }
    | undefined
}

type PluginsMap = Map<string, IPlugin>

function findMatchingDependencies(dependencies: Record<string, string>, patterns: string[]): string[] {
  return Object.keys(dependencies).filter((p) => patterns.some((w) => minimatch(p, w)))
}

export default class PluginLoader {
  public errors: (Error | string)[] = []
  public plugins: PluginsMap = new Map()
  private pluginsProvided = false

  constructor(public options: PluginLoaderOptions) {
    if (options.plugins) {
      this.pluginsProvided = true
      this.plugins = Array.isArray(options.plugins) ? new Map(options.plugins.map((p) => [p.name, p])) : options.plugins
    }
  }

  public async loadChildren(opts: LoadOpts): Promise<{errors: (Error | string)[]; plugins: PluginsMap}> {
    if (!this.pluginsProvided || opts.force) {
      await this.loadUserPlugins(opts)
      await this.loadDevPlugins(opts)
      await this.loadCorePlugins(opts)
    }

    return {errors: this.errors, plugins: this.plugins}
  }

  public async loadRoot({pjson}: {pjson?: PJSON | undefined}): Promise<IPlugin> {
    let rootPlugin: IPlugin
    if (this.pluginsProvided) {
      const plugins = [...this.plugins.values()]
      rootPlugin = plugins.find((p) => p.root === this.options.root) ?? plugins[0]
    } else {
      const marker = Performance.mark(OCLIF_MARKER_OWNER, 'plugin.load#root')
      rootPlugin = new Plugin({isRoot: true, pjson, root: this.options.root})
      await rootPlugin.load()
      marker?.addDetails({
        commandCount: rootPlugin.commands.length,
        hasManifest: rootPlugin.hasManifest ?? false,
        name: rootPlugin.name,
        topicCount: rootPlugin.topics.length,
        type: rootPlugin.type,
        usesMain: Boolean(rootPlugin.pjson.main),
      })
      marker?.stop()
    }

    this.plugins.set(rootPlugin.name, rootPlugin)
    return rootPlugin
  }

  private async loadCorePlugins(opts: LoadOpts): Promise<void> {
    const {plugins: corePlugins} = opts.rootPlugin.pjson.oclif
    if (corePlugins) {
      const plugins = findMatchingDependencies(opts.rootPlugin.pjson.dependencies ?? {}, corePlugins)
      await this.loadPlugins(opts.rootPlugin.root, 'core', plugins)
    }

    const {core: pluginAdditionsCore, path} = opts.pluginAdditions ?? {core: []}
    if (pluginAdditionsCore) {
      if (path) {
        // If path is provided, load plugins from the path
        const pjson = await readJson<PJSON>(join(path, 'package.json'))
        const plugins = findMatchingDependencies(pjson.dependencies ?? {}, pluginAdditionsCore)
        await this.loadPlugins(path, 'core', plugins)
      } else {
        const plugins = findMatchingDependencies(opts.rootPlugin.pjson.dependencies ?? {}, pluginAdditionsCore)
        await this.loadPlugins(opts.rootPlugin.root, 'core', plugins)
      }
    }
  }

  private async loadDevPlugins(opts: LoadOpts): Promise<void> {
    if (opts.devPlugins !== false) {
      // do not load oclif.devPlugins in production
      if (isProd()) return
      try {
        const {devPlugins} = opts.rootPlugin.pjson.oclif
        if (devPlugins) {
          const allDeps = {...opts.rootPlugin.pjson.dependencies, ...opts.rootPlugin.pjson.devDependencies}
          const plugins = findMatchingDependencies(allDeps ?? {}, devPlugins)
          await this.loadPlugins(opts.rootPlugin.root, 'dev', plugins)
        }

        const {dev: pluginAdditionsDev, path} = opts.pluginAdditions ?? {core: []}
        if (pluginAdditionsDev) {
          if (path) {
            // If path is provided, load plugins from the path
            const pjson = await readJson<PJSON>(join(path, 'package.json'))
            const allDeps = {...pjson.dependencies, ...pjson.devDependencies}
            const plugins = findMatchingDependencies(allDeps ?? {}, pluginAdditionsDev)
            await this.loadPlugins(path, 'dev', plugins)
          } else {
            const allDeps = {...opts.rootPlugin.pjson.dependencies, ...opts.rootPlugin.pjson.devDependencies}
            const plugins = findMatchingDependencies(allDeps ?? {}, pluginAdditionsDev)
            await this.loadPlugins(opts.rootPlugin.root, 'dev', plugins)
          }
        }
      } catch (error: any) {
        process.emitWarning(error)
      }
    }
  }

  private async loadPlugins(
    root: string,
    type: string,
    plugins: ({name?: string; root?: string; tag?: string; url?: string} | string)[],
    parent?: Plugin,
  ): Promise<void> {
    if (!plugins || plugins.length === 0) return
    const mark = Performance.mark(OCLIF_MARKER_OWNER, `config.loadPlugins#${type}`)
    debug('loading plugins', plugins)
    await Promise.all(
      (plugins || []).map(async (plugin) => {
        try {
          const name = typeof plugin === 'string' ? plugin : plugin.name!
          const opts: Options = {
            name,
            root,
            type,
          }
          if (typeof plugin !== 'string') {
            opts.tag = plugin.tag || opts.tag
            opts.root = plugin.root || opts.root
            opts.url = plugin.url
          }

          if (parent) {
            opts.parent = parent
          }

          if (this.plugins.has(name)) return
          const pluginMarker = Performance.mark(OCLIF_MARKER_OWNER, `plugin.load#${name}`)
          const instance = new Plugin(opts)
          await instance.load()
          pluginMarker?.addDetails({
            commandCount: instance.commands.length,
            hasManifest: instance.hasManifest,
            name: instance.name,
            topicCount: instance.topics.length,
            type: instance.type,
            usesMain: Boolean(instance.pjson.main),
          })
          pluginMarker?.stop()

          this.plugins.set(instance.name, instance)
          if (parent) {
            instance.parent = parent
            if (!parent.children) parent.children = []
            parent.children.push(instance)
          }

          if (instance.pjson.oclif.plugins) {
            const allDeps =
              type === 'dev'
                ? {...instance.pjson.dependencies, ...instance.pjson.devDependencies}
                : instance.pjson.dependencies
            const plugins = findMatchingDependencies(allDeps ?? {}, instance.pjson.oclif.plugins)
            await this.loadPlugins(instance.root, type, plugins, instance)
          }
        } catch (error: any) {
          this.errors.push(error)
        }
      }),
    )

    mark?.addDetails({pluginCount: plugins.length})
    mark?.stop()
  }

  private async loadUserPlugins(opts: LoadOpts): Promise<void> {
    if (opts.userPlugins !== false) {
      try {
        const userPJSONPath = join(opts.dataDir, 'package.json')
        debug('reading user plugins pjson %s', userPJSONPath)
        // ignore cache because the file might have changed within the same process (e.g. during a JIT plugin install)
        const pjson = await readJson<PJSON>(userPJSONPath, false)
        if (!pjson.oclif) pjson.oclif = {schema: 1}
        if (!pjson.oclif.plugins) pjson.oclif.plugins = []
        await this.loadPlugins(
          userPJSONPath,
          'user',
          pjson.oclif.plugins.filter((p: any) => p.type === 'user'),
        )
        await this.loadPlugins(
          userPJSONPath,
          'link',
          pjson.oclif.plugins.filter((p: any) => p.type === 'link'),
        )
      } catch (error: any) {
        if (error.code !== 'ENOENT') process.emitWarning(error)
      }
    }
  }
}
````

## File: src/config/plugin.ts
````typescript
import {join, parse, relative, sep} from 'node:path'
import {inspect} from 'node:util'
import {glob} from 'tinyglobby'

import Cache from '../cache'
import {Command} from '../command'
import {CLIError, error} from '../errors'
import {Manifest} from '../interfaces/manifest'
import {CommandDiscovery, HookOptions, PJSON} from '../interfaces/pjson'
import {Plugin as IPlugin, PluginOptions} from '../interfaces/plugin'
import {Topic} from '../interfaces/topic'
import {load, loadWithData, loadWithDataFromManifest} from '../module-loader'
import {OCLIF_MARKER_OWNER, Performance} from '../performance'
import {SINGLE_COMMAND_CLI_SYMBOL} from '../symbols'
import {cacheCommand} from '../util/cache-command'
import {findRoot} from '../util/find-root'
import {readJson} from '../util/fs'
import {readPjson} from '../util/read-pjson'
import {castArray, compact} from '../util/util'
import {tsPath} from './ts-path'
import {getCommandIdPermutations, makeDebug} from './util'

const _pjson = Cache.getInstance().get('@oclif/core')

function topicsToArray(input: any, base?: string): Topic[] {
  if (!input) return []
  base = base ? `${base}:` : ''
  if (Array.isArray(input)) {
    return [...input, input.flatMap((t) => topicsToArray(t.subtopics, `${base}${t.name}`))]
  }

  return Object.keys(input).flatMap((k) => {
    input[k].name = k
    return [{...input[k], name: `${base}${k}`}, ...topicsToArray(input[k].subtopics, `${base}${input[k].name}`)]
  })
}

const cachedCommandCanBeUsed = (manifest: Manifest | undefined, id: string): boolean =>
  Boolean(manifest?.commands[id] && 'isESM' in manifest.commands[id] && 'relativePath' in manifest.commands[id])

const searchForCommandClass = (cmd: any) => {
  if (typeof cmd.run === 'function') return cmd
  if (cmd.default && cmd.default.run) return cmd.default
  return Object.values(cmd).find((cmd: any) => typeof cmd.run === 'function')
}

const ensureCommandClass = (cmd: any) => {
  if (cmd && typeof cmd.run === 'function') return cmd
}

const GLOB_PATTERNS = [
  '**/*.+(js|cjs|mjs|ts|tsx|mts|cts)',
  '!**/*.+(d.ts|test.ts|test.js|spec.ts|spec.js|d.mts|d.cts)?(x)',
]

function processCommandIds(files: string[]): string[] {
  return files.map((file) => {
    const p = parse(file)
    const topics = p.dir.split('/')
    const command = p.name !== 'index' && p.name
    const id = [...topics, command].filter(Boolean).join(':')
    return id === '' ? SINGLE_COMMAND_CLI_SYMBOL : id
  })
}

function determineCommandDiscoveryOptions(
  commandDiscovery: string | CommandDiscovery | undefined,
): CommandDiscovery | undefined {
  if (!commandDiscovery) return

  if (typeof commandDiscovery === 'string') {
    return {globPatterns: GLOB_PATTERNS, strategy: 'pattern', target: commandDiscovery}
  }

  if (!commandDiscovery.target) throw new CLIError('`oclif.commandDiscovery.target` is required.')
  if (!commandDiscovery.strategy) throw new CLIError('`oclif.commandDiscovery.strategy` is required.')

  if (commandDiscovery.strategy === 'explicit' && !commandDiscovery.identifier) {
    commandDiscovery.identifier = 'default'
  }

  return commandDiscovery
}

function determineHookOptions(hook: string | HookOptions): HookOptions {
  if (typeof hook === 'string') return {identifier: 'default', target: hook}
  if (!hook.identifier) return {...hook, identifier: 'default'}
  return hook
}

/**
 * Cached commands, where the key is the command ID and the value is the command class.
 *
 * This is only populated if the `strategy` is `explicit` and the `target` is a file that default exports the id-to-command-class object.
 * Or if the strategy is `single` and the `target` is the file containing a command class.
 */
type CommandCache = Record<string, Command.Class>

export class Plugin implements IPlugin {
  _base = `${_pjson.name}@${_pjson.version}`
  protected _debug = makeDebug()
  alias!: string
  alreadyLoaded = false
  children: Plugin[] = []
  commandIDs: string[] = []
  // This will be initialized in the _manifest() method, which gets called in the load() method.
  commands!: Command.Loadable[]
  commandsDir: string | undefined
  hasManifest = false
  hooks!: {[key: string]: HookOptions[]}
  isRoot = false
  manifest!: Manifest
  moduleType!: 'commonjs' | 'module'
  name!: string
  parent?: Plugin | undefined
  pjson!: PJSON
  root!: string
  tag?: string | undefined
  type!: string
  valid = false
  version!: string
  private commandCache: CommandCache | undefined
  private commandDiscoveryOpts: CommandDiscovery | undefined
  private flexibleTaxonomy!: boolean

  constructor(public options: PluginOptions) {}

  public get topics(): Topic[] {
    return topicsToArray(this.pjson.oclif.topics || {})
  }

  public async findCommand(id: string, opts: {must: true}): Promise<Command.Class>

  public async findCommand(id: string, opts?: {must: boolean}): Promise<Command.Class | undefined>

  public async findCommand(id: string, opts: {must?: boolean} = {}): Promise<Command.Class | undefined> {
    const marker = Performance.mark(OCLIF_MARKER_OWNER, `plugin.findCommand#${this.name}.${id}`, {
      id,
      plugin: this.name,
    })

    const fetch = async () => {
      if (this.commandDiscoveryOpts?.strategy === 'pattern') {
        const commandsDir = await this.getCommandsDir()
        if (!commandsDir) return
        let module
        let isESM: boolean | undefined
        let filePath: string | undefined
        try {
          ;({filePath, isESM, module} = cachedCommandCanBeUsed(this.manifest, id)
            ? await loadWithDataFromManifest(this.manifest.commands[id], this.root)
            : await loadWithData(this, join(commandsDir ?? this.pjson.oclif.commands, ...id.split(':'))))
          this._debug(isESM ? '(import)' : '(require)', filePath)
        } catch (error: any) {
          if (!opts.must && error.code === 'MODULE_NOT_FOUND') return
          throw error
        }

        const cmd = searchForCommandClass(module)
        if (!cmd) return
        cmd.id = id
        cmd.plugin = this
        cmd.isESM = isESM
        cmd.relativePath = relative(this.root, filePath || '').split(sep)
        return cmd
      }

      if (this.commandDiscoveryOpts?.strategy === 'single' || this.commandDiscoveryOpts?.strategy === 'explicit') {
        const commandCache = await this.loadCommandsFromTarget()
        const cmd = ensureCommandClass(commandCache?.[id])
        if (!cmd) return

        cmd.id = id
        cmd.plugin = this
        return cmd
      }
    }

    const cmd = await fetch()
    if (!cmd && opts.must) error(`command ${id} not found`)
    marker?.stop()
    return cmd
  }

  // eslint-disable-next-line complexity
  public async load(): Promise<void> {
    this.type = this.options.type ?? 'core'
    this.tag = this.options.tag
    this.isRoot = this.options.isRoot ?? false
    if (this.options.parent) this.parent = this.options.parent as Plugin
    // Linked plugins already have a root so there's no need to search for it.
    // However there could be child plugins nested inside the linked plugin, in which
    // case we still need to search for the child plugin's root.
    const root =
      this.options.pjson && this.options.isRoot
        ? this.options.root
        : this.type === 'link' && !this.parent
          ? this.options.root
          : await findRoot(this.options.name, this.options.root)
    if (!root) throw new CLIError(`could not find package.json with ${inspect(this.options)}`)
    this.root = root
    this._debug(`loading ${this.type} plugin from ${root}`)
    this.pjson = this.options.pjson ?? (await readPjson(root))
    this.flexibleTaxonomy = this.options?.flexibleTaxonomy || this.pjson.oclif?.flexibleTaxonomy || false
    this.moduleType = this.pjson.type === 'module' ? 'module' : 'commonjs'
    this.name = this.pjson.name
    this.alias = this.options.name ?? this.pjson.name
    if (!this.name) throw new CLIError(`no name in package.json (${root})`)

    this._debug = makeDebug(this.name)
    this.version = this.pjson.version
    if (this.pjson.oclif) {
      this.valid = true
    } else {
      this.pjson.oclif = this.pjson['cli-engine'] || {}
    }

    this.hooks = Object.fromEntries(
      Object.entries(this.pjson.oclif.hooks ?? {}).map(([k, v]) => [
        k,
        castArray<string | HookOptions>(v).map((v) => determineHookOptions(v)),
      ]),
    )

    this.commandDiscoveryOpts = determineCommandDiscoveryOptions(this.pjson.oclif?.commands)

    this._debug('command discovery options', this.commandDiscoveryOpts)

    this.manifest = await this._manifest()
    this.commands = Object.entries(this.manifest.commands)
      .map(([id, c]) => ({
        ...c,
        load: async () => this.findCommand(id, {must: true}),
        pluginAlias: this.alias,
        pluginType: c.pluginType === 'jit' ? 'jit' : this.type,
      }))
      .sort((a, b) => a.id.localeCompare(b.id))
  }

  private async _manifest(): Promise<Manifest> {
    const ignoreManifest = Boolean(this.options.ignoreManifest)
    const errorOnManifestCreate = Boolean(this.options.errorOnManifestCreate)
    const respectNoCacheDefault = Boolean(this.options.respectNoCacheDefault)

    const readManifest = async (dotfile = false): Promise<Manifest | undefined> => {
      try {
        const p = join(this.root, `${dotfile ? '.' : ''}oclif.manifest.json`)
        const manifest = await readJson<Manifest>(p)
        if (!process.env.OCLIF_NEXT_VERSION && manifest.version.split('-')[0] !== this.version.split('-')[0]) {
          process.emitWarning(
            `Mismatched version in ${this.name} plugin manifest. Expected: ${this.version} Received: ${manifest.version}\nThis usually means you have an oclif.manifest.json file that should be deleted in development. This file should be automatically generated when publishing.`,
          )
        } else {
          this._debug('using manifest from', p)
          this.hasManifest = true
          return manifest
        }
      } catch (error: any) {
        if (error.code === 'ENOENT') {
          if (!dotfile) return readManifest(true)
        } else {
          this.warn(error, 'readManifest')
        }
      }
    }

    const marker = Performance.mark(OCLIF_MARKER_OWNER, `plugin.manifest#${this.name}`, {plugin: this.name})
    if (!ignoreManifest) {
      const manifest = await readManifest()
      if (manifest) {
        marker?.addDetails({commandCount: Object.keys(manifest.commands).length, fromCache: true})
        marker?.stop()
        this.commandIDs = Object.keys(manifest.commands)
        return manifest
      }
    }

    this.commandIDs = await this.getCommandIDs()
    const manifest = {
      commands: (
        await Promise.all(
          this.commandIDs.map(async (id) => {
            try {
              const found = await this.findCommand(id, {must: true})
              const cached = await cacheCommand(found, this, respectNoCacheDefault)

              // Ensure that id is set to the id being processed
              // This is necessary because the id is set by findCommand but if there
              // are multiple instances of a Command, then the id will be set to the
              // last one found.
              cached.id = id
              if (this.flexibleTaxonomy) {
                const permutations = getCommandIdPermutations(id)
                const aliasPermutations = cached.aliases.flatMap((a) => getCommandIdPermutations(a))
                return [id, {...cached, aliasPermutations, permutations} as Command.Cached]
              }

              return [id, cached]
            } catch (error: any) {
              const scope = `findCommand (${id})`
              if (Boolean(errorOnManifestCreate) === false) this.warn(error, scope)
              else throw this.addErrorScope(error, scope)
            }
          }),
        )
      )
        // eslint-disable-next-line unicorn/prefer-native-coercion-functions
        .filter((f): f is [string, Command.Cached] => Boolean(f))
        .reduce<{[k: string]: Command.Cached}>((commands, [id, c]) => {
          commands[id] = c
          return commands
        }, {}),
      version: this.version,
    }
    marker?.addDetails({commandCount: Object.keys(manifest.commands).length, fromCache: false})
    marker?.stop()
    return manifest
  }

  private addErrorScope(err: any, scope?: string) {
    err.name = err.name ?? inspect(err).trim()
    err.detail = compact([
      err.detail,
      `module: ${this._base}`,
      scope && `task: ${scope}`,
      `plugin: ${this.name}`,
      `root: ${this.root}`,
      ...(err.code ? [`code: ${err.code}`] : []),
      ...(err.message ? [`message: ${err.message}`] : []),
      'See more details with DEBUG=*',
    ]).join('\n')
    return err
  }

  private async getCommandIDs(): Promise<string[]> {
    const marker = Performance.mark(OCLIF_MARKER_OWNER, `plugin.getCommandIDs#${this.name}`, {plugin: this.name})

    let ids: string[]
    switch (this.commandDiscoveryOpts?.strategy) {
      case 'explicit': {
        ids = (await this.getCommandIdsFromTarget()) ?? []
        break
      }

      case 'pattern': {
        ids = await this.getCommandIdsFromPattern()
        break
      }

      case 'single': {
        ids = (await this.getCommandIdsFromTarget()) ?? []
        break
      }

      default: {
        ids = []
      }
    }

    this._debug('found commands', ids)
    marker?.addDetails({count: ids.length})
    marker?.stop()
    return ids
  }

  private async getCommandIdsFromPattern(): Promise<string[]> {
    const commandsDir = await this.getCommandsDir()
    if (!commandsDir) return []

    this._debug(`loading IDs from ${commandsDir}`)
    const files = await glob(this.commandDiscoveryOpts?.globPatterns ?? GLOB_PATTERNS, {cwd: commandsDir})
    return processCommandIds(files)
  }

  private async getCommandIdsFromTarget(): Promise<string[] | undefined> {
    const commandsFromExport = await this.loadCommandsFromTarget()
    if (commandsFromExport) {
      return Object.entries((await this.loadCommandsFromTarget()) ?? [])
        .filter(([, cmd]) => ensureCommandClass(cmd))
        .map(([id]) => id)
    }
  }

  private async getCommandsDir(): Promise<string | undefined> {
    if (this.commandsDir) return this.commandsDir

    this.commandsDir = await tsPath(this.root, this.commandDiscoveryOpts?.target, this)
    return this.commandsDir
  }

  private async loadCommandsFromTarget(): Promise<CommandCache | undefined> {
    if (this.commandCache) return this.commandCache

    if (this.commandDiscoveryOpts?.strategy === 'explicit' && this.commandDiscoveryOpts.target) {
      const filePath = await tsPath(this.root, this.commandDiscoveryOpts.target, this)
      const module = await load<Record<string, CommandCache>>(this, filePath)
      this.commandCache = module[this.commandDiscoveryOpts?.identifier ?? 'default'] ?? {}
      return this.commandCache
    }

    if (this.commandDiscoveryOpts?.strategy === 'single' && this.commandDiscoveryOpts.target) {
      const filePath = await tsPath(this.root, this.commandDiscoveryOpts?.target ?? this.root, this)
      const module = await load(this, filePath)
      this.commandCache = {[SINGLE_COMMAND_CLI_SYMBOL]: searchForCommandClass(module)}
      return this.commandCache
    }
  }

  private warn(err: CLIError | Error | string, scope?: string): void {
    if (typeof err === 'string') err = new Error(err)
    const warning = this.addErrorScope(err, scope)
    process.emitWarning(warning.name, warning)
  }
}
````

## File: src/config/ts-path.ts
````typescript
import {access} from 'node:fs/promises'
import {join, relative as pathRelative, sep} from 'node:path'
import {pathToFileURL} from 'node:url'
import * as TSNode from 'ts-node'

import Cache from '../cache'
import {memoizedWarn} from '../errors/warn'
import {Plugin, TSConfig} from '../interfaces'
import {settings} from '../settings'
import {existsSync} from '../util/fs'
import {readTSConfig} from '../util/read-tsconfig'
import {isProd, isTruthy} from '../util/util'
import {makeDebug} from './util'

const debug = makeDebug('ts-path')

export const TS_CONFIGS: Record<string, TSConfig | undefined> = {}
const REGISTERED = new Set<string>()

function determineRuntime(): 'node' | 'bun' | 'ts-node' | 'tsx' {
  /**
   * Examples:
   * #!/usr/bin/env bun
   * bun bin/run.js
   * bun bin/dev.js
   */
  if (process.execPath.split(sep).includes('bun')) return 'bun'
  /**
   * Examples:
   * #!/usr/bin/env node
   * #!/usr/bin/env node --loader ts-node/esm --experimental-specifier-resolution=node --no-warnings
   * node bin/run.js
   * node bin/dev.js
   */
  if (process.execArgv.length === 0) return 'node'
  /**
   * Examples:
   * #!/usr/bin/env ts-node
   * #!/usr/bin/env node_modules/.bin/ts-node
   * ts-node bin/run.js
   * ts-node bin/dev.js
   */
  if (process.execArgv[0] === '--require' && process.execArgv[1].split(sep).includes('ts-node')) return 'ts-node'
  if (process.execArgv[0].split(sep).includes('ts-node')) return 'ts-node'
  /**
   * Examples:
   * #!/usr/bin/env tsx
   * #!/usr/bin/env node_modules/.bin/tsx
   * tsx bin/run.js
   * tsx bin/dev.js
   */
  if (process.execArgv[0] === '--require' && process.execArgv[1].split(sep).includes('tsx')) return 'tsx'

  return 'node'
}

const RUN_TIME = determineRuntime()

function isErrno(error: any): error is NodeJS.ErrnoException {
  return 'code' in error && error.code === 'ENOENT'
}

async function loadTSConfig(root: string): Promise<TSConfig | undefined> {
  try {
    if (TS_CONFIGS[root]) return TS_CONFIGS[root]

    const tsconfig = await readTSConfig(root)
    if (!tsconfig) return
    debug('tsconfig: %O', tsconfig)
    TS_CONFIGS[root] = tsconfig
    return TS_CONFIGS[root]
  } catch (error) {
    if (isErrno(error)) return

    debug(`Could not parse tsconfig.json. Skipping typescript path lookup for ${root}.`)
    memoizedWarn(`Could not parse tsconfig.json for ${root}. Falling back to compiled source.`)
  }
}

async function registerTsx(root: string, moduleType: 'commonjs' | 'module' | undefined): Promise<void> {
  if (REGISTERED.has(root)) return

  try {
    const apiPath = moduleType === 'module' ? 'tsx/esm/api' : 'tsx/cjs/api'
    const tsxPath = require.resolve(apiPath, {paths: [root]})
    if (!tsxPath) return
    debug('registering tsx at', root)
    debug('tsx path:', tsxPath)
    const {href} = pathToFileURL(tsxPath)
    debug('tsx href:', href)
    const {register} = await import(href)
    debug('Successfully imported tsx')
    register()
    REGISTERED.add(root)
  } catch (error) {
    debug(`Could not find tsx. Skipping tsx registration for ${root}.`)
    debug(error)
  }
}

async function registerTSNode(root: string, tsconfig: TSConfig): Promise<void> {
  if (REGISTERED.has(root)) return

  debug('registering ts-node at', root)
  const tsNodePath = require.resolve('ts-node', {paths: [root, __dirname]})
  debug('ts-node path:', tsNodePath)

  let tsNode: typeof TSNode

  try {
    tsNode = require(tsNodePath)
    debug('Successfully required ts-node')
  } catch (error) {
    debug(`Could not find ts-node at ${tsNodePath}. Skipping ts-node registration for ${root}.`)
    debug(error)
    memoizedWarn(
      `Could not find ts-node at ${tsNodePath}. Please ensure that ts-node is a devDependency. Falling back to compiled source.`,
    )
    return
  }

  const typeRoots = [join(root, 'node_modules', '@types')]

  const rootDirs: string[] = []

  if (tsconfig.compilerOptions.rootDirs) {
    for (const r of tsconfig.compilerOptions.rootDirs) {
      rootDirs.push(join(root, r))
    }
  } else if (tsconfig.compilerOptions.rootDir) {
    rootDirs.push(join(root, tsconfig.compilerOptions.rootDir))
  } else if (tsconfig.compilerOptions.baseUrl) {
    rootDirs.push(join(root, tsconfig.compilerOptions.baseUrl))
  } else {
    rootDirs.push(join(root, 'src'))
  }

  // Because we need to provide a modified `rootDirs` to ts-node, we need to
  // remove `baseUrl` and `rootDir` from `compilerOptions` so that they
  // don't conflict.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const {baseUrl, rootDir, ...rest} = tsconfig.compilerOptions
  const conf: TSNode.RegisterOptions = {
    compilerOptions: {
      ...rest,
      rootDirs,
      typeRoots,
    },
    ...tsconfig['ts-node'],
    cwd: root,
    esm: tsconfig['ts-node']?.esm ?? true,
    experimentalSpecifierResolution: tsconfig['ts-node']?.experimentalSpecifierResolution ?? 'explicit',
    scope: true,
    scopeDir: root,
    skipProject: true,
    transpileOnly: true,
  }

  debug('ts-node options: %O', conf)
  tsNode.register(conf)
  REGISTERED.add(root)
}

/**
 * Skip ts-node registration for ESM plugins in production.
 * The node/ts-node ecosystem is not mature enough to support auto-transpiling ESM modules at this time.
 * See the following:
 * - https://github.com/TypeStrong/ts-node/issues/1791#issuecomment-1149754228
 * - https://github.com/nodejs/node/issues/49432
 * - https://github.com/nodejs/node/pull/49407
 * - https://github.com/nodejs/node/issues/34049
 *
 * We still register tsx/ts-node for ESM plugins when NODE_ENV is "test" or "development" and root plugin is also ESM
 * since that allows plugins to be auto-transpiled when developing locally using `bin/dev.js`.
 */
function cannotTranspileEsm(
  rootPlugin: Plugin | undefined,
  plugin: Plugin | undefined,
  isProduction: boolean,
): boolean {
  return (
    (isProduction || rootPlugin?.moduleType === 'commonjs') &&
    plugin?.moduleType === 'module' &&
    !plugin?.pjson.devDependencies?.tsx
  )
}

/**
 * If the dev script is run with ts-node for an ESM plugin, skip ts-node registration
 * and fall back on compiled source since ts-node executable cannot transpile ESM in Node 20+
 *
 * See the following:
 * https://nodejs.org/en/blog/announcements/v20-release-announce#custom-esm-loader-hooks-nearing-stable
 * https://github.com/oclif/core/issues/817
 * https://github.com/TypeStrong/ts-node/issues/1997
 */
function cannotUseTsNode(root: string, plugin: Plugin | undefined, isProduction: boolean): boolean {
  if (plugin?.moduleType !== 'module' || isProduction) return false

  const nodeMajor = Number.parseInt(process.version.replace('v', '').split('.')[0], 10)
  return RUN_TIME === 'ts-node' && nodeMajor >= 20
}

/**
 * Determine the path to the source file from the compiled ./lib files
 */
async function determinePath(root: string, orig: string, plugin: Plugin | undefined): Promise<string> {
  const tsconfig = await loadTSConfig(root)
  if (!tsconfig) return orig

  debug(`Determining path for ${orig}`)

  if (RUN_TIME === 'bun') {
    debug(`Skipping ts-node registration for ${root} because the runtime is: ${RUN_TIME}`)
  } else {
    // attempt to register tsx first. If it fails to register, we will fall back to ts-node
    await registerTsx(root, plugin?.moduleType)
    // if tsx registration succeeded, then this will exit early since the path will be in REGISTERED already
    await registerTSNode(root, tsconfig)
  }

  const {baseUrl, outDir, rootDir, rootDirs} = tsconfig.compilerOptions
  const rootDirPath = rootDir ?? (rootDirs ?? [])[0] ?? baseUrl
  if (!rootDirPath) {
    debug(`no rootDir, rootDirs, or baseUrl specified in tsconfig.json. Returning default path ${orig}`)
    return orig
  }

  if (!outDir) {
    debug(`no outDir specified in tsconfig.json. Returning default path ${orig}`)
    return orig
  }

  // rewrite path from ./lib/foo to ./src/foo
  const lib = join(root, outDir) // ./lib
  const src = join(root, rootDirPath) // ./src
  const relative = pathRelative(lib, orig) // ./commands
  // For hooks, it might point to a js file, not a module. Something like "./hooks/myhook.js" which doesn't need the js.
  const out = join(src, relative).replace(/\.js$/, '') // ./src/commands
  // this can be a directory of commands or point to a hook file
  // if it's a directory, we check if the path exists. If so, return the path to the directory.
  // For hooks, it might point to a module, not a file. Something like "./hooks/myhook"
  // That file doesn't exist, and the real file is "./hooks/myhook.ts"
  // In that case we attempt to resolve to the filename. If it fails it will revert back to the lib path

  debug(`lib dir: ${lib}`)
  debug(`src dir: ${src}`)
  debug(`src directory to find: ${out}`)

  if (existsSync(out)) {
    debug(`Found source directory for ${orig} at ${out}`)
    return out
  }

  const sourceFiles = await Promise.all([
    access(`${out}.ts`)
      .then(() => `${out}.ts`)
      .catch(() => false),
    access(`${out}.tsx`)
      .then(() => `${out}.tsx`)
      .catch(() => false),
  ])

  if (sourceFiles.some(Boolean)) {
    debug(`Found source file for ${orig} at ${out}`)
    return out
  }

  debug(`No source file found. Returning default path ${orig}`)
  if (!isProd()) memoizedWarn(`Could not find source for ${orig} based on tsconfig. Defaulting to compiled source.`)

  return orig
}

/**
 * Convert a path from the compiled ./lib files to the ./src typescript source
 * this is for developing typescript plugins/CLIs
 * if there is a tsconfig and the original sources exist, it attempts to require ts-node
 */
export async function tsPath(root: string, orig: string, plugin: Plugin): Promise<string>
export async function tsPath(
  root: string,
  orig: string | undefined,
  plugin?: Plugin | undefined,
): Promise<string | undefined>
export async function tsPath(
  root: string,
  orig: string | undefined,
  plugin?: Plugin | undefined,
): Promise<string | undefined> {
  const rootPlugin = plugin?.options.isRoot ? plugin : Cache.getInstance().get('rootPlugin')

  if (!orig) return orig
  orig = orig.startsWith(root) ? orig : join(root, orig)

  // NOTE: The order of these checks matter!

  const enableAutoTranspile = settings.enableAutoTranspile ?? settings.tsnodeEnabled

  if (enableAutoTranspile === false) {
    debug(`Skipping typescript path lookup for ${root} because enableAutoTranspile is explicitly set to false`)
    return orig
  }

  const isProduction = isProd()

  // Do not skip ts-node registration if the plugin is linked
  if (enableAutoTranspile === undefined && isProduction && plugin?.type !== 'link') {
    debug(`Skipping typescript path lookup for ${root} because NODE_ENV is NOT "test" or "development"`)
    return orig
  }

  if (cannotTranspileEsm(rootPlugin, plugin, isProduction)) {
    debug(
      `Skipping typescript path lookup for ${root} because it's an ESM module (NODE_ENV: ${process.env.NODE_ENV}, root plugin module type: ${rootPlugin?.moduleType})`,
    )

    const warningIsDisabled =
      process.env.OCLIF_DISABLE_LINKED_ESM_WARNING && isTruthy(process.env.OCLIF_DISABLE_LINKED_ESM_WARNING)

    // Only warn if the plugin is linked AND the warning is not disabled
    if (plugin?.type === 'link' && !warningIsDisabled)
      memoizedWarn(
        `${plugin?.name} is a linked ESM module and cannot be auto-transpiled. Existing compiled source will be used instead.`,
      )
    return orig
  }

  if (cannotUseTsNode(root, plugin, isProduction)) {
    debug(`Skipping typescript path lookup for ${root} because ts-node is run in node version ${process.version}"`)
    memoizedWarn(
      `ts-node executable cannot transpile ESM in Node 20. Existing compiled source will be used instead. See https://github.com/oclif/core/issues/817.`,
    )
    return orig
  }

  try {
    return await determinePath(root, orig, plugin)
  } catch (error: any) {
    debug(error)
    return orig
  }
}
````

## File: src/config/util.ts
````typescript
import {getLogger} from '../logger'

export function makeDebug(...scope: string[]): (..._: any) => void {
  return (formatter: unknown, ...args: unknown[]) => getLogger(['config', ...scope].join(':')).debug(formatter, ...args)
}

// Adapted from https://github.com/angus-c/just/blob/master/packages/array-permutations/index.js
export function getPermutations(arr: string[]): Array<string[]> {
  if (arr.length === 0) return []
  if (arr.length === 1) return [arr]

  const output = []
  const partialPermutations = getPermutations(arr.slice(1))
  const first = arr[0]

  for (let i = 0, len = partialPermutations.length; i < len; i++) {
    const partial = partialPermutations[i]

    for (let j = 0, len2 = partial.length; j <= len2; j++) {
      const start = partial.slice(0, j)
      const end = partial.slice(j)
      const merged = [...start, first, ...end]

      output.push(merged)
    }
  }

  return output
}

export function getCommandIdPermutations(commandId: string): string[] {
  return getPermutations(commandId.split(':')).flatMap((c) => c.join(':'))
}

/**
 * Return an array of ids that represent all the usable combinations that a user could enter.
 *
 * For example, if the command ids are:
 * - foo:bar:baz
 * - one:two:three
 * Then the usable ids would be:
 * - foo
 * - foo:bar
 * - foo:bar:baz
 * - one
 * - one:two
 * - one:two:three
 *
 * This allows us to determine which parts of the argv array belong to the command id whenever the topicSeparator is a space.
 *
 * @param commandIds string[]
 * @returns string[]
 */
export const collectUsableIds = (commandIds: string[]): Set<string> =>
  new Set(commandIds.flatMap((id) => id.split(':').map((_, i, a) => a.slice(0, i + 1).join(':'))))
````

## File: src/errors/errors/cli.ts
````typescript
import cs from 'clean-stack'
import indent from 'indent-string'
import wrap from 'wrap-ansi'

import Cache from '../../cache'
import {OclifError, PrettyPrintableError} from '../../interfaces/errors'
import {errtermwidth} from '../../screen'
import {settings} from '../../settings'
import {colorize} from '../../ux/theme'

/**
 * properties specific to internal oclif error handling
 */

export function addOclifExitCode(
  error: Record<string, any>,
  options?: {exit?: false | number | undefined},
): OclifError {
  if (!('oclif' in error)) {
    ;(error as unknown as OclifError).oclif = {}
  }

  error.oclif.exit = options?.exit === undefined ? (Cache.getInstance().get('exitCodes')?.default ?? 2) : options.exit
  return error as OclifError
}

export class CLIError extends Error implements OclifError {
  code?: string | undefined
  oclif: OclifError['oclif'] = {}
  skipOclifErrorHandling?: boolean | undefined
  suggestions?: string[] | undefined

  constructor(error: Error | string, options: {exit?: false | number | undefined} & PrettyPrintableError = {}) {
    super(error instanceof Error ? error.message : error)
    addOclifExitCode(this, options)
    this.code = options.code
    this.suggestions = options.suggestions
  }

  // eslint-disable-next-line getter-return
  get bang(): string | undefined {
    try {
      return colorize('red', process.platform === 'win32' ? 'Â»' : 'â€º')
    } catch {}
  }

  get stack(): string {
    return cs(super.stack!, {pretty: true})
  }

  /**
   * @deprecated `render` Errors display should be handled by display function, like pretty-print
   * @returns {string} returns a string representing the display of the error
   */
  render(): string {
    if (settings.debug) {
      return this.stack
    }

    let output = `${this.name}: ${this.message}`
    output = wrap(output, errtermwidth - 6, {hard: true, trim: false} as any)
    output = indent(output, 3)
    output = indent(output, 1, {includeEmptyLines: true, indent: this.bang} as any)
    output = indent(output, 1)
    return output
  }
}

export namespace CLIError {
  export class Warn extends CLIError {
    constructor(err: Error | string) {
      super(err instanceof Error ? err.message : err)
      this.name = 'Warning'
    }

    // eslint-disable-next-line getter-return
    get bang(): string | undefined {
      try {
        return colorize('yellow', process.platform === 'win32' ? 'Â»' : 'â€º')
      } catch {}
    }
  }
}
````

## File: src/errors/errors/exit.ts
````typescript
import {OclifError} from '../../interfaces'
import {CLIError} from './cli'

export class ExitError extends CLIError implements OclifError {
  code = 'EEXIT'

  constructor(exitCode = 1) {
    super(`EEXIT: ${exitCode}`, {exit: exitCode})
  }

  render(): string {
    return ''
  }
}
````

## File: src/errors/errors/module-load.ts
````typescript
import {OclifError} from '../../interfaces'
import {CLIError} from './cli'

export class ModuleLoadError extends CLIError implements OclifError {
  code = 'MODULE_NOT_FOUND'

  constructor(message: string) {
    super(`[MODULE_NOT_FOUND] ${message}`, {exit: 1})
    this.name = 'ModuleLoadError'
  }
}
````

## File: src/errors/errors/pretty-print.ts
````typescript
import indent from 'indent-string'
import wrap from 'wrap-ansi'

import {PrettyPrintableError} from '../../interfaces/errors'
import {errtermwidth} from '../../screen'
import {settings} from '../../settings'

// These exist for backwards compatibility with CLIError
type CLIErrorDisplayOptions = {bang?: string | undefined; name?: string | undefined}

export function applyPrettyPrintOptions(error: Error, options: PrettyPrintableError): PrettyPrintableError {
  const prettyErrorKeys: (keyof PrettyPrintableError)[] = ['message', 'code', 'ref', 'suggestions']

  for (const key of prettyErrorKeys) {
    const applyOptionsKey = !(key in error) && options[key]
    if (applyOptionsKey) {
      ;(error as any)[key] = options[key]
    }
  }

  return error
}

const formatSuggestions = (suggestions?: string[]): string | undefined => {
  const label = 'Try this:'
  if (!suggestions || suggestions.length === 0) return undefined
  if (suggestions.length === 1) return `${label} ${suggestions[0]}`

  const multiple = suggestions.map((suggestion) => `* ${suggestion}`).join('\n')
  return `${label}\n${indent(multiple, 2)}`
}

export default function prettyPrint(error: Error & PrettyPrintableError & CLIErrorDisplayOptions): string | undefined {
  if (settings.debug) {
    return error.stack
  }

  const {bang, code, message, name: errorSuffix, ref, suggestions} = error

  // errorSuffix is pulled from the 'name' property on CLIError
  // and is like either Error or Warning
  const formattedHeader = message ? `${errorSuffix || 'Error'}: ${message}` : undefined
  const formattedCode = code ? `Code: ${code}` : undefined
  const formattedSuggestions = formatSuggestions(suggestions)
  const formattedReference = ref ? `Reference: ${ref}` : undefined

  const formatted = [formattedHeader, formattedCode, formattedSuggestions, formattedReference]
    .filter(Boolean)
    .join('\n')

  let output = wrap(formatted, errtermwidth - 6, {hard: true, trim: false} as any)
  output = indent(output, 3)
  output = indent(output, 1, {includeEmptyLines: true, indent: bang || ''} as any)
  output = indent(output, 1)

  return output
}
````

## File: src/errors/error.ts
````typescript
import {OclifError, PrettyPrintableError} from '../interfaces'
import {getLogger} from '../logger'
import {stderr} from '../ux/write'
import {addOclifExitCode, CLIError} from './errors/cli'
import prettyPrint, {applyPrettyPrintOptions} from './errors/pretty-print'

export function error(input: Error | string, options: {exit: false} & PrettyPrintableError): void
export function error(input: Error | string, options?: {exit?: number} & PrettyPrintableError): never
export function error(input: Error | string, options: {exit?: false | number} & PrettyPrintableError = {}): void {
  let err: Error & OclifError

  if (typeof input === 'string') {
    err = new CLIError(input, options)
  } else if (input instanceof Error) {
    err = addOclifExitCode(input, options) as Error & OclifError
  } else {
    throw new TypeError('first argument must be a string or instance of Error')
  }

  err = applyPrettyPrintOptions(err, options) as Error & OclifError & PrettyPrintableError

  if (options.exit === false) {
    const message = prettyPrint(err)
    if (message) stderr(message)
    if (err?.stack) getLogger().error(err.stack)
  } else throw err
}

export default error
````

## File: src/errors/exit.ts
````typescript
import {ExitError} from './errors/exit'

export function exit(code = 0): never {
  throw new ExitError(code)
}
````

## File: src/errors/handle.ts
````typescript
import clean from 'clean-stack'

import Cache from '../cache'
import {Help} from '../help/index'
import {OclifError, PrettyPrintableError} from '../interfaces'
import {getLogger} from '../logger'
import {CLIParseError} from '../parser/errors'
import {CLIError} from './errors/cli'
import {ExitError} from './errors/exit'
import prettyPrint from './errors/pretty-print'

/**
 * This is an odd abstraction for process.exit, but it allows us to stub it in tests.
 *
 * https://github.com/sinonjs/sinon/issues/562
 */
export const Exit = {
  exit(code = 0) {
    // eslint-disable-next-line n/no-process-exit, unicorn/no-process-exit
    process.exit(code)
  },
}

type ErrorToHandle = Error &
  Partial<PrettyPrintableError> &
  Partial<OclifError> &
  Partial<CLIError> &
  Partial<CLIParseError>

export async function handle(err: ErrorToHandle): Promise<void> {
  try {
    if (!err) err = new CLIError('no error?')
    if (err.message === 'SIGINT') Exit.exit(1)

    const shouldPrint = !(err instanceof ExitError) && !err.skipOclifErrorHandling
    const pretty = prettyPrint(err)
    const stack = clean(err.stack || '', {pretty: true})

    if (shouldPrint) {
      console.error(pretty ?? stack)
      const config = Cache.getInstance().get('config')
      if (err.showHelp && err.parse?.input?.argv && config) {
        const options = {
          ...(config.pjson.oclif.helpOptions ?? config.pjson.helpOptions),
          sections: ['flags', 'usage', 'arguments'],
          sendToStderr: true,
        }
        const help = new Help(config, options)
        console.error()
        await help.showHelp(process.argv.slice(2))
      }
    }

    const exitCode = err.oclif?.exit ?? 1

    if (err.code !== 'EEXIT' && stack) {
      getLogger().error(stack)
    }

    Exit.exit(exitCode)
  } catch (error: any) {
    console.error(err.stack)
    console.error(error.stack)
    Exit.exit(1)
  }
}
````

## File: src/errors/index.ts
````typescript
export {PrettyPrintableError} from '../interfaces'
export {error} from './error'
export {CLIError} from './errors/cli'
export {ExitError} from './errors/exit'
export {ModuleLoadError} from './errors/module-load'
export {exit} from './exit'
export {handle} from './handle'
export {warn} from './warn'
````

## File: src/errors/warn.ts
````typescript
import {OclifError} from '../interfaces'
import {getLogger} from '../logger'
import {stderr} from '../ux/write'
import {addOclifExitCode, CLIError} from './errors/cli'
import prettyPrint from './errors/pretty-print'

/**
 * Prints a pretty warning message to stderr.
 *
 * @param input The error or string to print.
 */
export function warn(input: Error | string): void {
  let err: Error & OclifError

  if (typeof input === 'string') {
    err = new CLIError.Warn(input)
  } else if (input instanceof Error) {
    err = addOclifExitCode(input) as Error & OclifError
  } else {
    throw new TypeError('first argument must be a string or instance of Error')
  }

  const message = prettyPrint(err)
  if (message) stderr(message)
  if (err?.stack) getLogger().error(err.stack)
}

const WARNINGS = new Set<Error | string>()
export function memoizedWarn(input: Error | string): void {
  if (!WARNINGS.has(input)) warn(input)

  WARNINGS.add(input)
}

export default warn
````

## File: src/help/command.ts
````typescript
import ansis from 'ansis'

import {Command} from '../command'
import * as Interfaces from '../interfaces'
import {ensureArgObject} from '../util/ensure-arg-object'
import {toConfiguredId, toStandardizedId} from '../util/ids'
import {castArray, compact, sortBy} from '../util/util'
import {colorize} from '../ux/theme'
import {DocOpts} from './docopts'
import {HelpFormatter, HelpSection, HelpSectionRenderer} from './formatter'

// Don't use os.EOL because we need to ensure that a string
// written on any platform, that may use \r\n or \n, will be
// split on any platform, not just the os specific EOL at runtime.
const POSSIBLE_LINE_FEED = /\r\n|\n/

/**
 * Determines the sort order of flags. Will default to alphabetical if not set or set to an invalid value.
 */
function determineSortOrder(
  flagSortOrder: HelpFormatter['opts']['flagSortOrder'],
): NonNullable<HelpFormatter['opts']['flagSortOrder']> {
  if (flagSortOrder === 'alphabetical') return 'alphabetical'
  if (flagSortOrder === 'none') return 'none'
  return 'alphabetical'
}

export class CommandHelp extends HelpFormatter {
  constructor(
    public command: Command.Loadable,
    public config: Interfaces.Config,
    public opts: Interfaces.HelpOptions,
  ) {
    super(config, opts)
  }

  protected aliases(aliases: string[] | undefined): string | undefined {
    if (!aliases || aliases.length === 0) return
    const body = aliases
      .map((a) =>
        [
          colorize(this.config?.theme?.dollarSign, '$'),
          colorize(this.config?.theme?.bin, this.config.bin),
          colorize(this.config?.theme?.alias, a),
        ].join(' '),
      )
      .join('\n')
    return body
  }

  protected arg(arg: Command.Arg.Any): string {
    const name = arg.name.toUpperCase()
    if (arg.required) return `${name}`
    return `[${name}]`
  }

  protected args(args: Command.Arg.Any[]): [string, string | undefined][] | undefined {
    if (args.filter((a) => a.description).length === 0) return

    return args.map((a) => {
      // Add ellipsis to indicate that the argument takes multiple values if strict is false
      const name = this.command.strict === false ? `${a.name.toUpperCase()}...` : a.name.toUpperCase()
      let description = a.description || ''
      if (a.default)
        description = `${colorize(this.config?.theme?.flagDefaultValue, `[default: ${a.default}]`)} ${description}`
      if (a.options)
        description = `${colorize(this.config?.theme?.flagOptions, `(${a.options.join('|')})`)} ${description}`
      return [
        colorize(this.config?.theme?.flag, name),
        description ? colorize(this.config?.theme?.sectionDescription, description) : undefined,
      ]
    })
  }

  protected defaultUsage(): string {
    // Docopts by default
    if (this.opts.docopts === undefined || this.opts.docopts) {
      return DocOpts.generate(this.command)
    }

    return compact([
      this.command.id,
      Object.values(this.command.args ?? {})
        ?.filter((a) => !a.hidden)
        .map((a) => this.arg(a))
        .join(' '),
    ]).join(' ')
  }

  protected description(): string | undefined {
    const cmd = this.command

    let description: string[] | undefined
    if (this.opts.hideCommandSummaryInDescription) {
      description = (cmd.description || '').split(POSSIBLE_LINE_FEED).slice(1)
    } else if (cmd.description) {
      const summary = cmd.summary ? `${cmd.summary}\n` : null
      description = summary
        ? [...summary.split(POSSIBLE_LINE_FEED), ...(cmd.description || '').split(POSSIBLE_LINE_FEED)]
        : (cmd.description || '').split(POSSIBLE_LINE_FEED)
    }

    if (description) {
      return this.wrap(description.join('\n'))
    }
  }

  protected examples(examples: Command.Example[] | string | undefined): string | undefined {
    if (!examples || examples.length === 0) return

    const body = castArray(examples)
      .map((a) => {
        let description
        let commands
        if (typeof a === 'string') {
          const lines = a.split(POSSIBLE_LINE_FEED).filter(Boolean)
          // If the example is <description>\n<command> then format correctly
          if (lines.length >= 2 && !this.isCommand(lines[0]) && lines.slice(1).every((i) => this.isCommand(i))) {
            description = lines[0]
            commands = lines.slice(1)
          } else {
            return lines.map((line) => this.formatIfCommand(line)).join('\n')
          }
        } else {
          description = a.description
          commands = [a.command]
        }

        const multilineSeparator =
          this.config.platform === 'win32' ? (this.config.shell.includes('powershell') ? '`' : '^') : '\\'

        // The command will be indented in the section, which is also indented
        const finalIndentedSpacing = this.indentSpacing * 2
        const multilineCommands = commands
          .map((c) =>
            // First indent keeping room for escaped newlines
            this.indent(this.wrap(this.formatIfCommand(c), finalIndentedSpacing + 4))
              // Then add the escaped newline
              .split(POSSIBLE_LINE_FEED)
              .join(` ${multilineSeparator}\n  `),
          )
          .join('\n')

        return `${this.wrap(description, finalIndentedSpacing)}\n\n${multilineCommands}`
      })
      .join('\n\n')
    return body
  }

  protected flagHelpLabel(flag: Command.Flag.Any, showOptions = false): string {
    let label = flag.helpLabel

    if (!label) {
      const labels = []
      labels.push(flag.char ? `-${flag.char[0]}` : '  ')
      if (flag.name) {
        if (flag.type === 'boolean' && flag.allowNo) {
          labels.push(`--[no-]${flag.name.trim()}`)
        } else {
          labels.push(`--${flag.name.trim()}`)
        }
      }

      label = labels.join(flag.char ? colorize(this.config?.theme?.flagSeparator, ', ') : '  ')
    }

    if (flag.type === 'option') {
      let value = DocOpts.formatUsageType(
        flag,
        this.opts.showFlagNameInTitle ?? false,
        this.opts.showFlagOptionsInTitle ?? showOptions,
      )
      if (!value.includes('|')) value = colorize('underline', value)
      label += `=${value}`
    }

    return colorize(this.config.theme?.flag, label)
  }

  protected flags(flags: Array<Command.Flag.Any>): [string, string | undefined][] | undefined {
    if (flags.length === 0) return

    const noChar = flags.reduce((previous, current) => previous && current.char === undefined, true)

    // eslint-disable-next-line complexity
    return flags.map((flag) => {
      let left = this.flagHelpLabel(flag)

      if (noChar) left = left.replace('    ', '')

      let right = flag.summary || flag.description || ''
      const canBeCached = !(this.opts.respectNoCacheDefault === true && flag.noCacheDefault === true)
      if (flag.type === 'option' && flag.default && canBeCached) {
        right = `${colorize(this.config?.theme?.flagDefaultValue, `[default: ${flag.default}]`)} ${right}`
      }

      if (flag.required) right = `${colorize(this.config?.theme?.flagRequired, '(required)')} ${right}`

      if (flag.type === 'option' && flag.options && !flag.helpValue && !this.opts.showFlagOptionsInTitle) {
        right += colorize(this.config?.theme?.flagOptions, `\n<options: ${flag.options.join('|')}>`)
      }

      return [left, colorize(this.config?.theme?.sectionDescription, right.trim())]
    })
  }

  protected flagsDescriptions(flags: Array<Command.Flag.Any>): string | undefined {
    const flagsWithExtendedDescriptions = flags.filter((flag) => flag.summary && flag.description)
    if (flagsWithExtendedDescriptions.length === 0) return

    const body = flagsWithExtendedDescriptions
      .map((flag) => {
        // Guaranteed to be set because of the filter above, but make ts happy
        const summary = flag.summary || ''
        let flagHelp = this.flagHelpLabel(flag, true)

        if (!flag.char) flagHelp = flagHelp.replace('    ', '')

        flagHelp +=
          flagHelp.length + summary.length + 2 < this.opts.maxWidth
            ? '  ' + summary
            : '\n\n' + this.indent(this.wrap(summary, this.indentSpacing * 2))

        return `${flagHelp}\n\n${this.indent(this.wrap(flag.description || '', this.indentSpacing * 2))}`
      })
      .join('\n\n')

    return body
  }

  generate(): string {
    const cmd = this.command
    const unsortedFlags = Object.entries(cmd.flags || {})
      .filter(([, v]) => !v.hidden)
      .map(([k, v]) => {
        v.name = k
        return v
      })

    const flags =
      determineSortOrder(this.opts.flagSortOrder) === 'alphabetical'
        ? sortBy(unsortedFlags, (f) => [!f.char, f.char, f.name])
        : unsortedFlags

    const args = Object.values(ensureArgObject(cmd.args)).filter((a) => !a.hidden)
    const output = compact(
      this.sections().map(({generate, header}) => {
        const body = generate({args, cmd, flags}, header)
        // Generate can return a list of sections
        if (Array.isArray(body)) {
          return body
            .map((helpSection) => helpSection && helpSection.body && this.section(helpSection.header, helpSection.body))
            .join('\n\n')
        }

        return body && this.section(header, body)
      }),
    ).join('\n\n')
    return output
  }

  protected groupFlags(flags: Array<Command.Flag.Any>): {
    flagGroups: {[name: string]: Array<Command.Flag.Any>}
    mainFlags: Array<Command.Flag.Any>
  } {
    const mainFlags: Array<Command.Flag.Any> = []
    const flagGroups: {[index: string]: Array<Command.Flag.Any>} = {}

    for (const flag of flags) {
      const group = flag.helpGroup

      if (group) {
        if (!flagGroups[group]) flagGroups[group] = []
        flagGroups[group].push(flag)
      } else {
        mainFlags.push(flag)
      }
    }

    return {flagGroups, mainFlags}
  }

  protected sections(): Array<{generate: HelpSectionRenderer; header: string}> {
    const sections: Array<{generate: HelpSectionRenderer; header: string}> = [
      {
        generate: () => this.usage(),
        header: this.opts.usageHeader || 'USAGE',
      },
      {
        generate: ({args}, header) => [{body: this.args(args), header}],
        header: 'ARGUMENTS',
      },
      {
        generate: ({flags}, header) => {
          const {flagGroups, mainFlags} = this.groupFlags(flags)

          const flagSections: HelpSection[] = []
          const mainFlagBody = this.flags(mainFlags)

          if (mainFlagBody) flagSections.push({body: mainFlagBody, header})

          for (const [name, flags] of Object.entries(flagGroups)) {
            const body = this.flags(flags)
            if (body) flagSections.push({body, header: `${name.toUpperCase()} ${header}`})
          }

          return compact<HelpSection>(flagSections)
        },
        header: 'FLAGS',
      },
      {
        generate: () => this.description(),
        header: 'DESCRIPTION',
      },
      {
        generate: ({cmd}) => this.aliases(cmd.aliases),
        header: 'ALIASES',
      },
      {
        generate: ({cmd}) => {
          const examples = cmd.examples || (cmd as any).example
          return this.examples(examples)
        },
        header: 'EXAMPLES',
      },
      {
        generate: ({flags}) => this.flagsDescriptions(flags),
        header: 'FLAG DESCRIPTIONS',
      },
    ]

    const allowedSections = this.opts.sections?.map((s) => s.toLowerCase())

    return sections.filter(({header}) => !allowedSections || allowedSections.includes(header.toLowerCase()))
  }

  protected usage(): string {
    const {id, usage} = this.command
    const standardId = toStandardizedId(id, this.config)
    const configuredId = toConfiguredId(id, this.config)
    const body = (usage ? castArray(usage) : [this.defaultUsage()])
      .map((u) => {
        const allowedSpacing = this.opts.maxWidth - this.indentSpacing

        const dollarSign = colorize(this.config?.theme?.dollarSign, '$')
        const bin = colorize(this.config?.theme?.bin, this.config.bin)

        const command = colorize(this.config?.theme?.command, '<%= command.id %>')

        const commandDescription = colorize(
          this.config?.theme?.sectionDescription,
          u
            .replace('<%= command.id %>', '')
            .replace(new RegExp(`^${standardId}`), '')
            .replace(new RegExp(`^${configuredId}`), '')
            .trim(),
        )

        const line = `${dollarSign} ${bin} ${command} ${commandDescription}`.trim()
        if (line.length > allowedSpacing) {
          const splitIndex = line.slice(0, Math.max(0, allowedSpacing)).lastIndexOf(' ')
          return (
            line.slice(0, Math.max(0, splitIndex)) +
            '\n' +
            this.indent(this.wrap(line.slice(Math.max(0, splitIndex)), this.indentSpacing * 2))
          )
        }

        return this.wrap(line)
      })
      .join('\n')
    return body
  }

  private formatIfCommand(example: string): string {
    example = this.render(example)
    const dollarSign = colorize(this.config?.theme?.dollarSign, '$')
    if (example.startsWith(this.config.bin)) return `${dollarSign} ${example}`
    if (example.startsWith(`$ ${this.config.bin}`)) return `${dollarSign}${example.replace(`$`, '')}`
    return example
  }

  private isCommand(example: string): boolean {
    return ansis
      .strip(this.formatIfCommand(example))
      .startsWith(`${colorize(this.config?.theme?.dollarSign, '$')} ${this.config.bin}`)
  }
}
export default CommandHelp
````

## File: src/help/docopts.ts
````typescript
import {Command} from '../command'
import {ensureArgObject} from '../util/ensure-arg-object'
/**
 * DocOpts - See http://docopt.org/.
 *
 * flag.exclusive: groups elements when one of the mutually exclusive cases is a required flag: (--apple | --orange)
 * flag.exclusive: groups elements when none of the mutually exclusive cases is required (optional flags): [--apple | --orange]
 * flag.dependsOn: specifies that if one element is present, then another one is required: (--apple --orange)
 *
 * @example
 *  {
 *      name: 'classnames',
 *      required: true,
 *      exclusive: ['suitenames']
 *      ...
 *  },{
 *      name: 'suitenames',
 *      type: 'array'
 *      required: true
 *      ...
 *  }
 *
 *  Results in:
 *      Usage: <%= command.id %> (-n <string> | -s <array>)
 *
 * @example
 *  {
 *      name: 'classnames',
 *      ...
 *      excludes: ['suitenames']
 *  },{
 *      name: 'suitenames',
 *      ...
 *  }
 *
 *  Results in:
 *      Usage: <%= command.id %> [-n <string> | -s <string>]
 *
 * @example
 *  {
 *      name: 'classnames',
 *      ...
 *      dependsOn: ['suitenames']
 *  },{
 *      name: 'suitenames',
 *      type: 'flag'
 *      ...
 *  }
 *
 *  Results in:
 *      Usage: <%= command.id %> (-n <string> -s)
 *
 * TODO:
 *  - Support nesting, eg:
 *      Usage: my_program (--either-this <and-that> | <or-this>)
 *      Usage: my_program [(<one-argument> <another-argument>)]
 *
 */
export class DocOpts {
  private flagList: Command.Flag.Any[]
  private flagMap: {[index: string]: Command.Flag.Any}

  public constructor(private cmd: Command.Loadable) {
    // Create a new map with references to the flags that we can manipulate.
    this.flagMap = {}
    this.flagList = Object.entries(cmd.flags || {})
      .filter(([_, flag]) => !flag.hidden)
      .map(([name, flag]) => {
        this.flagMap[name] = flag
        return flag
      })
  }

  public static formatUsageType(flag: Command.Flag.Any, showFlagName: boolean, showOptions: boolean): string {
    if (flag.type !== 'option') return ''

    let helpValues: string[]
    if (flag.helpValue) {
      // if there is a given helpValue, use it
      helpValues = typeof flag.helpValue === 'string' ? [flag.helpValue] : flag.helpValue
    } else if (flag.options) {
      // if there are options, show them if wanted
      helpValues = [showOptions ? flag.options.join('|') : '<option>']
    } else if (showFlagName) {
      helpValues = [flag.name]
    } else {
      // default to <value>
      helpValues = ['<value>']
    }

    return helpValues.map((v) => `${v}${flag.multiple ? '...' : ''}`).join(' ')
  }

  public static generate(cmd: Command.Loadable): string {
    return new DocOpts(cmd).toString()
  }

  public toString(): string {
    const opts = ['<%= command.id %>']
    if (this.cmd.args) {
      // If strict is false, add ellipsis to indicate that the argument takes multiple values
      const suffix = this.cmd.strict === false ? '...' : ''
      const a =
        Object.values(ensureArgObject(this.cmd.args))
          .filter((arg) => !arg.hidden)
          .map((arg) =>
            arg.required ? `${arg.name.toUpperCase()}${suffix}` : `[${arg.name.toUpperCase()}${suffix}]`,
          ) || []
      opts.push(...a)
    }

    try {
      opts.push(...Object.values(this.groupFlagElements()))
    } catch {
      // If there is an error, just return no usage so we don't fail command help.
      opts.push(
        ...this.flagList.map((flag) => {
          const name = flag.char ? `-${flag.char}` : `--${flag.name}`
          if (flag.type === 'boolean') return name
          return `${name}=${DocOpts.formatUsageType(flag, false, true)}`
        }),
      )
    }

    return opts.join(' ')
  }

  private combineElementsToFlag(
    elementMap: {[index: string]: string},
    flagName: string,
    flagNames: string[],
    unionString: string,
  ): void {
    if (!this.flagMap[flagName]) {
      return
    }

    let isRequired = this.flagMap[flagName]?.required
    if (typeof isRequired !== 'boolean' || !isRequired) {
      isRequired = flagNames.reduce(
        (required: boolean, toCombine) => required || this.flagMap[toCombine]?.required || false,
        false,
      )
    }

    for (const toCombine of flagNames) {
      elementMap[flagName] = `${elementMap[flagName] || ''}${unionString}${elementMap[toCombine] || ''}`
      // We handled this flag, don't handle it again
      delete elementMap[toCombine]
      delete this.flagMap[toCombine]
    }

    elementMap[flagName] = isRequired ? `(${elementMap[flagName] || ''})` : `[${elementMap[flagName] || ''}]`

    // We handled this flag, don't handle it again
    delete this.flagMap[flagName]
  }

  private generateElements(elementMap: {[index: string]: string} = {}, flagGroups: Command.Flag.Any[] = []): string[] {
    const elementStrs = []
    for (const flag of flagGroups) {
      let type = ''
      // not all flags have short names
      const flagName = flag.char ? `-${flag.char}` : `--${flag.name}`
      if (flag.type === 'option') {
        type = ` ${DocOpts.formatUsageType(flag, false, true)}`
      }

      const element = `${flagName}${type}`
      elementMap[flag.name] = element
      elementStrs.push(element)
    }

    return elementStrs
  }

  private groupFlagElements(): {[index: string]: string} {
    const elementMap: {[index: string]: string} = {}

    // Generate all doc opt elements for combining
    // Show required flags first
    this.generateElements(
      elementMap,
      this.flagList.filter((flag) => flag.required),
    )
    // Then show optional flags
    this.generateElements(
      elementMap,
      this.flagList.filter((flag) => !flag.required),
    )

    for (const flag of this.flagList) {
      if (Array.isArray(flag.dependsOn)) {
        this.combineElementsToFlag(elementMap, flag.name, flag.dependsOn, ' ')
      }

      if (Array.isArray(flag.exclusive)) {
        this.combineElementsToFlag(elementMap, flag.name, flag.exclusive, ' | ')
      }
    }

    // Since combineElementsToFlag deletes the references in this.flags when it combines
    // them, this will go through the remaining list of uncombined elements.
    for (const remainingFlagName of Object.keys(this.flagMap)) {
      const remainingFlag = this.flagMap[remainingFlagName] || {}

      if (!remainingFlag.required) {
        elementMap[remainingFlag.name] = `[${elementMap[remainingFlag.name] || ''}]`
      }
    }

    return elementMap
  }
}
````

## File: src/help/formatter.ts
````typescript
import ansis from 'ansis'
import indent from 'indent-string'
import width from 'string-width'
import widestLine from 'widest-line'
import wrap from 'wrap-ansi'

import {Command} from '../command'
import * as Interfaces from '../interfaces'
import {stdtermwidth} from '../screen'
import {colorize} from '../ux/theme'
import {template} from './util'

export type HelpSectionKeyValueTable = {description: string; name: string}[]
export type HelpSection =
  | {body: [string, string | undefined][] | HelpSectionKeyValueTable | string | undefined; header: string}
  | undefined
export type HelpSectionRenderer = (
  data: {args: Command.Arg.Any[]; cmd: Command.Loadable; flags: Command.Flag.Any[]},
  header: string,
) => HelpSection | HelpSection[] | string | undefined

export class HelpFormatter {
  protected config: Interfaces.Config
  indentSpacing = 2
  protected opts: Interfaces.HelpOptions
  /**
   * Takes a string and replaces `<%= prop =>` with the value of prop, where prop is anything on
   * `config=Interfaces.Config` or `opts=Interface.HelpOptions`.
   *
   * ```javascript
   * `<%= config.bin =>` // will resolve to the bin defined in `pjson.oclif`.
   * ```
   */
  render: (input: string) => string

  constructor(config: Interfaces.Config, opts: Partial<Interfaces.HelpOptions> = {}) {
    this.config = config
    this.opts = {maxWidth: stdtermwidth, ...opts}
    this.render = template(this)
  }

  /**
   * Indent by `this.indentSpacing`. The text should be wrap based on terminal width before indented.
   *
   * In order to call indent multiple times on the same set or text, the caller must wrap based on
   * the number of times the text has been indented. For example.
   *
   * ```javascript
   * const body = `main line\n${indent(wrap('indented example line', 4))}`
   * const header = 'SECTION'
   * console.log(`${header}\n${indent(wrap(body))}`
   * ```
   * will output
   * ```
   * SECTION
   *   main line
   *     indented example line
   * ```
   *
   * If the terminal width was 24 and the `4` was not provided in the first wrap, it would like like the following.
   * ```
   * SECTION
   *   main line
   *     indented example
   *   line
   * ```
   * @param body the text to indent
   * @param spacing the final number of spaces this text will be indented
   * @returns the formatted indented text
   */
  public indent(body: string, spacing = this.indentSpacing): string {
    return indent(body, spacing)
  }

  public renderList(
    input: (string | undefined)[][],
    opts: {
      indentation: number
      multiline?: boolean | undefined
      spacer?: string | undefined
      stripAnsi?: boolean | undefined
    },
  ): string {
    if (input.length === 0) {
      return ''
    }

    const renderMultiline = () => {
      let output = ''
      for (let [left, right] of input) {
        if (!left && !right) continue
        if (left) {
          if (opts.stripAnsi) left = ansis.strip(left)
          output += this.wrap(left.trim(), opts.indentation)
        }

        if (right) {
          if (opts.stripAnsi) right = ansis.strip(right)
          output += '\n'
          output += this.indent(this.wrap(right.trim(), opts.indentation + 2), 4)
        }

        output += '\n\n'
      }

      return output.trim()
    }

    if (opts.multiline) return renderMultiline()
    const maxLength = widestLine(input.map((i) => i[0]).join('\n'))
    let output = ''
    let spacer = opts.spacer || '\n'
    let cur = ''
    for (const [left, r] of input) {
      let right = r
      if (cur) {
        output += spacer
        output += cur
      }

      cur = left || ''
      if (opts.stripAnsi) cur = ansis.strip(cur)
      if (!right) {
        cur = cur.trim()
        continue
      }

      if (opts.stripAnsi) right = ansis.strip(right)
      right = this.wrap(right.trim(), opts.indentation + maxLength + 2)

      const [first, ...lines] = right!.split('\n').map((s) => s.trim())
      cur += ' '.repeat(maxLength - width(cur) + 2)
      cur += first
      if (lines.length === 0) {
        continue
      }

      // if we start putting too many lines down, render in multiline format
      if (lines.length > 4) return renderMultiline()
      // if spacer is not defined, separate all rows with a newline
      if (!opts.spacer) spacer = '\n'
      cur += '\n'
      cur += this.indent(lines.join('\n'), maxLength + 2)
    }

    if (cur) {
      output += spacer
      output += cur
    }

    return output.trim()
  }

  public section(
    header: string,
    body: [string, string | undefined][] | HelpSection | HelpSectionKeyValueTable | string,
  ): string {
    // Always render template strings with the provided render function before wrapping and indenting
    let newBody: any
    if (typeof body! === 'string') {
      newBody = this.render(body!)
    } else if (Array.isArray(body)) {
      newBody = (body! as [string, HelpSectionKeyValueTable | string | undefined][]).map((entry) => {
        if ('name' in entry) {
          const tableEntry = entry as unknown as {description: string; name: string}
          return [this.render(tableEntry.name), this.render(tableEntry.description)]
        }

        const [left, right] = entry
        return [this.render(left), right && this.render(right as string)]
      })
    } else if ('header' in body!) {
      return this.section(body!.header, body!.body)
    } else {
      newBody = (body! as unknown as HelpSectionKeyValueTable)
        .map((entry: {description: string; name: string}) => [entry.name, entry.description])
        .map(([left, right]) => [this.render(left), right && this.render(right)])
    }

    const output = [
      colorize(this.config?.theme?.sectionHeader, colorize('bold', header)),
      colorize(
        this.config?.theme?.sectionDescription,
        this.indent(
          Array.isArray(newBody) ? this.renderList(newBody, {indentation: 2, stripAnsi: this.opts.stripAnsi}) : newBody,
        ),
      ),
    ].join('\n')

    return this.opts.stripAnsi ? ansis.strip(output) : output
  }

  /**
   * Wrap text according to `opts.maxWidth` which is typically set to the terminal width. All text
   * will be rendered before bring wrapped, otherwise it could mess up the lengths.
   *
   * A terminal will automatically wrap text, so this method is primarily used for indented
   * text. For indented text, specify the indentation so it is taken into account during wrapping.
   *
   * Here is an example of wrapping with indentation.
   * ```
   * <------ terminal window width ------>
   * <---------- no indentation --------->
   * This is my text that will be wrapped
   * once it passes maxWidth.
   *
   * <- indent -><------ text space ----->
   *             This is my text that will
   *             be wrapped once it passes
   *             maxWidth.
   *
   * <-- indent not taken into account ->
   *             This is my text that will
   * be wrapped
   *             once it passes maxWidth.
   * ```
   * @param body the text to wrap
   * @param spacing the indentation size to subtract from the terminal width
   * @returns the formatted wrapped text
   */
  public wrap(body: string, spacing = this.indentSpacing): string {
    return wrap(this.render(body), this.opts.maxWidth - spacing, {hard: true})
  }
}
````

## File: src/help/index.ts
````typescript
import ansis from 'ansis'

import {Command} from '../command'
import {tsPath} from '../config/ts-path'
import {error} from '../errors/error'
import * as Interfaces from '../interfaces'
import {HelpLocationOptions} from '../interfaces/pjson'
import {load} from '../module-loader'
import {SINGLE_COMMAND_CLI_SYMBOL} from '../symbols'
import {cacheDefaultValue} from '../util/cache-default-value'
import {toConfiguredId} from '../util/ids'
import {compact, sortBy, uniqBy} from '../util/util'
import {ux} from '../ux'
import {colorize} from '../ux/theme'
import {CommandHelp} from './command'
import {HelpFormatter} from './formatter'
import RootHelp from './root'
import {formatCommandDeprecationWarning, getHelpFlagAdditions, standardizeIDFromArgv} from './util'
export {CommandHelp} from './command'
export {HelpFormatter, type HelpSection, type HelpSectionKeyValueTable, type HelpSectionRenderer} from './formatter'
export {getHelpFlagAdditions, normalizeArgv, standardizeIDFromArgv} from './util'

function getHelpSubject(args: string[], config: Interfaces.Config): string | undefined {
  // for each help flag that starts with '--' create a new flag with same name sans '--'
  const mergedHelpFlags = getHelpFlagAdditions(config)
  for (const arg of args) {
    if (arg === '--') return
    if (mergedHelpFlags.includes(arg) || arg === 'help') continue
    if (arg.startsWith('-')) return
    return arg
  }
}

export abstract class HelpBase extends HelpFormatter {
  constructor(config: Interfaces.Config, opts: Partial<Interfaces.HelpOptions> = {}) {
    super(config, opts)
    if (!config.topicSeparator) config.topicSeparator = ':' // back-support @oclif/config
  }

  /**
   * Show help for an individual command
   * @param command
   * @param topics
   */
  public abstract showCommandHelp(command: Command.Loadable, topics: Interfaces.Topic[]): Promise<void>

  /**
   * Show help, used in multi-command CLIs
   * @param args passed into your command, useful for determining which type of help to display
   */
  public abstract showHelp(argv: string[]): Promise<void>
}

export class Help extends HelpBase {
  protected CommandHelpClass: typeof CommandHelp = CommandHelp

  constructor(config: Interfaces.Config, opts: Partial<Interfaces.HelpOptions> = {}) {
    super(config, opts)
  }

  /*
   * _topics is to work around Interfaces.topics mistakenly including commands that do
   * not have children, as well as topics. A topic has children, either commands or other topics. When
   * this is fixed upstream config.topics should return *only* topics with children,
   * and this can be removed.
   */
  private get _topics(): Interfaces.Topic[] {
    return this.config.topics.filter((topic: Interfaces.Topic) => {
      // it is assumed a topic has a child if it has children
      const hasChild = this.config.topics.some((subTopic) => subTopic.name.includes(`${topic.name}:`))
      return hasChild
    })
  }

  protected get sortedCommands(): Command.Loadable[] {
    let {commands} = this.config

    commands = commands.filter((c) => this.opts.all || !c.hidden)
    commands = sortBy(commands, (c) => c.id)
    commands = uniqBy(commands, (c) => c.id)

    return commands
  }

  protected get sortedTopics(): Interfaces.Topic[] {
    let topics = this._topics
    topics = topics.filter((t) => this.opts.all || !t.hidden)
    topics = sortBy(topics, (t) => t.name)
    topics = uniqBy(topics, (t) => t.name)

    return topics
  }

  protected command(command: Command.Loadable): string {
    return this.formatCommand(command)
  }

  protected description(c: Command.Loadable): string {
    const description = this.render(c.description || '')
    if (c.summary) {
      return description
    }

    return description.split('\n').slice(1).join('\n')
  }

  protected formatCommand(command: Command.Loadable): string {
    if (this.config.topicSeparator !== ':') {
      command.id = command.id.replaceAll(':', this.config.topicSeparator)
      command.aliases = command.aliases && command.aliases.map((a) => a.replaceAll(':', this.config.topicSeparator))
    }

    const help = this.getCommandHelpClass(command)
    return help.generate()
  }

  protected formatCommands(commands: Array<Command.Loadable>): string {
    if (commands.length === 0) return ''
    const body = this.renderList(
      commands
        .filter((c) => (this.opts.hideAliasesFromRoot ? !c.aliases?.includes(c.id) : true))
        .map((c) => {
          if (this.config.topicSeparator !== ':') c.id = c.id.replaceAll(':', this.config.topicSeparator)
          const summary = this.summary(c)
          return [
            colorize(this.config?.theme?.command, c.id),
            summary && colorize(this.config?.theme?.sectionDescription, ansis.strip(summary)),
          ]
        }),
      {
        indentation: 2,
        spacer: '\n',
        stripAnsi: this.opts.stripAnsi,
      },
    )

    return this.section('COMMANDS', body)
  }

  protected formatRoot(): string {
    const help = new RootHelp(this.config, this.opts)
    return help.root()
  }

  protected formatTopic(topic: Interfaces.Topic): string {
    let description = this.render(topic.description || '')
    const summary = description.split('\n')[0]
    description = description.split('\n').slice(1).join('\n')
    let topicID = `${topic.name}:COMMAND`
    if (this.config.topicSeparator !== ':') topicID = topicID.replaceAll(':', this.config.topicSeparator)
    let output = compact([
      colorize(this.config?.theme?.commandSummary, summary),
      this.section(
        this.opts.usageHeader || 'USAGE',
        `${colorize(this.config?.theme?.dollarSign, '$')} ${colorize(
          this.config?.theme?.bin,
          this.config.bin,
        )} ${topicID}`,
      ),
      description &&
        this.section('DESCRIPTION', this.wrap(colorize(this.config?.theme?.sectionDescription, description))),
    ]).join('\n\n')
    if (this.opts.stripAnsi) output = ansis.strip(output)
    return output + '\n'
  }

  protected formatTopics(topics: Interfaces.Topic[]): string {
    if (topics.length === 0) return ''
    const body = this.renderList(
      topics.map((c) => {
        if (this.config.topicSeparator !== ':') c.name = c.name.replaceAll(':', this.config.topicSeparator)
        return [
          colorize(this.config?.theme?.topic, c.name),
          c.description && this.render(colorize(this.config?.theme?.sectionDescription, c.description.split('\n')[0])),
        ]
      }),
      {
        indentation: 2,
        spacer: '\n',
        stripAnsi: this.opts.stripAnsi,
      },
    )
    return this.section('TOPICS', body)
  }

  protected getCommandHelpClass(command: Command.Loadable): CommandHelp {
    return new this.CommandHelpClass(command, this.config, this.opts)
  }

  protected log(...args: string[]) {
    return this.opts.sendToStderr ? ux.stderr(args) : ux.stdout(args)
  }

  public async showCommandHelp(command: Command.Loadable): Promise<void> {
    const name = command.id
    const depth = name.split(':').length

    const subTopics = this.sortedTopics.filter(
      (t) => t.name.startsWith(name + ':') && t.name.split(':').length === depth + 1,
    )
    const subCommands = this.sortedCommands.filter(
      (c) => c.id.startsWith(name + ':') && c.id.split(':').length === depth + 1,
    )
    const plugin = this.config.plugins.get(command.pluginName!)

    const state = this.config.pjson?.oclif?.state || plugin?.pjson?.oclif?.state || command.state

    if (state) {
      this.log(
        state === 'deprecated'
          ? `${formatCommandDeprecationWarning(toConfiguredId(name, this.config), command.deprecationOptions)}\n`
          : `This command is in ${state}.\n`,
      )
    }

    if (command.deprecateAliases && command.aliases.includes(name)) {
      const actualCmd = this.config.commands.find((c) => c.aliases.includes(name))
      const actualCmdName = actualCmd ? toConfiguredId(actualCmd.id, this.config) : ''
      const opts = {...command.deprecationOptions, ...(actualCmd ? {to: actualCmdName} : {})}
      this.log(`${formatCommandDeprecationWarning(toConfiguredId(name, this.config), opts)}\n`)
    }

    const summary = this.summary(command)
    if (summary) {
      this.log(summary + '\n')
    }

    this.log(this.formatCommand(command))
    this.log('')

    if (subTopics.length > 0) {
      this.log(this.formatTopics(subTopics))
      this.log('')
    }

    if (subCommands.length > 0) {
      const aliases: string[] = []
      const uniqueSubCommands: Command.Loadable[] = subCommands.filter((p) => {
        aliases.push(...p.aliases)
        return !aliases.includes(p.id)
      })
      this.log(this.formatCommands(uniqueSubCommands))
      this.log('')
    }
  }

  public async showHelp(argv: string[]): Promise<void> {
    const originalArgv = argv.slice(1)
    argv = argv.filter((arg) => !getHelpFlagAdditions(this.config).includes(arg))

    if (this.config.topicSeparator !== ':') argv = standardizeIDFromArgv(argv, this.config)
    const subject = getHelpSubject(argv, this.config)
    if (!subject) {
      if (this.config.isSingleCommandCLI) {
        const rootCmd = this.config.findCommand(SINGLE_COMMAND_CLI_SYMBOL)
        if (rootCmd) {
          // set the command id to an empty string to prevent the
          // SINGLE_COMMAND_CLI_SYMBOL from being displayed in the help output
          rootCmd.id = ''
          await this.showCommandHelp(rootCmd)
          return
        }
      }

      await this.showRootHelp()
      return
    }

    const command = this.config.findCommand(subject)
    if (command) {
      if (command.id === SINGLE_COMMAND_CLI_SYMBOL) {
        // If the command is the root command of a single command CLI,
        // then set the command id to an empty string to prevent the
        // the SINGLE_COMMAND_CLI_SYMBOL from being displayed in the help output.
        command.id = ''
      }

      if (command.hasDynamicHelp && command.pluginType !== 'jit') {
        const loaded = await command.load()
        for (const [name, flag] of Object.entries(loaded.flags ?? {})) {
          // As of v3 each flag that needs to be re-evaluated has the `hasDynamicHelp` property.
          // However, we cannot assume that the absence of this property means that the flag
          // doesn't need to be re-evaluated since any command from a v2 or older plugin will
          // not have the `hasDynamicHelp` property on it.

          // In the future we could improve performance by skipping any flag that doesn't
          // have `hasDynamicHelp === true`

          if (flag.type === 'boolean') continue
          // eslint-disable-next-line no-await-in-loop
          command.flags[name].default = await cacheDefaultValue(flag, false)
        }

        await this.showCommandHelp(command)
      } else {
        await this.showCommandHelp(command)
      }

      return
    }

    const topic = this.config.findTopic(subject)
    if (topic) {
      await this.showTopicHelp(topic)
      return
    }

    if (this.config.flexibleTaxonomy) {
      const matches = this.config.findMatches(subject, originalArgv)
      if (matches.length > 0) {
        const result = await this.config.runHook('command_incomplete', {
          argv: originalArgv.filter((o) => !subject.split(':').includes(o)),
          id: subject,
          matches,
        })
        if (result.successes.length > 0) return
      }
    }

    error(`Command ${subject} not found.`)
  }

  protected async showRootHelp(): Promise<void> {
    let rootTopics = this.sortedTopics
    let rootCommands = this.sortedCommands

    const state = this.config.pjson?.oclif?.state
    if (state) {
      this.log(state === 'deprecated' ? `${this.config.bin} is deprecated` : `${this.config.bin} is in ${state}.\n`)
    }

    this.log(this.formatRoot())
    this.log('')

    if (!this.opts.all) {
      rootTopics = rootTopics.filter((t) => !t.name.includes(':'))
      rootCommands = rootCommands.filter((c) => !c.id.includes(':'))
    }

    if (rootTopics.length > 0) {
      this.log(this.formatTopics(rootTopics))
      this.log('')
    }

    if (rootCommands.length > 0) {
      rootCommands = rootCommands.filter((c) => c.id)
      this.log(this.formatCommands(rootCommands))
      this.log('')
    }
  }

  protected async showTopicHelp(topic: Interfaces.Topic): Promise<void> {
    const {name} = topic
    const depth = name.split(':').length

    const subTopics = this.sortedTopics.filter(
      (t) => t.name.startsWith(name + ':') && t.name.split(':').length === depth + 1,
    )
    const commands = this.sortedCommands.filter(
      (c) => c.id.startsWith(name + ':') && c.id.split(':').length === depth + 1,
    )

    const state = this.config.pjson?.oclif?.state
    if (state) this.log(`This topic is in ${state}.\n`)

    this.log(this.formatTopic(topic))

    if (subTopics.length > 0) {
      this.log(this.formatTopics(subTopics))
      this.log('')
    }

    if (commands.length > 0) {
      this.log(this.formatCommands(commands))
      this.log('')
    }
  }

  protected summary(c: Command.Loadable): string | undefined {
    if (this.opts.sections && !this.opts.sections.map((s) => s.toLowerCase()).includes('summary')) return
    if (c.summary) return colorize(this.config?.theme?.commandSummary, this.render(c.summary.split('\n')[0]))
    return c.description && colorize(this.config?.theme?.commandSummary, this.render(c.description).split('\n')[0])
  }
}

interface HelpBaseDerived {
  new (config: Interfaces.Config, opts?: Partial<Interfaces.HelpOptions>): HelpBase
}

function extractClass(exported: any): HelpBaseDerived {
  return exported && exported.default ? exported.default : exported
}

function determineLocation(helpClass: string | HelpLocationOptions): HelpLocationOptions {
  if (typeof helpClass === 'string') return {identifier: 'default', target: helpClass}
  if (!helpClass.identifier) return {...helpClass, identifier: 'default'}
  return helpClass
}

export async function loadHelpClass(config: Interfaces.Config): Promise<HelpBaseDerived> {
  if (config.pjson.oclif?.helpClass) {
    const {identifier, target} = determineLocation(config.pjson.oclif?.helpClass)
    try {
      const path = (await tsPath(config.root, target)) ?? target
      const module = await load(config, path)
      const helpClass = module[identifier] ?? (identifier === 'default' ? extractClass(module) : undefined)
      return extractClass(helpClass)
    } catch (error: any) {
      throw new Error(`Unable to load configured help class "${target}", failed with message:\n${error.message}`)
    }
  }

  return Help
}
````

## File: src/help/root.ts
````typescript
import ansis from 'ansis'

import * as Interfaces from '../interfaces'
import {compact} from '../util/util'
import {colorize} from '../ux/theme'
import {HelpFormatter} from './formatter'

export default class RootHelp extends HelpFormatter {
  constructor(
    public config: Interfaces.Config,
    public opts: Interfaces.HelpOptions,
  ) {
    super(config, opts)
  }

  protected description(): string | undefined {
    let description = this.config.pjson.oclif.description || this.config.pjson.description || ''
    description = this.render(description)
    description = description.split('\n').slice(1).join('\n')
    if (!description) return
    return this.section('DESCRIPTION', this.wrap(colorize(this.config?.theme?.sectionDescription, description)))
  }

  root(): string {
    let description = this.config.pjson.oclif.description || this.config.pjson.description || ''
    description = this.render(description)
    description = description.split('\n')[0]
    let output = compact([
      colorize(this.config?.theme?.commandSummary, description),
      this.version(),
      this.usage(),
      this.description(),
    ]).join('\n\n')
    if (this.opts.stripAnsi) output = ansis.strip(output)
    return output
  }

  protected usage(): string {
    return this.section(
      this.opts.usageHeader || 'USAGE',
      this.wrap(
        `${colorize(this.config?.theme?.dollarSign, '$')} ${colorize(
          this.config?.theme?.bin,
          this.config.bin,
        )} ${colorize(this.config?.theme?.sectionDescription, '[COMMAND]')}`,
      ),
    )
  }

  protected version(): string {
    return this.section('VERSION', this.wrap(colorize(this.config?.theme?.version, this.config.userAgent)))
  }
}
````

## File: src/help/util.ts
````typescript
import * as ejs from 'ejs'

import {collectUsableIds} from '../config/util'
import {Deprecation, Config as IConfig} from '../interfaces'
import {toStandardizedId} from '../util/ids'

export function template(context: any): (t: string) => string {
  function render(t: string): string {
    return ejs.render(t, context)
  }

  return render
}

const isFlag = (s: string) => s.startsWith('-')
const isArgWithValue = (s: string) => s.includes('=')

function collateSpacedCmdIDFromArgs(argv: string[], config: IConfig): string[] {
  if (argv.length === 1) return argv

  const findId = (argv: string[]): string | undefined => {
    const ids = collectUsableIds(config.commandIDs)

    const final: string[] = []
    const idPresent = (id: string) => ids.has(id)
    const finalizeId = (s?: string) => (s ? [...final, s] : final).filter(Boolean).join(':')

    const hasArgs = () => {
      const id = finalizeId()
      if (!id) return false
      const cmd = config.findCommand(id)
      return Boolean(cmd && (cmd.strict === false || Object.keys(cmd.args ?? {}).length > 0))
    }

    for (const arg of argv) {
      if (idPresent(finalizeId(arg))) final.push(arg)
      // If the parent topic has a command that expects positional arguments, then we cannot
      // assume that any subsequent string could be part of the command name
      else if (isArgWithValue(arg) || isFlag(arg) || hasArgs()) break
      else final.push(arg)
    }

    return finalizeId()
  }

  const id = findId(argv)

  if (id) {
    const argvSlice = argv.slice(id.split(':').length)
    return [id, ...argvSlice]
  }

  return argv // ID is argv[0]
}

export function standardizeIDFromArgv(argv: string[], config: IConfig): string[] {
  if (argv.length === 0) return argv
  if (config.topicSeparator === ' ') argv = collateSpacedCmdIDFromArgs(argv, config)
  else if (config.topicSeparator !== ':') argv[0] = toStandardizedId(argv[0], config)
  return argv
}

export function getHelpFlagAdditions(config: IConfig): string[] {
  const helpFlags = ['--help']
  const additionalHelpFlags = config.pjson.oclif.additionalHelpFlags ?? []
  return [...new Set([...additionalHelpFlags, ...helpFlags]).values()]
}

export function formatFlagDeprecationWarning(flag: string, opts: Deprecation | true): string {
  let message = `The "${flag}" flag has been deprecated`
  if (opts === true) return `${message}.`
  if (opts.message) return opts.message

  if (opts.version) {
    message += ` and will be removed in version ${opts.version}`
  }

  message += opts.to ? `. Use "${opts.to}" instead.` : '.'

  return message
}

export function formatCommandDeprecationWarning(command: string, opts?: Deprecation): string {
  let message = `The "${command}" command has been deprecated`
  if (!opts) return `${message}.`

  if (opts.message) return opts.message

  if (opts.version) {
    message += ` and will be removed in version ${opts.version}`
  }

  message += opts.to ? `. Use "${opts.to}" instead.` : '.'

  return message
}

export function normalizeArgv(config: IConfig, argv = process.argv.slice(2)): string[] {
  if (config.topicSeparator !== ':' && !argv[0]?.includes(':')) argv = standardizeIDFromArgv(argv, config)
  return argv
}
````

## File: src/interfaces/alphabet.ts
````typescript
export type AlphabetUppercase =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'E'
  | 'F'
  | 'G'
  | 'H'
  | 'I'
  | 'J'
  | 'K'
  | 'L'
  | 'M'
  | 'N'
  | 'O'
  | 'P'
  | 'Q'
  | 'R'
  | 'S'
  | 'T'
  | 'U'
  | 'V'
  | 'W'
  | 'X'
  | 'Y'
  | 'Z'
export type AlphabetLowercase =
  | 'a'
  | 'b'
  | 'c'
  | 'd'
  | 'e'
  | 'f'
  | 'g'
  | 'h'
  | 'i'
  | 'j'
  | 'k'
  | 'l'
  | 'm'
  | 'n'
  | 'o'
  | 'p'
  | 'q'
  | 'r'
  | 's'
  | 't'
  | 'u'
  | 'v'
  | 'w'
  | 'x'
  | 'y'
  | 'z'
````

## File: src/interfaces/args.ts
````typescript
import {ArgInput} from './parser'

/**
 * Infer the args that are returned by Command.parse. This is useful for when you want to assign the args as a class property.
 *
 * @example
 * export type StatusArgs = Interfaces.InferredArgs<typeof Status.args>
 *
 * export default class Status {
 *   static args = {
 *     force: Args.boolean({char: 'f', description: 'a flag'}),
 *   }
 *
 *   public args!: StatusArgs
 *
 *   public async run(): Promise<StatusArgs> {
 *     const result = await this.parse(Status)
 *     this.args = result.args
 *     return result.args
 *   }
 * }
 */
export type InferredArgs<T> = T extends ArgInput<infer F> ? F : unknown
````

## File: src/interfaces/config.ts
````typescript
import {Command} from '../command'
import {Hook, Hooks} from './hooks'
import {OclifConfiguration, PJSON, S3Templates} from './pjson'
import {Options, Plugin} from './plugin'
import {Theme} from './theme'
import {Topic} from './topic'

export type LoadOptions = Config | Options | string | undefined
export type PlatformTypes = 'wsl' | NodeJS.Platform
export type ArchTypes = 'arm' | 'arm64' | 'mips' | 'mipsel' | 'ppc' | 'ppc64' | 's390' | 's390x' | 'x32' | 'x64' | 'x86'

export type PluginVersionDetail = {
  root: string
  type: string
  version: string
}

export type VersionDetails = {
  architecture: string
  cliVersion: string
  nodeVersion: string
  osVersion?: string
  pluginVersions?: Record<string, PluginVersionDetail>
  rootPath?: string
  shell?: string
}

export interface Config {
  /**
   * process.arch
   */
  readonly arch: ArchTypes
  /**
   * bin name of CLI command
   */
  readonly bin: string
  /**
   * name of any bin aliases that will execute the cli
   */
  readonly binAliases?: string[] | undefined
  readonly binPath?: string | undefined
  /**
   * cache directory to use for CLI
   *
   * example ~/Library/Caches/mycli or ~/.cache/mycli
   */
  readonly cacheDir: string
  readonly channel: string
  readonly commandIDs: string[]
  readonly commands: Command.Loadable[]
  /**
   * config directory to use for CLI
   *
   * example: ~/.config/mycli
   */
  readonly configDir: string
  /**
   * data directory to use for CLI
   *
   * example: ~/.local/share/mycli
   */
  readonly dataDir: string
  /**
   * base dirname to use in cacheDir/configDir/dataDir
   */
  readonly dirname: string
  findCommand(id: string, opts: {must: true}): Command.Loadable
  findCommand(id: string, opts?: {must: boolean}): Command.Loadable | undefined
  findMatches(id: string, argv: string[]): Command.Loadable[]
  findTopic(id: string, opts: {must: true}): Topic
  findTopic(id: string, opts?: {must: boolean}): Topic | undefined
  readonly flexibleTaxonomy?: boolean
  getAllCommandIDs(): string[]
  getAllCommands(): Command.Loadable[]
  getPluginsList(): Plugin[]
  /**
   * path to home directory
   *
   * example: /home/myuser
   */
  readonly home: string
  readonly isSingleCommandCLI: boolean
  readonly name: string
  /**
   * npm registry to use for installing plugins
   */
  readonly npmRegistry?: string | undefined
  readonly nsisCustomization?: string | undefined
  readonly pjson: PJSON
  /**
   * process.platform
   */
  readonly platform: PlatformTypes
  readonly plugins: Map<string, Plugin>
  readonly root: string

  runCommand<T = unknown>(id: string, argv?: string[], cachedCommand?: Command.Loadable): Promise<T>
  runHook<T extends keyof Hooks>(
    event: T,
    opts: Hooks[T]['options'],
    timeout?: number,
    captureErrors?: boolean,
  ): Promise<Hook.Result<Hooks[T]['return']>>
  s3Key(type: 'unversioned' | 'versioned', ext: '.tar.gz' | '.tar.xz', options?: Config.s3Key.Options): string
  s3Key(type: keyof S3Templates, options?: Config.s3Key.Options): string
  s3Url(key: string): string
  scopedEnvVar(key: string): string | undefined
  scopedEnvVarKey(key: string): string
  scopedEnvVarKeys(key: string): string[]
  scopedEnvVarTrue(key: string): boolean
  /**
   * active shell
   */
  readonly shell: string
  readonly theme?: Theme | undefined
  readonly topics: Topic[]
  topicSeparator: ' ' | ':'
  readonly updateConfig: NonNullable<OclifConfiguration['update']>
  /**
   * user agent to use for http calls
   *
   * example: mycli/1.2.3 (darwin-x64) node-9.0.0
   */
  readonly userAgent: string
  readonly valid: boolean
  readonly version: string
  readonly versionDetails: VersionDetails
  /**
   * if windows
   */
  readonly windows: boolean
}

export namespace Config {
  export namespace s3Key {
    export interface Options {
      [key: string]: any
      arch?: ArchTypes
      platform?: PlatformTypes
    }
  }
}
````

## File: src/interfaces/errors.ts
````typescript
export type CommandError = Error & {exitCode?: number}

export interface OclifError {
  oclif: {
    exit?: number | undefined
  }
}

export interface PrettyPrintableError {
  /**
   * a unique error code for this error class
   */
  code?: string | undefined

  /**
   * message to display related to the error
   */
  message?: string | undefined

  /**
   * a url to find out more information related to this error
   * or fixing the error
   */
  ref?: string | undefined

  /**
   * a suggestion that may be useful or provide additional context
   */
  suggestions?: string[] | undefined
}
````

## File: src/interfaces/flags.ts
````typescript
import {FlagInput} from './parser'

/**
 * Infer the flags that are returned by Command.parse. This is useful for when you want to assign the flags as a class property.
 *
 * @example
 * export type StatusFlags = Interfaces.InferredFlags<typeof Status.flags && typeof Status.baseFlags>
 *
 * export abstract class BaseCommand extends Command {
 *   static enableJsonFlag = true
 *
 *   static flags = {
 *     config: Flags.string({
 *       description: 'specify config file',
 *     }),
 *   }
 * }
 *
 * export default class Status extends BaseCommand {
 *   static flags = {
 *     force: Flags.boolean({char: 'f', description: 'a flag'}),
 *   }
 *
 *   public flags!: StatusFlags
 *
 *   public async run(): Promise<StatusFlags> {
 *     const result = await this.parse(Status)
 *     this.flags = result.flags
 *     return result.flags
 *   }
 * }
 */
export type InferredFlags<T> = T extends FlagInput<infer F> ? F & {json: boolean | undefined} : unknown
````

## File: src/interfaces/help.ts
````typescript
export interface HelpOptions {
  all?: boolean
  /**
   * Use docopts as the usage. Defaults to true.
   */
  docopts?: boolean
  /**
   * Order in which to sort flags in help output. Defaults to `alphabetical`.
   *
   * `alphabetical`: Sort flags alphabetically. All flags with short characters will come first.
   * `none`: Do not sort flags. They will appear in the order in which they were defined on the command.
   */
  flagSortOrder?: 'alphabetical' | 'none'
  /**
   * If true, hide command aliases from the root help output. Defaults to false.
   */
  hideAliasesFromRoot?: boolean
  /**
   * By default, the command summary is show at the top of the help and as the first line in
   * the command description. Repeating the summary in the command description improves readability
   * especially for long command help output. If there is no `command.summary`, the first line of
   * the description is treated as the summary. Some CLIs, especially with very simple commands, may
   * not want the duplication.
   */
  hideCommandSummaryInDescription?: boolean
  maxWidth: number
  /**
   * Respect the `noCacheDefault` property on flags. Defaults to false.
   */
  respectNoCacheDefault?: boolean
  /**
   * Only show the help for the specified sections. Defaults to all sections.
   */
  sections?: string[]
  /**
   * By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
   */
  sendToStderr?: boolean
  /**
   * By default, titles show flag values as `<value>`. Some CLI developers may prefer titles
   * to show the flag name as the value. i.e. `--myflag=myflag` instead of `--myflag=<value>`.
   * An individual flag can set this using `flag.helpValue=flag.name`.
   */
  showFlagNameInTitle?: boolean
  /**
   * By default, option values on flags are shown in the flag's description. This is because
   * long options list ruin the formatting of help. If a CLI knows all commands will not
   * do this, it can be turned off at a help level using this property. An individual flag
   * can set this using `flag.helpValue=options.join('|')`.
   */
  showFlagOptionsInTitle?: boolean
  stripAnsi?: boolean
  /**
   * Use USAGE, but some may want to use USAGE as used in gnu man pages. See help recommendations at
   * http://www.gnu.org/software/help2man/#--help-recommendations
   */
  usageHeader?: string
}
````

## File: src/interfaces/hooks.ts
````typescript
import {Command} from '../command'
import {Config} from './config'
import {Input, OutputFlags} from './parser'
import {Plugin} from './plugin'

interface HookMeta {
  options: Record<string, unknown>
  return: any
}

type Context = {
  debug(...args: any[]): void
  error(message: Error | string, options?: {code?: string; exit?: number}): void
  exit(code?: number): void
  log(message?: any, ...args: any[]): void
  warn(message: string): void
}

export interface Hooks {
  [event: string]: HookMeta
  command_incomplete: {
    options: {argv: string[]; id: string; matches: Command.Loadable[]}
    return: unknown
  }
  command_not_found: {
    options: {argv?: string[]; id: string}
    return: unknown
  }
  finally: {
    options: {argv: string[]; id: string}
    return: void
  }
  init: {
    options: {argv: string[]; id: string | undefined}
    return: void
  }
  jit_plugin_not_installed: {
    options: {argv: string[]; command: Command.Loadable; id: string; pluginName: string; pluginVersion: string}
    return: unknown
  }
  'plugins:preinstall': {
    options: {
      plugin: {name: string; tag: string; type: 'npm'} | {type: 'repo'; url: string}
    }
    return: void
  }
  postrun: {
    options: {
      Command: Command.Class
      argv: string[]
      result?: any
    }
    return: void
  }
  preparse: {
    options: {
      argv: string[]
      options: Input<OutputFlags<any>, OutputFlags<any>, OutputFlags<any>>
    }
    return: string[]
  }
  prerun: {
    options: {Command: Command.Class; argv: string[]}
    return: void
  }
  preupdate: {
    options: {channel: string; version: string}
    return: void
  }
  update: {
    options: {channel: string; version: string}
    return: void
  }
}

export type Hook<T extends keyof P, P extends Hooks = Hooks> = (
  this: Hook.Context,
  options: P[T]['options'] & {config: Config; context: Context},
) => Promise<P[T]['return']>

export namespace Hook {
  /**
   * Runs at the end of the CLI lifecycle - regardless of success or failure.
   */
  export type Finally = Hook<'finally'>
  /**
   * Runs when the CLI is initialized before a command is executed.
   */
  export type Init = Hook<'init'>
  /**
   * Runs before the `plugins install` command from @oclif/plugin-plugins is run.
   */
  export type PluginsPreinstall = Hook<'plugins:preinstall'>
  /**
   * Runs after the `init` hook, after a command is found but before it is executed.
   */
  export type Prerun = Hook<'prerun'>
  /**
   * Runs after a command is successfully executed. Does not run if the command fails.
   */
  export type Postrun = Hook<'postrun'>
  /**
   * Runs before the CLI is updated by `update` command from @oclif/plugin-update.
   */
  export type Preupdate = Hook<'preupdate'>
  /**
   * Runs before a command's flags and args are parsed. Useful for modifying the command line arguments before they are parsed.
   *
   * The return value is a string[] of the modified arguments.
   */
  export type Preparse = Hook<'preparse'>
  /**
   * Runs once the `update` command from @oclif/plugin-update is run.
   */
  export type Update = Hook<'update'>
  /**
   * Runs when a command is not found.
   */
  export type CommandNotFound = Hook<'command_not_found'>
  /**
   * Runs when a partial command is entered and no matching command is found.
   */
  export type CommandIncomplete = Hook<'command_incomplete'>
  /**
   * Runs when a command from an uninstalled JIT plugins is run.
   */
  export type JitPluginNotInstalled = Hook<'jit_plugin_not_installed'>

  export interface Context {
    config: Config
    debug(...args: any[]): void
    error(message: Error | string, options?: {code?: string; exit?: number}): void
    exit(code?: number): void
    log(message?: any, ...args: any[]): void
    warn(message: string): void
  }

  export interface Result<T> {
    failures: Array<{error: Error; plugin: Plugin}>
    successes: Array<{plugin: Plugin; result: T}>
  }
}
````

## File: src/interfaces/index.ts
````typescript
export type {AlphabetLowercase, AlphabetUppercase} from './alphabet'
export type {InferredArgs} from './args'
export type {ArchTypes, Config, LoadOptions, PlatformTypes, PluginVersionDetail, VersionDetails} from './config'
export type {CommandError, OclifError, PrettyPrintableError} from './errors'
export type {InferredFlags} from './flags'
export type {HelpOptions} from './help'
export type {Hook, Hooks} from './hooks'
export type {Logger} from './logger'
export type {Manifest} from './manifest'
export type {
  Arg,
  ArgDefinition,
  ArgInput,
  BooleanFlag,
  CustomOptions,
  Deprecation,
  Flag,
  FlagDefinition,
  FlagInput,
  Input,
  OptionFlag,
  OutputArgs,
  OutputFlags,
  ParserOutput,
} from './parser'
export type {LinkedPlugin, OclifConfiguration, PJSON, S3, S3Templates, UserPJSON, UserPlugin} from './pjson'
export type {Options, Plugin, PluginOptions} from './plugin'
export type {S3Manifest} from './s3-manifest'
export type {Theme} from './theme'
export type {Topic} from './topic'
export type {TSConfig} from './ts-config'
````

## File: src/interfaces/logger.ts
````typescript
export type Logger = {
  debug: (formatter: unknown, ...args: unknown[]) => void
  error: (formatter: unknown, ...args: unknown[]) => void
  info: (formatter: unknown, ...args: unknown[]) => void
  trace: (formatter: unknown, ...args: unknown[]) => void
  warn: (formatter: unknown, ...args: unknown[]) => void
  child: (namespace: string) => Logger
  namespace: string
}
````

## File: src/interfaces/manifest.ts
````typescript
import {Command} from '../command'

export type Manifest = {
  commands: {[id: string]: Command.Cached}
  version: string
}
````

## File: src/interfaces/parser.ts
````typescript
import {Command} from '../command'
import {AlphabetLowercase, AlphabetUppercase} from './alphabet'

export type FlagOutput = {[name: string]: any}
export type ArgOutput = {[name: string]: any}

export type CLIParseErrorOptions = {
  parse: {
    input?: ParserInput | undefined
    output?: ParserOutput | undefined
  }
  exit?: number | undefined
}

export type OutputArgs<T extends ParserInput['args']> = {[P in keyof T]: any}
export type OutputFlags<T extends ParserInput['flags']> = {[P in keyof T]: any}

export type ParserOutput<
  TFlags extends OutputFlags<any> = any,
  BFlags extends OutputFlags<any> = any,
  TArgs extends OutputFlags<any> = any,
> = {
  // Add in the --json flag so that it shows up in the types.
  // This is necessary because there's no way to optionally add the json flag based
  // on wether enableJsonFlag is set in the command.
  flags: TFlags & BFlags & {json: boolean | undefined}
  args: TArgs
  argv: unknown[]
  raw: ParsingToken[]
  metadata: Metadata
  nonExistentFlags: string[]
}

export type ArgToken = {type: 'arg'; arg: string; input: string}
export type FlagToken = {type: 'flag'; flag: string; input: string}
export type ParsingToken = ArgToken | FlagToken

export type FlagUsageOptions = {displayRequired?: boolean}

export type Metadata = {
  flags: {[key: string]: MetadataFlag}
}

export type MetadataFlag = {
  setFromDefault?: boolean
  defaultHelp?: unknown
}

export type ListItem = [string, string | undefined]
export type List = ListItem[]

export type CustomOptions = Record<string, unknown>

export type DefaultContext<T> = {
  options: T
  flags: Record<string, string>
}

/**
 * Type to define a default value for a flag.
 * @param context The context of the flag.
 */
export type FlagDefault<T, P = CustomOptions> = T | ((context: DefaultContext<P & OptionFlag<T, P>>) => Promise<T>)

/**
 * Type to define a defaultHelp value for a flag.
 * The defaultHelp value is used in the help output for the flag and when writing a manifest.
 * It is also can be used to provide a value for the flag when issuing certain error messages.
 *
 * @param context The context of the flag.
 */
export type FlagDefaultHelp<T, P = CustomOptions> =
  | T
  | ((context: DefaultContext<P & OptionFlag<T, P>>) => Promise<string | undefined>)

/**
 * Type to define a default value for an arg.
 * @param context The context of the arg.
 */
export type ArgDefault<T, P = CustomOptions> = T | ((context: DefaultContext<Arg<T, P>>) => Promise<T>)

/**
 * Type to define a defaultHelp value for an arg.
 * @param context The context of the arg.
 */
export type ArgDefaultHelp<T, P = CustomOptions> =
  | T
  | ((context: DefaultContext<Arg<T, P>>) => Promise<string | undefined>)

export type FlagRelationship = string | {name: string; when: (flags: Record<string, unknown>) => Promise<boolean>}
export type Relationship = {
  type: 'all' | 'some' | 'none'
  flags: FlagRelationship[]
}

export type Deprecation = {
  to?: string
  message?: string
  version?: string | number
}

export type FlagProps = {
  name: string
  char?: AlphabetLowercase | AlphabetUppercase
  /**
   * A short summary of flag usage to show in the flag list.
   * If not provided, description will be used.
   */
  summary?: string
  /**
   * A description of flag usage. If summary is provided, the description
   * is assumed to be a longer description and will be shown in a separate
   * section within help.
   */
  description?: string
  /**
   * The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is
   * only displayed if the char is defined.
   */
  helpLabel?: string
  /**
   * Shows this flag in a separate list in the help.
   */
  helpGroup?: string
  /**
   * Accept an environment variable as input
   */
  env?: string
  /**
   * If true, the flag will not be shown in the help.
   */
  hidden?: boolean
  /**
   * If true, the flag will be required.
   */
  required?: boolean
  /**
   * List of flags that this flag depends on.
   */
  dependsOn?: string[]
  /**
   * List of flags that cannot be used with this flag.
   */
  exclusive?: string[]
  /**
   * Exactly one of these flags must be provided.
   */
  exactlyOne?: string[]
  /**
   * Define complex relationships between flags.
   */
  relationships?: Relationship[]
  /**
   * Make the flag as deprecated.
   */
  deprecated?: true | Deprecation
  /**
   * Alternate names that can be used for this flag.
   */
  aliases?: string[]
  /**
   * Alternate short chars that can be used for this flag.
   */
  charAliases?: (AlphabetLowercase | AlphabetUppercase)[]
  /**
   * Emit deprecation warning when a flag alias is provided
   */
  deprecateAliases?: boolean
  /**
   * If true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.
   * This is helpful if the default value contains sensitive data that shouldn't be published to npm.
   */
  noCacheDefault?: boolean
  /**
   * At least one of these flags must be provided.
   */
  atLeastOne?: string[]
}

export type ArgProps = {
  name: string
  /**
   * A description of flag usage. If summary is provided, the description
   * is assumed to be a longer description and will be shown in a separate
   * section within help.
   */
  description?: string
  /**
   * If true, the flag will not be shown in the help.
   */
  hidden?: boolean
  /**
   * If true, the flag will be required.
   */
  required?: boolean

  options?: string[]
  ignoreStdin?: boolean
  /**
   * If true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.
   * This is helpful if the default value contains sensitive data that shouldn't be published to npm.
   */
  noCacheDefault?: boolean
}

export type BooleanFlagProps = FlagProps & {
  type: 'boolean'
  allowNo: boolean
}

export type OptionFlagProps = FlagProps & {
  type: 'option'
  helpValue?: string | string[]
  options?: readonly string[]
  multiple?: boolean
  /**
   * Parse one value per flag; allow `-m val1 -m val2`, disallow `-m val1 val2`.
   * Set to true to use "multiple: true" flags together with args.
   * Only respected if multiple is set to true.
   */
  multipleNonGreedy?: boolean
  /**
   * Delimiter to separate the values for a multiple value flag.
   * Only respected if multiple is set to true. Default behavior is to
   * separate on spaces.
   */
  delimiter?: ','
  /**
   * Allow input value to be read from stdin if the provided value is `-`.
   * If set to `only`, the flag will only accept input from stdin.
   * Should only be used on one flag at a time.
   */
  allowStdin?: boolean | 'only'
}

export type FlagParserContext = Command & {token: FlagToken}

type NonNullableElementOf<T> = [NonNullable<T>] extends [Array<infer U>] ? U : T

export type FlagParser<T, I extends string | boolean, P = CustomOptions> = (
  input: I,
  context: FlagParserContext,
  opts: P & OptionFlag<T, P>,
) => Promise<NonNullableElementOf<T> | undefined>

export type ArgParserContext = Command & {token: ArgToken}

export type ArgParser<T, P = CustomOptions> = (
  input: string,
  context: ArgParserContext,
  opts: P & Arg<T, P>,
) => Promise<T>

export type Arg<T, P = CustomOptions> = ArgProps & {
  options?: T[]
  defaultHelp?: ArgDefaultHelp<T>
  input: string[]
  default?: ArgDefault<T | undefined>
  parse: ArgParser<T, P>
}

export type ArgDefinition<T, P = CustomOptions> = {
  (options: P & ({required: true} | {default: ArgDefault<T>}) & Partial<Arg<T, P>>): Arg<T, P>
  (options?: P & Partial<Arg<T, P>>): Arg<T | undefined, P>
}

export type BooleanFlag<T> = FlagProps &
  BooleanFlagProps & {
    /**
     * specifying a default of false is the same as not specifying a default
     */
    default?: FlagDefault<boolean>
    parse: (input: boolean, context: FlagParserContext, opts: FlagProps & BooleanFlagProps) => Promise<T>
  }

export type OptionFlag<T, P = CustomOptions> = FlagProps &
  OptionFlagProps & {
    parse: FlagParser<T | undefined, string, P>
    defaultHelp?: FlagDefaultHelp<T, P>
    input: string[]
    default?: FlagDefault<T | undefined, P>
  }

type ReturnTypeSwitches = {multiple: boolean; requiredOrDefaulted: boolean}

/**
 * The logic here is as follows:
 * - If requiredOrDefaulted is true && multiple is true, then the return type is T[]
 *    - It's possible that T extends an Array, if so we want to return T so that the return isn't T[][]
 * - If requiredOrDefaulted is true && multiple is false, then the return type is T
 * - If requiredOrDefaulted is false && multiple is true, then the return type is T[] | undefined
 *    - It's possible that T extends an Array, if so we want to return T so that the return isn't T[][]
 * - If requiredOrDefaulted is false && multiple is false, then the return type is T | undefined
 */
type FlagReturnType<T, R extends ReturnTypeSwitches> = R['requiredOrDefaulted'] extends true
  ? R['multiple'] extends true
    ? [T] extends [Array<unknown>]
      ? T
      : T[]
    : T
  : R['multiple'] extends true
    ? [T] extends [Array<unknown>]
      ? T | undefined
      : T[] | undefined
    : T | undefined

/**
 * FlagDefinition types a function that takes `options` and returns an OptionFlag<T>.
 *
 * This is returned by `Flags.custom()` and `Flags.option()`, which each take a `defaults` object
 * that mirrors the OptionFlag interface.
 *
 * The `T` in the `OptionFlag<T>` return type is determined by a combination of the provided defaults for
 * `multiple`, `required`, and `default` and the provided options for those same properties. If these properties
 * are provided in the options, they override the defaults.
 *
 * no options or defaults -> T | undefined
 * `required` -> T
 * `default` -> T
 * `multiple` -> T[] | undefined
 * `required` + `multiple` -> T[]
 * `default` + `multiple` -> T[]
 */
export type FlagDefinition<
  T,
  P = CustomOptions,
  R extends ReturnTypeSwitches = {multiple: false; requiredOrDefaulted: false},
> = {
  (
    // `multiple` is set to false and `required` is set to true in options, potentially overriding the default
    options: P & {multiple: false; required: true} & Partial<
        OptionFlag<FlagReturnType<T, {multiple: false; requiredOrDefaulted: true}>, P>
      >,
  ): OptionFlag<FlagReturnType<T, {multiple: false; requiredOrDefaulted: true}>>
  (
    // `multiple` is set to true and `required` is set to false in options, potentially overriding the default
    options: P & {multiple: true; required: false} & Partial<
        OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: false}>, P>
      >,
  ): OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: false}>>
  (
    // `multiple` is set to true and `required` is set to false in options, potentially overriding the default
    options: P & {multiple: false; required: false} & Partial<
        OptionFlag<FlagReturnType<T, {multiple: false; requiredOrDefaulted: false}>, P>
      >,
  ): OptionFlag<FlagReturnType<T, {multiple: false; requiredOrDefaulted: false}>>
  (
    options: R['multiple'] extends true
      ? // `multiple` is defaulted to true and either `required=true` or `default` are provided in options
        P &
          (
            | {required: true}
            | {
                default: OptionFlag<
                  FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>,
                  P
                >['default']
              }
          ) &
          Partial<OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>, P>>
      : // `multiple` is NOT defaulted to true and either `required=true` or `default` are provided in options
        P & {multiple?: false | undefined} & (
            | {required: true}
            | {
                default: OptionFlag<
                  FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>,
                  P
                >['default']
              }
          ) &
          Partial<OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>, P>>,
  ): OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>>
  (
    options: R['multiple'] extends true
      ? // `multiple` is defaulted to true and either `required=true` or `default` are provided in options
        P &
          (
            | {required: true}
            | {default: OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: true}>, P>['default']}
          ) &
          Partial<OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: true}>, P>>
      : // `multiple` is NOT defaulted to true but `multiple=true` and either `required=true` or `default` are provided in options
        P & {multiple: true} & (
            | {required: true}
            | {default: OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: true}>, P>['default']}
          ) &
          Partial<OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: true}>, P>>,
  ): OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: true}>>
  (
    // `multiple` is not provided in options but either `required=true` or `default` are provided
    options: P & {multiple?: false | undefined} & (
        | {required: true}
        | {default: OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>, P>['default']}
      ) &
      Partial<OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>, P>>,
  ): OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: true}>>
  (
    // `required` is set to false in options, potentially overriding the default
    options: P & {required: false} & Partial<
        OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: false}>, P>
      >,
  ): OptionFlag<FlagReturnType<T, {multiple: R['multiple']; requiredOrDefaulted: false}>>
  (
    // `multiple` is set to false in options, potentially overriding the default
    options: P & {multiple: false} & Partial<
        OptionFlag<FlagReturnType<T, {multiple: false; requiredOrDefaulted: R['requiredOrDefaulted']}>, P>
      >,
  ): OptionFlag<FlagReturnType<T, {multiple: false; requiredOrDefaulted: R['requiredOrDefaulted']}>>
  (
    // Catch all for when `multiple` is not set in the options
    options?: P & {multiple?: false | undefined} & Partial<OptionFlag<FlagReturnType<T, R>, P>>,
  ): OptionFlag<FlagReturnType<T, R>>
  (
    // `multiple` is set to true in options, potentially overriding the default
    options: P & {multiple: true} & Partial<
        OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: R['requiredOrDefaulted']}>, P>
      >,
  ): OptionFlag<FlagReturnType<T, {multiple: true; requiredOrDefaulted: R['requiredOrDefaulted']}>>
}

export type Flag<T> = BooleanFlag<T> | OptionFlag<T>

export type Input<TFlags extends FlagOutput, BFlags extends FlagOutput, AFlags extends ArgOutput> = {
  flags?: FlagInput<TFlags>
  baseFlags?: FlagInput<BFlags>
  enableJsonFlag?: true | false
  args?: ArgInput<AFlags>
  strict?: boolean | undefined
  context?: ParserContext
  '--'?: boolean
}

export type ParserInput = {
  argv: string[]
  flags: FlagInput<any>
  args: ArgInput<any>
  strict: boolean
  context: ParserContext | undefined
  '--'?: boolean | undefined
}

export type ParserContext = Command & {
  token?: FlagToken | ArgToken | undefined
}

export type FlagInput<T extends FlagOutput = {[flag: string]: any}> = {[P in keyof T]: Flag<T[P]>}

export type ArgInput<T extends ArgOutput = {[arg: string]: any}> = {[P in keyof T]: Arg<T[P]>}
````

## File: src/interfaces/pjson.ts
````typescript
import {HelpOptions} from './help'
import {Theme} from './theme'

export type CommandDiscovery = {
  /**
   * The strategy to use for loading commands.
   *
   * - `pattern` will use glob patterns to find command files in the specified `target`.
   * - `explicit` will use `import` (or `require` for CJS) to load the commands from the
   *    specified `target`.
   * - `single` will use the `target` which should export a command class. This is for CLIs that
   *    only have a single command.
   *
   * In both cases, the `oclif.manifest.json` file will be used to find the commands if it exists.
   */
  strategy: 'pattern' | 'explicit' | 'single'
  /**
   * If the `strategy` is `pattern`, this is the **directory** to use to find command files.
   *
   * If the `strategy` is `explicit`, this is the **file** that exports the commands.
   *   - This export must be an object with keys that are the command names and values that are the command classes.
   *   - Unless `identifier` is specified, the default export will be used.
   *
   * @example
   * ```typescript
   * // in src/commands.ts
   * import {Command} from '@oclif/core'
   * import Hello from './commands/hello/index.js'
   * import HelloWorld from './commands/hello/world.js'
   *
   * export default {
   *   hello: Hello,
   *   'hello:world': HelloWorld,
   * } satisfies Record<string, Command.Class>
   * ```
   */
  target: string
  /**
   * The glob patterns to use to find command files when no `oclif.manifest.json` is present.
   * This is only used when `strategy` is `pattern`.
   */
  globPatterns?: string[]
  /**
   * The name of the export to used when loading the command object from the `target` file. Only
   * used when `strategy` is `explicit`. Defaults to `default`.
   *
   * @example
   * ```typescript
   * // in src/commands.ts
   * import {Command} from '@oclif/core'
   * import Hello from './commands/hello/index.js'
   * import HelloWorld from './commands/hello/world.js'
   *
   * export const MY_COMMANDS = {
   *  hello: Hello,
   * 'hello:world': HelloWorld,
   * } satisfies Record<string, Command.Class>
   * ```
   *
   * In the package.json:
   * ```json
   * {
   *  "oclif": {
   *   "commands": {
   *     "strategy": "explicit",
   *     "target": "./dist/index.js",
   *     "identifier": "MY_COMMANDS"
   *    }
   * }
   * ```
   */
  identifier?: string
}

export type HookOptions = {
  /**
   * The file path containing hook.
   */
  target: string
  /**
   * The name of the export to use when loading the hook function from the `target` file. Defaults to `default`.
   */
  identifier: string
}

export type HelpLocationOptions = {
  /**
   * The file path containing help class.
   */
  target: string
  /**
   * The name of the export to use when loading the help class from the `target` file. Defaults to `default`.
   */
  identifier: string
}

export type S3Templates = {
  baseDir?: string
  manifest?: string
  unversioned?: string
  versioned?: string
}

export type S3 = {
  acl?: string | undefined
  bucket?: string | undefined
  folder?: string | undefined
  gz?: boolean | undefined
  host?: string | undefined
  indexVersionLimit?: number | undefined
  templates?:
    | {
        target: S3Templates
        vanilla: S3Templates
      }
    | undefined
  xz?: boolean | undefined
}

export type OclifConfiguration = {
  /**
   * Flags in addition to --help that should trigger help output.
   */
  additionalHelpFlags?: string[]
  /**
   * Flags in addition to --version that should trigger version output.
   */
  additionalVersionFlags?: string[]
  /**
   * Plugin aliases.
   */
  aliases?: {[name: string]: null | string}
  /**
   * The name of the executable.
   */
  bin?: string
  /**
   * Aliases for the executable.
   */
  binAliases?: string[]
  commands?: string | CommandDiscovery
  /**
   * Your CLI's description. Overrides the description in the package.json.
   */
  description?: string | undefined
  /**
   * Plugins to load when in development mode.
   */
  devPlugins?: string[]
  /**
   * The directory name to use when determining the cache, config, and data directories.
   */
  dirname?: string
  /**
   * Example plugin to use in @oclif/plugin-plugin's help output.
   */
  examplePlugin?: string
  /**
   * Customize the exit codes for the CLI.
   */
  exitCodes?: {
    default?: number
    failedFlagParsing?: number
    failedFlagValidation?: number
    invalidArgsSpec?: number
    nonExistentFlag?: number
    requiredArgs?: number
    unexpectedArgs?: number
  }
  /**
   * Enable flexible taxonomy for commands.
   */
  flexibleTaxonomy?: boolean
  /**
   * The location of your custom help class.
   */
  helpClass?: string | HelpLocationOptions
  /**
   * Options for the help output.
   */
  helpOptions?: HelpOptions
  /**
   * Register hooks to run at various points in the CLI lifecycle.
   */
  hooks?: {[name: string]: string | string[] | HookOptions | HookOptions[] | (string | HookOptions)[]}
  /**
   * Plugins that can be installed just-in-time.
   */
  jitPlugins?: Record<string, string>
  macos?: {
    identifier?: string
    sign?: string
  }
  /**
   * Use a private or alternate npm registry.
   */
  npmRegistry?: string
  /**
   * Script to run during postinstall on windows.
   */
  nsisCustomization?: string
  /**
   * Plugin prefix to use when working with plugins with @oclif/plugin-plugins.
   *
   * Defaults to `plugin-`.
   */
  pluginPrefix?: string
  /**
   * Plugins to load.
   */
  plugins?: string[]
  /**
   * Template string used to build links to source code in CLI's README (when using `oclif readme`).
   */
  repositoryPrefix?: string
  schema?: number
  /**
   * The namespace to be used for plugins of your CLI, e.g. `@salesforce`.
   */
  scope?: string
  /**
   * State of your CLI
   *
   * - `beta` - will show message to user that command or CLI is in beta
   * - `deprecated` - will show message to user that command or CLI is deprecated
   */
  state?: 'beta' | 'deprecated' | string
  /**
   * The theme to ship with the CLI.
   *
   * Can be a path to a JSON file or a Theme object.
   */
  theme?: string | Theme
  /**
   * Separator to use for your CLI. Can be `:` or ` `.
   */
  topicSeparator?: ' ' | ':'
  /**
   * Customize the topics in the CLI.
   */
  topics?: {
    [k: string]: {
      description?: string
      hidden?: boolean
      subtopics?: OclifConfiguration['topics']
    }
  }
  /**
   * Tar flags configuration for different platforms.
   * 
   * {
   *  "tarFlags": {
   *   "win32": "--force-local",
   *   "darwin": "--no-xattrs"
   *  }
   * }
   * 
   */
  tarFlags?: {
    [platform: string]: string
  }
  update?: {
    autoupdate?: {
      debounce?: number
      rollout?: number
    }
    disableNpmLookup?: boolean
    node?: {
      targets?: string[]
      version?: string
      options?: string | string[]
    }
    s3?: S3
  }
  'warn-if-update-available'?: {
    authorization?: string
    message?: string
    registry?: string
    timeoutInDays?: number
    frequency?: number
    frequencyUnit?: 'days' | 'hours' | 'minutes' | 'seconds' | 'milliseconds'
  }
  windows?: {
    homepage?: string
    keypath?: string
    name?: string
  }
}

export type UserPlugin = {
  name: string
  tag?: string
  type: 'user'
  url?: string
}

export type LinkedPlugin = {
  name: string
  root: string
  type: 'link'
}

export type UserPJSON = {
  oclif: {
    plugins?: (UserPlugin | LinkedPlugin)[]
  }
  private?: boolean
}

export type PJSON = {
  [k: string]: any
  dependencies?: {[name: string]: string}
  devDependencies?: {[name: string]: string}
  name: string
  oclif: OclifConfiguration
  version: string
}
````

## File: src/interfaces/plugin.ts
````typescript
import {Command} from '../command'
import {Logger} from './logger'
import {HookOptions, PJSON} from './pjson'
import {Topic} from './topic'

export interface PluginOptions {
  children?: Plugin[] | undefined
  errorOnManifestCreate?: boolean | undefined
  flexibleTaxonomy?: boolean | undefined
  ignoreManifest?: boolean | undefined
  isRoot?: boolean | undefined
  name?: string | undefined
  parent?: Plugin | undefined
  pjson?: PJSON | undefined
  respectNoCacheDefault?: boolean | undefined
  root: string
  tag?: string | undefined
  type?: string | undefined
  url?: string | undefined
}

export interface Options extends PluginOptions {
  channel?: string | undefined
  devPlugins?: boolean | undefined
  enablePerf?: boolean | undefined
  jitPlugins?: boolean | undefined
  logger?: Logger | undefined
  pjson?: PJSON | undefined
  pluginAdditions?:
    | {
        core?: string[]
        dev?: string[]
        path?: string
      }
    | undefined
  plugins?: Map<string, Plugin> | undefined
  userPlugins?: boolean | undefined
  version?: string | undefined
}

export interface Plugin {
  /**
   * ../config version
   */
  _base: string
  /**
   * aliases from package.json dependencies
   */
  alias: string
  readonly commandIDs: string[]
  commands: Command.Loadable[]
  readonly commandsDir: string | undefined
  findCommand(id: string, opts: {must: true}): Promise<Command.Class>
  findCommand(id: string, opts?: {must: boolean}): Promise<Command.Class> | undefined
  readonly hasManifest: boolean
  hooks: {[key: string]: HookOptions[]}
  /**
   * True if the plugin is the root plugin.
   */
  isRoot: boolean
  load(): Promise<void>

  /**
   * Plugin is written in ESM or CommonJS
   */
  moduleType: 'commonjs' | 'module'

  /**
   * name from package.json
   */
  name: string
  readonly options: Options
  parent?: Plugin | undefined
  /**
   * full package.json
   *
   * parsed with read-pkg
   */
  pjson: PJSON
  /**
   * base path of plugin
   */
  root: string
  /**
   * npm dist-tag of plugin
   * only used for user plugins
   */
  tag?: string | undefined

  readonly topics: Topic[]
  /**
   * used to tell the user how the plugin was installed
   * examples: core, link, user, dev
   */
  type: string
  /**
   * if it appears to be an npm package but does not look like it's really a CLI plugin, this is set to false
   */
  valid: boolean

  /**
   * version from package.json
   *
   * example: 1.2.3
   */
  version: string
}
````

## File: src/interfaces/s3-manifest.ts
````typescript
export interface S3Manifest {
  baseDir: string
  gz: string
  node: {
    compatible: string
    recommended: string
  }
  rollout?: number
  sha: string
  sha256gz: string
  sha256xz?: string
  version: string
  xz?: string
}
````

## File: src/interfaces/theme.ts
````typescript
export const STANDARD_ANSI = [
  'white',
  'black',
  'blue',
  'yellow',
  'green',
  'red',
  'magenta',
  'cyan',
  'gray',
  'blackBright',
  'redBright',
  'greenBright',
  'yellowBright',
  'blueBright',
  'magentaBright',
  'cyanBright',
  'whiteBright',
  'bgBlack',
  'bgRed',
  'bgGreen',
  'bgYellow',
  'bgBlue',
  'bgMagenta',
  'bgCyan',
  'bgWhite',
  'bgGray',
  'bgBlackBright',
  'bgRedBright',
  'bgGreenBright',
  'bgYellowBright',
  'bgBlueBright',
  'bgMagentaBright',
  'bgCyanBright',
  'bgWhiteBright',
  'bold',
  'underline',
  'dim',
  'italic',
  'strikethrough',
] as const

export type StandardAnsi = (typeof STANDARD_ANSI)[number]

export type JsonTheme = {
  brace?: string | StandardAnsi
  bracket?: string | StandardAnsi
  colon?: string | StandardAnsi
  comma?: string | StandardAnsi
  key?: string | StandardAnsi
  string?: string | StandardAnsi
  number?: string | StandardAnsi
  boolean?: string | StandardAnsi
  null?: string | StandardAnsi
}

export type Theme = {
  [key: string]: string | StandardAnsi | Theme | undefined
  alias?: string | StandardAnsi
  bin?: string | StandardAnsi
  command?: string | StandardAnsi
  commandSummary?: string | StandardAnsi
  dollarSign?: string | StandardAnsi
  flag?: string | StandardAnsi
  flagDefaultValue?: string | StandardAnsi
  flagOptions?: string | StandardAnsi
  flagRequired?: string | StandardAnsi
  flagSeparator?: string | StandardAnsi
  json?: JsonTheme
  sectionDescription?: string | StandardAnsi
  sectionHeader?: string | StandardAnsi
  spinner?: string | StandardAnsi
  topic?: string | StandardAnsi
  version?: string | StandardAnsi
}
````

## File: src/interfaces/topic.ts
````typescript
export interface Topic {
  description?: string | undefined
  hidden?: boolean | undefined
  name: string
}
````

## File: src/interfaces/ts-config.ts
````typescript
export interface TSConfig {
  compilerOptions: {
    baseUrl?: string
    emitDecoratorMetadata?: boolean
    esModuleInterop?: boolean
    experimentalDecorators?: boolean
    jsx?: boolean
    module?: string
    moduleResolution?: string
    outDir?: string
    rootDir?: string
    rootDirs?: string[]
    sourceMap?: boolean
    target?: string
  }
  extends?: string
  'ts-node'?: {
    esm?: boolean
    experimentalSpecifierResolution?: 'explicit' | 'node'
    scope?: boolean
    swc?: boolean
  }
}
````

## File: src/parser/errors.ts
````typescript
import Cache from '../cache'
import {CLIError} from '../errors'
import {Arg, ArgInput, CLIParseErrorOptions, OptionFlag} from '../interfaces/parser'
import {uniq} from '../util/util'
import renderList from '../ux/list'
import {colorize} from '../ux/theme'

export {CLIError} from '../errors'

export type Validation = {
  name: string
  reason?: string | undefined
  status: 'failed' | 'success'
  validationFn: string
}

export class CLIParseError extends CLIError {
  public parse: CLIParseErrorOptions['parse']
  public showHelp = false

  constructor(options: CLIParseErrorOptions & {message: string}) {
    options.message += '\nSee more help with --help'
    super(options.message, {exit: options.exit})
    this.parse = options.parse
  }
}

export class InvalidArgsSpecError extends CLIParseError {
  public args: ArgInput

  constructor({args, exit, parse}: CLIParseErrorOptions & {args: ArgInput}) {
    let message = 'Invalid argument spec'
    const namedArgs = Object.values(args).filter((a) => a.name)
    if (namedArgs.length > 0) {
      const list = renderList(
        namedArgs.map(
          (a) => [`${a.name} (${a.required ? 'required' : 'optional'})`, a.description] as [string, string],
        ),
      )
      message += `:\n${list}`
    }

    super({exit: Cache.getInstance().get('exitCodes')?.invalidArgsSpec ?? exit, message, parse})
    this.args = args
  }
}

export class RequiredArgsError extends CLIParseError {
  public args: Arg<any>[]

  constructor({
    args,
    exit,
    flagsWithMultiple,
    parse,
  }: CLIParseErrorOptions & {args: Arg<any>[]; flagsWithMultiple?: string[]}) {
    let message = `Missing ${args.length} required arg${args.length === 1 ? '' : 's'}`
    const namedArgs = args.filter((a) => a.name)
    if (namedArgs.length > 0) {
      const list = renderList(
        namedArgs.map((a) => {
          const description = a.options ? `(${a.options.join('|')}) ${a.description}` : a.description
          return [a.name, description]
        }),
      )
      message += `:\n${list}`
    }

    if (flagsWithMultiple?.length) {
      const flags = flagsWithMultiple.map((f) => `--${f}`).join(', ')
      message += `\n\nNote: ${flags} allow${
        flagsWithMultiple.length === 1 ? 's' : ''
      } multiple values. Because of this you need to provide all arguments before providing ${
        flagsWithMultiple.length === 1 ? 'that flag' : 'those flags'
      }.`
      message += '\nAlternatively, you can use "--" to signify the end of the flags and the beginning of arguments.'
    }

    super({exit: Cache.getInstance().get('exitCodes')?.requiredArgs ?? exit, message, parse})
    this.args = args
    this.showHelp = true
  }
}

export class UnexpectedArgsError extends CLIParseError {
  public args: unknown[]

  constructor({args, exit, parse}: CLIParseErrorOptions & {args: unknown[]}) {
    const message = `Unexpected argument${args.length === 1 ? '' : 's'}: ${args.join(', ')}`
    super({exit: Cache.getInstance().get('exitCodes')?.unexpectedArgs ?? exit, message, parse})
    this.args = args
    this.showHelp = true
  }
}

export class NonExistentFlagsError extends CLIParseError {
  public flags: string[]

  constructor({exit, flags, parse}: CLIParseErrorOptions & {flags: string[]}) {
    const message = `Nonexistent flag${flags.length === 1 ? '' : 's'}: ${flags.join(', ')}`
    super({exit: Cache.getInstance().get('exitCodes')?.nonExistentFlag ?? exit, message, parse})
    this.flags = flags
    this.showHelp = true
  }
}

export class FlagInvalidOptionError extends CLIParseError {
  constructor(flag: OptionFlag<any>, input: string) {
    const message = `Expected --${flag.name}=${input} to be one of: ${flag.options!.join(', ')}`
    super({message, parse: {}})
  }
}

export class ArgInvalidOptionError extends CLIParseError {
  constructor(arg: Arg<any>, input: string) {
    const message = `Expected ${input} to be one of: ${arg.options!.join(', ')}`
    super({message, parse: {}})
  }
}

export class FailedFlagValidationError extends CLIParseError {
  constructor({exit, failed, parse}: CLIParseErrorOptions & {failed: Validation[]}) {
    const reasons = failed.map((r) => r.reason)
    const deduped = uniq(reasons)
    const errString = deduped.length === 1 ? 'error' : 'errors'
    const message = `The following ${errString} occurred:\n  ${colorize('dim', deduped.join('\n  '))}`
    super({exit: Cache.getInstance().get('exitCodes')?.failedFlagValidation ?? exit, message, parse})
  }
}
````

## File: src/parser/help.ts
````typescript
import {Flag, FlagUsageOptions} from '../interfaces/parser'
import {sortBy} from '../util/util'
import {colorize} from '../ux'

export function flagUsage(flag: Flag<any>, options: FlagUsageOptions = {}): [string, string | undefined] {
  const label = []

  if (flag.helpLabel) {
    label.push(flag.helpLabel)
  } else {
    if (flag.char) label.push(`-${flag.char}`)
    if (flag.name) label.push(` --${flag.name}`)
  }

  const usage = flag.type === 'option' ? ` ${flag.name.toUpperCase()}` : ''

  let description: string | undefined = flag.summary || flag.description || ''
  if (options.displayRequired && flag.required) description = `(required) ${description}`
  description = description ? colorize('dim', description) : undefined

  return [` ${label.join(',').trim()}${usage}`, description] as [string, string | undefined]
}

export function flagUsages(flags: Flag<any>[], options: FlagUsageOptions = {}): [string, string | undefined][] {
  if (flags.length === 0) return []
  return sortBy(flags, (f) => [f.char ? -1 : 1, f.char, f.name]).map((f) => flagUsage(f, options))
}
````

## File: src/parser/index.ts
````typescript
import type {ArgInput, FlagInput, Input, OutputArgs, OutputFlags, ParserOutput} from '../interfaces/parser'

import {Parser} from './parse'
import {validate} from './validate'

export type {ArgInput, FlagInput, Input, OutputArgs, OutputFlags, ParserOutput} from '../interfaces/parser'

export {flagUsages} from './help'
export {validate} from './validate'

export async function parse<
  TFlags extends OutputFlags<any>,
  BFlags extends OutputFlags<any>,
  TArgs extends OutputArgs<any>,
>(argv: string[], options: Input<TFlags, BFlags, TArgs>): Promise<ParserOutput<TFlags, BFlags, TArgs>> {
  const input = {
    '--': options['--'],
    args: (options.args ?? {}) as ArgInput<any>,
    argv,
    context: options.context,
    flags: (options.flags ?? {}) as FlagInput<any>,
    strict: options.strict !== false,
  }
  const parser = new Parser(input)
  const output = await parser.parse()
  await validate({input, output})
  return output as ParserOutput<TFlags, BFlags, TArgs>
}
````

## File: src/parser/parse.ts
````typescript
/* eslint-disable no-await-in-loop */
import {createInterface} from 'node:readline'

import Cache from '../cache'
import {
  ArgParserContext,
  ArgToken,
  BooleanFlag,
  Flag,
  FlagParserContext,
  FlagToken,
  Metadata,
  MetadataFlag,
  OptionFlag,
  OutputArgs,
  OutputFlags,
  ParserContext,
  ParserInput,
  ParserOutput,
  ParsingToken,
} from '../interfaces/parser'
import {makeDebug} from '../logger'
import {isTruthy, last, pickBy} from '../util/util'
import {ArgInvalidOptionError, CLIError, FlagInvalidOptionError} from './errors'

let debug: any
try {
  debug =
    process.env.CLI_FLAGS_DEBUG === '1'
      ? makeDebug('parser')
      : () => {
          // noop
        }
} catch {
  debug = () => {
    // noop
  }
}

declare global {
  /**
   * Cache the stdin so that it can be read multiple times.
   *
   * This fixes a bug where the stdin would be read multiple times (because Parser.parse() was called more than once)
   * but only the first read would be successful - all other reads would return null.
   *
   * Storing in global is necessary because we want the cache to be shared across all versions of @oclif/core in
   * in the dependency tree. Storing in a variable would only share the cache within the same version of @oclif/core.
   */

  var oclif: {stdinCache?: string}
}

export const readStdin = async (): Promise<null | string> => {
  const {stdin, stdout} = process

  // process.stdin.isTTY is true whenever it's running in a terminal.
  // process.stdin.isTTY is undefined when it's running in a pipe, e.g. echo 'foo' | my-cli command
  // process.stdin.isTTY is undefined when it's running in a spawned process, even if there's no pipe.
  // This means that reading from stdin could hang indefinitely while waiting for a non-existent pipe.
  // Because of this, we have to set a timeout to prevent the process from hanging.

  if (stdin.isTTY) return null

  if (globalThis.oclif?.stdinCache) {
    debug('resolved stdin from global cache', globalThis.oclif.stdinCache)
    return globalThis.oclif.stdinCache
  }

  return new Promise((resolve) => {
    let result = ''
    const ac = new AbortController()
    const {signal} = ac
    const timeout = setTimeout(() => ac.abort(), 10)

    const rl = createInterface({
      input: stdin,
      output: stdout,
      terminal: false,
    })

    rl.on('line', (line) => {
      result += line
    })

    rl.once('close', () => {
      clearTimeout(timeout)
      debug('resolved from stdin', result)
      globalThis.oclif = {...globalThis.oclif, stdinCache: result}
      resolve(result)
    })

    signal.addEventListener(
      'abort',
      () => {
        debug('stdin aborted')
        clearTimeout(timeout)
        rl.close()
        resolve(null)
      },
      {once: true},
    )
  })
}

function isNegativeNumber(input: string): boolean {
  return /^-\d/g.test(input)
}

const validateOptions = (flag: OptionFlag<any>, input: string): string => {
  if (flag.options && !flag.options.includes(input)) throw new FlagInvalidOptionError(flag, input)
  return input
}

export class Parser<
  T extends ParserInput,
  TFlags extends OutputFlags<T['flags']>,
  BFlags extends OutputFlags<T['flags']>,
  TArgs extends OutputArgs<T['args']>,
> {
  private readonly argv: string[]
  private readonly booleanFlags: {[k: string]: BooleanFlag<any>}
  private readonly context: ParserContext
  private currentFlag?: OptionFlag<any>
  private readonly flagAliases: {[k: string]: BooleanFlag<any> | OptionFlag<any>}
  private readonly raw: ParsingToken[] = []

  constructor(private readonly input: T) {
    this.context = input.context ?? ({} as ParserContext)
    this.argv = [...input.argv]
    this._setNames()
    this.booleanFlags = pickBy(input.flags, (f) => f.type === 'boolean') as any
    this.flagAliases = Object.fromEntries(
      Object.values(input.flags).flatMap((flag) =>
        [...(flag.aliases ?? []), ...(flag.charAliases ?? [])].map((a) => [a, flag]),
      ),
    )
  }

  private get _argTokens(): ArgToken[] {
    return this.raw.filter((o) => o.type === 'arg') as ArgToken[]
  }

  public async parse(): Promise<ParserOutput<TFlags, BFlags, TArgs>> {
    this._debugInput()

    // eslint-disable-next-line complexity
    const parseFlag = async (arg: string): Promise<boolean> => {
      const {isLong, name} = this.findFlag(arg)
      if (!name) {
        const i = arg.indexOf('=')
        if (i !== -1) {
          const sliced = arg.slice(i + 1)
          this.argv.unshift(sliced)

          const equalsParsed = await parseFlag(arg.slice(0, i))
          if (!equalsParsed) {
            this.argv.shift()
          }

          return equalsParsed
        }

        return false
      }

      const flag = this.input.flags[name]

      if (flag.type === 'option') {
        if (!flag.multiple && this.raw.some((o) => o.type === 'flag' && o.flag === name)) {
          throw new CLIError(`Flag --${name} can only be specified once`)
        }

        this.currentFlag = flag
        let input = isLong || arg.length < 3 ? this.argv.shift() : arg.slice(arg[2] === '=' ? 3 : 2)

        if (flag.allowStdin === 'only' && input !== '-' && input !== undefined && !this.findFlag(input).name) {
          throw new CLIError(
            `Flag --${name} can only be read from stdin. The value must be "-" or not provided at all.`,
          )
        }

        if ((flag.allowStdin && input === '-') || flag.allowStdin === 'only') {
          const stdin = await readStdin()
          if (stdin) {
            input = stdin.trim()
          }
        }

        // if the value ends up being one of the command's flags, the user didn't provide an input
        if (typeof input !== 'string' || this.findFlag(input).name) {
          if (flag.options) {
            throw new CLIError(`Flag --${name} expects one of these values: ${flag.options.join(', ')}`)
          }

          throw new CLIError(`Flag --${name} expects a value`)
        }

        this.raw.push({flag: flag.name, input, type: 'flag'})
      } else {
        this.raw.push({flag: flag.name, input: arg, type: 'flag'})
        // push the rest of the short characters back on the stack
        if (!isLong && arg.length > 2) {
          this.argv.unshift(`-${arg.slice(2)}`)
        }
      }

      return true
    }

    let parsingFlags = true
    const nonExistentFlags: string[] = []
    let dashdash = false
    const originalArgv = [...this.argv]

    while (this.argv.length > 0) {
      const input = this.argv.shift() as string
      if (parsingFlags && input.startsWith('-') && input !== '-') {
        // attempt to parse as arg
        if (this.input['--'] !== false && input === '--') {
          parsingFlags = false
          continue
        }

        if (await parseFlag(input)) {
          continue
        }

        if (input === '--') {
          dashdash = true
          continue
        }

        if (this.input['--'] !== false && !isNegativeNumber(input)) {
          // At this point we have a value that begins with '-' or '--'
          // but doesn't match up to a flag definition. So we assume that
          // this is a misspelled flag or a non-existent flag,
          // e.g. --hekp instead of --help
          nonExistentFlags.push(input)
          continue
        }
      }

      if (parsingFlags && this.currentFlag && this.currentFlag.multiple && !this.currentFlag.multipleNonGreedy) {
        this.raw.push({flag: this.currentFlag.name, input, type: 'flag'})
        continue
      }

      // not a flag, parse as arg
      const arg = Object.keys(this.input.args)[this._argTokens.length]
      this.raw.push({arg, input, type: 'arg'})
    }

    const [{args, argv}, {flags, metadata}] = await Promise.all([this._args(), this._flags()])
    this._debugOutput(argv, args, flags)

    const unsortedArgv = (dashdash ? [...argv, ...nonExistentFlags, '--'] : [...argv, ...nonExistentFlags]) as string[]

    return {
      args: args as TArgs,
      argv: unsortedArgv.sort((a, b) => originalArgv.indexOf(a) - originalArgv.indexOf(b)),
      flags,
      metadata,
      nonExistentFlags,
      raw: this.raw,
    }
  }

  private async _args(): Promise<{args: Record<string, unknown>; argv: unknown[]}> {
    const argv: unknown[] = []
    const args = {} as Record<string, unknown>
    const tokens = this._argTokens
    let stdinRead = false
    const ctx = this.context as ArgParserContext

    for (const [name, arg] of Object.entries(this.input.args)) {
      const token = tokens.find((t) => t.arg === name)
      ctx.token = token!

      if (token) {
        if (arg.options && !arg.options.includes(token.input)) {
          throw new ArgInvalidOptionError(arg, token.input)
        }

        const parsed = await arg.parse(token.input, ctx, arg)
        argv.push(parsed)
        args[token.arg] = parsed
      } else if (!arg.ignoreStdin && !stdinRead) {
        let stdin = await readStdin()
        if (stdin) {
          stdin = stdin.trim()
          const parsed = await arg.parse(stdin, ctx, arg)
          argv.push(parsed)
          args[name] = parsed
        }

        stdinRead = true
      }

      if (!args[name] && (arg.default || arg.default === false)) {
        if (typeof arg.default === 'function') {
          const f = await arg.default()
          argv.push(f)
          args[name] = f
        } else {
          argv.push(arg.default)
          args[name] = arg.default
        }
      }
    }

    for (const token of tokens) {
      if (args[token.arg] !== undefined) continue
      argv.push(token.input)
    }

    return {args, argv}
  }

  private _debugInput() {
    debug('input: %s', this.argv.join(' '))
    const args = Object.keys(this.input.args)
    if (args.length > 0) {
      debug('available args: %s', args.join(' '))
    }

    if (Object.keys(this.input.flags).length === 0) return
    debug(
      'available flags: %s',
      Object.keys(this.input.flags)
        .map((f) => `--${f}`)
        .join(' '),
    )
  }

  private _debugOutput(args: any, flags: any, argv: any) {
    if (argv.length > 0) {
      debug('argv: %o', argv)
    }

    if (Object.keys(args).length > 0) {
      debug('args: %o', args)
    }

    if (Object.keys(flags).length > 0) {
      debug('flags: %o', flags)
    }
  }

  private async _flags(): Promise<{
    flags: TFlags & BFlags & {json: boolean | undefined}
    metadata: Metadata
  }> {
    type ValueFunction = (fws: FlagWithStrategy, flags?: Record<string, string>) => Promise<any>

    const parseFlagOrThrowError = async (
      input: any,
      flag: BooleanFlag<any> | OptionFlag<any>,
      context: ParserContext | undefined,
      token?: FlagToken,
    ) => {
      if (!flag.parse) return input

      const ctx = {
        ...context,
        error: context?.error,
        exit: context?.exit,
        jsonEnabled: context?.jsonEnabled,
        log: context?.log,
        logToStderr: context?.logToStderr,
        token,
        warn: context?.warn,
      } as FlagParserContext

      try {
        if (flag.type === 'boolean') {
          return await flag.parse(input, ctx, flag)
        }

        return await flag.parse(input, ctx, flag)
      } catch (error: any) {
        error.message = `Parsing --${flag.name} \n\t${error.message}\nSee more help with --help`
        if (Cache.getInstance().get('exitCodes')?.failedFlagParsing)
          error.oclif = {exit: Cache.getInstance().get('exitCodes')?.failedFlagParsing}
        throw error
      }
    }

    /* Could add a valueFunction (if there is a value/env/default) and could metadata.
     *  Value function can be resolved later.
     */
    const addValueFunction = (fws: FlagWithStrategy): FlagWithStrategy => {
      const tokenLength = fws.tokens?.length
      // user provided some input
      if (tokenLength) {
        // boolean
        if (fws.inputFlag.flag.type === 'boolean' && last(fws.tokens)?.input) {
          return {
            ...fws,
            valueFunction: async (i) =>
              parseFlagOrThrowError(
                last(i.tokens)?.input !== `--no-${i.inputFlag.name}`,
                i.inputFlag.flag,
                this.context,
                last(i.tokens),
              ),
          }
        }

        // multiple with custom delimiter
        if (fws.inputFlag.flag.type === 'option' && fws.inputFlag.flag.delimiter && fws.inputFlag.flag.multiple) {
          // regex that will identify unescaped delimiters
          const makeDelimiter = (delimiter: string) => new RegExp(`(?<!\\\\)${delimiter}`)
          return {
            ...fws,
            valueFunction: async (i) =>
              (
                await Promise.all(
                  (i.tokens ?? [])
                    .flatMap((token) =>
                      token.input.split(makeDelimiter((i.inputFlag.flag as OptionFlag<any>).delimiter ?? ',')),
                    )
                    // trim, and remove surrounding doubleQuotes (which would hav been needed if the elements contain spaces)
                    .map((v) =>
                      v
                        .trim()
                        // remove escaped characters from delimiter
                        // example: --opt="a\,b,c" -> ["a,b", "c"]
                        .replaceAll(
                          new RegExp(`\\\\${(i.inputFlag.flag as OptionFlag<any>).delimiter}`, 'g'),
                          (i.inputFlag.flag as OptionFlag<any>).delimiter ?? ',',
                        )
                        .replace(/^"(.*)"$/, '$1')
                        .replace(/^'(.*)'$/, '$1'),
                    )
                    .map(async (v) =>
                      parseFlagOrThrowError(v, i.inputFlag.flag, this.context, {
                        ...(last(i.tokens) as FlagToken),
                        input: v,
                      }),
                    ),
                )
              ).map((v) => validateOptions(i.inputFlag.flag as OptionFlag<any>, v)),
          }
        }

        // multiple in the oclif-core style
        if (fws.inputFlag.flag.type === 'option' && fws.inputFlag.flag.multiple) {
          return {
            ...fws,
            valueFunction: async (i: FlagWithStrategy) =>
              Promise.all(
                (fws.tokens ?? []).map((token) =>
                  parseFlagOrThrowError(
                    validateOptions(i.inputFlag.flag as OptionFlag<any>, token.input as string),
                    i.inputFlag.flag,
                    this.context,
                    token,
                  ),
                ),
              ),
          }
        }

        // simple option flag
        if (fws.inputFlag.flag.type === 'option') {
          return {
            ...fws,
            valueFunction: async (i: FlagWithStrategy) =>
              parseFlagOrThrowError(
                validateOptions(i.inputFlag.flag as OptionFlag<any>, last(fws.tokens)?.input as string),
                i.inputFlag.flag,
                this.context,
                last(fws.tokens),
              ),
          }
        }
      }

      // no input: env flags
      if (fws.inputFlag.flag.env && process.env[fws.inputFlag.flag.env]) {
        const valueFromEnv = process.env[fws.inputFlag.flag.env]
        if (fws.inputFlag.flag.type === 'option' && valueFromEnv) {
          return {
            ...fws,
            valueFunction: async (i: FlagWithStrategy) =>
              parseFlagOrThrowError(
                validateOptions(i.inputFlag.flag as OptionFlag<any>, valueFromEnv),
                i.inputFlag.flag,
                this.context,
              ),
          }
        }

        if (fws.inputFlag.flag.type === 'boolean') {
          return {
            ...fws,
            valueFunction: async (i: FlagWithStrategy) =>
              isTruthy(process.env[i.inputFlag.flag.env as string] ?? 'false'),
          }
        }
      }

      // no input, but flag has default value
      // eslint-disable-next-line no-constant-binary-expression, valid-typeof
      if (typeof fws.inputFlag.flag.default !== undefined) {
        return {
          ...fws,
          metadata: {setFromDefault: true},
          valueFunction:
            typeof fws.inputFlag.flag.default === 'function'
              ? (i: FlagWithStrategy, allFlags = {}) =>
                  fws.inputFlag.flag.default({flags: allFlags, options: i.inputFlag.flag})
              : async () => fws.inputFlag.flag.default,
        }
      }

      // base case (no value function)
      return fws
    }

    const addHelpFunction = (fws: FlagWithStrategy): FlagWithStrategy => {
      if (fws.inputFlag.flag.type === 'option' && fws.inputFlag.flag.defaultHelp) {
        return {
          ...fws,
          helpFunction:
            typeof fws.inputFlag.flag.defaultHelp === 'function'
              ? (i: FlagWithStrategy, flags: Record<string, string>, ...context) =>
                  // @ts-expect-error flag type isn't specific enough to know defaultHelp will definitely be there
                  i.inputFlag.flag.defaultHelp({flags, options: i.inputFlag}, ...context)
              : // @ts-expect-error flag type isn't specific enough to know defaultHelp will definitely be there
                (i: FlagWithStrategy) => i.inputFlag.flag.defaultHelp,
        }
      }

      return fws
    }

    const addDefaultHelp = async (fwsArray: FlagWithStrategy[]): Promise<FlagWithStrategy[]> => {
      const valueReferenceForHelp = fwsArrayToObject(flagsWithAllValues.filter((fws) => !fws.metadata?.setFromDefault))
      return Promise.all(
        fwsArray.map(async (fws) => {
          try {
            if (fws.helpFunction) {
              return {
                ...fws,
                metadata: {
                  ...fws.metadata,
                  defaultHelp: await fws.helpFunction?.(fws, valueReferenceForHelp, this.context),
                },
              }
            }
          } catch {
            // no-op
          }

          return fws
        }),
      )
    }

    const fwsArrayToObject = (fwsArray: FlagWithStrategy[]) =>
      Object.fromEntries(
        fwsArray.filter((fws) => fws.value !== undefined).map((fws) => [fws.inputFlag.name, fws.value]),
      ) as TFlags & BFlags & {json: boolean | undefined}

    type FlagWithStrategy = {
      helpFunction?: (
        fws: FlagWithStrategy,
        flags: Record<string, string>,
        ...args: any
      ) => Promise<string | undefined> | undefined
      inputFlag: {
        flag: Flag<any>
        name: string
      }
      metadata?: MetadataFlag | undefined
      tokens?: FlagToken[] | undefined
      value?: any | undefined
      valueFunction?: ValueFunction | undefined
    }

    const flagTokenMap = this.mapAndValidateFlags()
    const flagsWithValues = await Promise.all(
      Object.entries(this.input.flags)
        // we check them if they have a token, or might have env, default, or defaultHelp.  Also include booleans so they get their default value
        .filter(
          ([name, flag]) =>
            flag.type === 'boolean' ||
            flag.env ||
            flag.default !== undefined ||
            'defaultHelp' in flag ||
            flagTokenMap.has(name),
        )
        // match each possible flag to its token, if there is one
        .map(([name, flag]): FlagWithStrategy => ({inputFlag: {flag, name}, tokens: flagTokenMap.get(name)}))
        .map((fws) => addValueFunction(fws))
        .filter((fws) => fws.valueFunction !== undefined)
        .map((fws) => addHelpFunction(fws))
        // we can't apply the default values until all the other flags are resolved because `flag.default` can reference other flags
        .map(async (fws) => (fws.metadata?.setFromDefault ? fws : {...fws, value: await fws.valueFunction?.(fws)})),
    )

    const valueReference = fwsArrayToObject(flagsWithValues.filter((fws) => !fws.metadata?.setFromDefault))

    const flagsWithAllValues = await Promise.all(
      flagsWithValues.map(async (fws) =>
        fws.metadata?.setFromDefault ? {...fws, value: await fws.valueFunction?.(fws, valueReference)} : fws,
      ),
    )

    const finalFlags = flagsWithAllValues.some((fws) => typeof fws.helpFunction === 'function')
      ? await addDefaultHelp(flagsWithAllValues)
      : flagsWithAllValues

    return {
      flags: fwsArrayToObject(finalFlags),
      metadata: {
        flags: Object.fromEntries(
          finalFlags.filter((fws) => fws.metadata).map((fws) => [fws.inputFlag.name, fws.metadata as MetadataFlag]),
        ),
      },
    }
  }

  private _setNames() {
    for (const k of Object.keys(this.input.flags)) {
      this.input.flags[k].name = k
    }

    for (const k of Object.keys(this.input.args)) {
      this.input.args[k].name = k
    }
  }

  private findFlag(arg: string): {isLong: boolean; name?: string | undefined} {
    const isLong = arg.startsWith('--')
    const short = isLong ? false : arg.startsWith('-')
    const name = isLong ? this.findLongFlag(arg) : short ? this.findShortFlag(arg) : undefined
    return {isLong, name}
  }

  private findLongFlag(arg: string): string | undefined {
    const name = arg.slice(2)
    if (this.input.flags[name]) {
      return name
    }

    if (this.flagAliases[name]) {
      return this.flagAliases[name].name
    }

    if (arg.startsWith('--no-')) {
      const flag = this.booleanFlags[arg.slice(5)]
      if (flag && flag.allowNo) return flag.name
    }
  }

  private findShortFlag([_, char]: string): string | undefined {
    if (this.flagAliases[char]) {
      return this.flagAliases[char].name
    }

    return Object.keys(this.input.flags).find(
      (k) => this.input.flags[k].char === char && char !== undefined && this.input.flags[k].char !== undefined,
    )
  }

  private mapAndValidateFlags(): Map<string, FlagToken[]> {
    const flagTokenMap = new Map<string, FlagToken[]>()
    for (const token of this.raw.filter((o) => o.type === 'flag') as FlagToken[]) {
      // fail fast if there are any invalid flags
      if (!(token.flag in this.input.flags)) {
        throw new CLIError(`Unexpected flag ${token.flag}`)
      }

      const existing = flagTokenMap.get(token.flag) ?? []
      flagTokenMap.set(token.flag, [...existing, token])
    }

    return flagTokenMap
  }
}
````

## File: src/parser/validate.ts
````typescript
import {Arg, Flag, FlagRelationship, ParserInput, ParserOutput} from '../interfaces/parser'
import {uniq} from '../util/util'
import {
  FailedFlagValidationError,
  InvalidArgsSpecError,
  NonExistentFlagsError,
  RequiredArgsError,
  UnexpectedArgsError,
  Validation,
} from './errors'

export async function validate(parse: {input: ParserInput; output: ParserOutput}): Promise<void> {
  let cachedResolvedFlags: Record<string, unknown> | undefined

  function validateArgs() {
    if (parse.output.nonExistentFlags?.length > 0) {
      throw new NonExistentFlagsError({
        flags: parse.output.nonExistentFlags,
        parse,
      })
    }

    const maxArgs = Object.keys(parse.input.args).length
    if (parse.input.strict && parse.output.argv.length > maxArgs) {
      const extras = parse.output.argv.slice(maxArgs)
      throw new UnexpectedArgsError({
        args: extras,
        parse,
      })
    }

    const missingRequiredArgs: Arg<any>[] = []
    let hasOptional = false

    for (const [name, arg] of Object.entries(parse.input.args)) {
      if (!arg.required) {
        hasOptional = true
      } else if (hasOptional) {
        // (required arg) check whether an optional has occurred before
        // optionals should follow required, not before
        throw new InvalidArgsSpecError({
          args: parse.input.args,
          parse,
        })
      }

      // Only add if it's required and undefined. Allow falsy values like empty strings and 0.
      if (arg.required && parse.output.args[name] === undefined) {
        missingRequiredArgs.push(arg)
      }
    }

    if (missingRequiredArgs.length > 0) {
      const flagsWithMultiple = Object.entries(parse.input.flags)
        .filter(([_, flagDef]) => flagDef.type === 'option' && Boolean(flagDef.multiple))
        .map(([name]) => name)

      throw new RequiredArgsError({
        args: missingRequiredArgs,
        flagsWithMultiple,
        parse,
      })
    }
  }

  async function validateFlags() {
    const promises = Object.entries(parse.input.flags).flatMap(
      ([name, flag]): Array<Promise<Validation> | Validation> => {
        if (parse.output.flags[name] !== undefined) {
          return [
            ...(flag.relationships ? validateRelationships(name, flag) : []),
            ...(flag.dependsOn ? [validateDependsOn(name, flag.dependsOn)] : []),
            ...(flag.exclusive ? [validateExclusive(name, flag.exclusive)] : []),
            ...(flag.exactlyOne ? [validateExactlyOne(name, flag.exactlyOne)] : []),
          ]
        }

        if (flag.required) {
          return [{name, reason: `Missing required flag ${name}`, status: 'failed', validationFn: 'required'}]
        }

        if (flag.exactlyOne && flag.exactlyOne.length > 0) {
          return [validateExactlyOneAcrossFlags(flag)]
        }

        if (flag.atLeastOne && flag.atLeastOne.length > 0) {
          return [validateAtLeastOneAcrossFlags(flag)]
        }

        return []
      },
    )

    const results = await Promise.all(promises)

    const failed = results.filter((r) => r.status === 'failed')
    if (failed.length > 0)
      throw new FailedFlagValidationError({
        failed,
        parse,
      })
  }

  async function resolveFlags(flags: FlagRelationship[]): Promise<Record<string, unknown>> {
    if (cachedResolvedFlags) return cachedResolvedFlags
    const promises = flags.map(async (flag) => {
      if (typeof flag === 'string') {
        return [flag, parse.output.flags[flag]]
      }

      const result = await flag.when(parse.output.flags)
      return result ? [flag.name, parse.output.flags[flag.name]] : null
    })
    const resolved = await Promise.all(promises)
    cachedResolvedFlags = Object.fromEntries(resolved.filter((r) => r !== null) as [string, unknown][])
    return cachedResolvedFlags
  }

  const getPresentFlags = (flags: Record<string, unknown>): string[] =>
    Object.keys(flags).filter((key) => key !== undefined)

  function validateExactlyOneAcrossFlags(flag: Flag<any>): Validation {
    const base = {name: flag.name, validationFn: 'validateExactlyOneAcrossFlags'}
    const intersection = Object.entries(parse.input.flags)
      .map((entry) => entry[0]) // array of flag names
      .filter((flagName) => parse.output.flags[flagName] !== undefined) // with values
      .filter((flagName) => flag.exactlyOne && flag.exactlyOne.includes(flagName)) // and in the exactlyOne list
    if (intersection.length === 0) {
      // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe
      const deduped = uniq(flag.exactlyOne?.map((flag) => `--${flag}`) ?? []).join(', ')
      const reason = `Exactly one of the following must be provided: ${deduped}`
      return {...base, reason, status: 'failed'}
    }

    return {...base, status: 'success'}
  }

  function validateAtLeastOneAcrossFlags(flag: Flag<any>): Validation {
    const base = {name: flag.name, validationFn: 'validateAtLeastOneAcrossFlags'}
    const intersection = Object.entries(parse.input.flags)
      .map((entry) => entry[0]) // array of flag names
      .filter((flagName) => parse.output.flags[flagName] !== undefined) // with values
      .filter((flagName) => flag.atLeastOne && flag.atLeastOne.includes(flagName)) // and in the atLeastOne list
    if (intersection.length === 0) {
      // the command's atLeastOne may or may not include itself, so we'll use Set to add + de-dupe
      const deduped = uniq(flag.atLeastOne?.map((flag) => `--${flag}`) ?? []).join(', ')
      const reason = `At least one of the following must be provided: ${deduped}`
      return {...base, reason, status: 'failed'}
    }

    return {...base, status: 'success'}
  }

  async function validateExclusive(name: string, flags: FlagRelationship[]): Promise<Validation> {
    const base = {name, validationFn: 'validateExclusive'}
    const resolved = await resolveFlags(flags)
    const keys = getPresentFlags(resolved)
    for (const flag of keys) {
      // do not enforce exclusivity for flags that were defaulted
      if (parse.output.metadata.flags && parse.output.metadata.flags[flag]?.setFromDefault) continue
      if (parse.output.metadata.flags && parse.output.metadata.flags[name]?.setFromDefault) continue
      if (parse.output.flags[flag] !== undefined) {
        const flagValue = parse.output.metadata.flags?.[flag]?.defaultHelp ?? parse.output.flags[flag]
        return {
          ...base,
          reason: `--${flag}=${flagValue} cannot also be provided when using --${name}`,
          status: 'failed',
        }
      }
    }

    return {...base, status: 'success'}
  }

  async function validateExactlyOne(name: string, flags: FlagRelationship[]): Promise<Validation> {
    const base = {name, validationFn: 'validateExactlyOne'}

    const resolved = await resolveFlags(flags)
    const keys = getPresentFlags(resolved)
    for (const flag of keys) {
      if (flag !== name && parse.output.flags[flag] !== undefined) {
        return {...base, reason: `--${flag} cannot also be provided when using --${name}`, status: 'failed'}
      }
    }

    return {...base, status: 'success'}
  }

  async function validateDependsOn(name: string, flags: FlagRelationship[]): Promise<Validation> {
    const base = {name, validationFn: 'validateDependsOn'}
    const resolved = await resolveFlags(flags)

    const foundAll = Object.values(resolved).every((val) => val !== undefined)
    if (!foundAll) {
      const formattedFlags = Object.keys(resolved)
        .map((f) => `--${f}`)
        .join(', ')
      return {
        ...base,
        reason: `All of the following must be provided when using --${name}: ${formattedFlags}`,
        status: 'failed',
      }
    }

    return {...base, status: 'success'}
  }

  async function validateSome(name: string, flags: FlagRelationship[]): Promise<Validation> {
    const base = {name, validationFn: 'validateSome'}

    const resolved = await resolveFlags(flags)
    const foundAtLeastOne = Object.values(resolved).some(Boolean)
    if (!foundAtLeastOne) {
      const formattedFlags = Object.keys(resolved)
        .map((f) => `--${f}`)
        .join(', ')
      return {
        ...base,
        reason: `One of the following must be provided when using --${name}: ${formattedFlags}`,
        status: 'failed',
      }
    }

    return {...base, status: 'success'}
  }

  function validateRelationships(name: string, flag: Flag<any>): Promise<Validation>[] {
    return (flag.relationships ?? []).map((relationship) => {
      switch (relationship.type) {
        case 'all': {
          return validateDependsOn(name, relationship.flags)
        }

        case 'none': {
          return validateExclusive(name, relationship.flags)
        }

        case 'some': {
          return validateSome(name, relationship.flags)
        }

        default: {
          throw new Error(`Unknown relationship type: ${relationship.type}`)
        }
      }
    })
  }

  validateArgs()
  return validateFlags()
}
````

## File: src/util/aggregate-flags.ts
````typescript
import {boolean} from '../flags'
import {FlagInput, FlagOutput} from '../interfaces/parser'

const json = boolean({
  description: 'Format output as json.',
  helpGroup: 'GLOBAL',
})

export function aggregateFlags<F extends FlagOutput, B extends FlagOutput>(
  flags: FlagInput<F> | undefined,
  baseFlags: FlagInput<B> | undefined,
  enableJsonFlag: boolean | undefined,
): FlagInput<F> {
  const combinedFlags = {...baseFlags, ...flags}
  return (enableJsonFlag ? {json, ...combinedFlags} : combinedFlags) as FlagInput<F>
}
````

## File: src/util/cache-command.ts
````typescript
import {Command} from '../command'
import {ArgInput, FlagInput} from '../interfaces/parser'
import {Plugin as IPlugin} from '../interfaces/plugin'
import {aggregateFlags} from './aggregate-flags'
import {cacheDefaultValue} from './cache-default-value'
import {ensureArgObject} from './ensure-arg-object'
import {pickBy} from './util'

// In order to collect static properties up the inheritance chain, we need to recursively
// access the prototypes until there's nothing left. This allows us to combine baseFlags
// and flags as well as add in the json flag if enableJsonFlag is enabled.
function mergePrototype(result: Command.Class, cmd: Command.Class): Command.Class {
  const proto = Object.getPrototypeOf(cmd)
  const filteredProto = pickBy(proto, (v) => v !== undefined) as Command.Class
  return Object.keys(proto).length > 0 ? mergePrototype({...filteredProto, ...result} as Command.Class, proto) : result
}

async function cacheFlags(
  cmdFlags: FlagInput<any>,
  respectNoCacheDefault: boolean,
): Promise<Record<string, Command.Flag.Cached>> {
  const promises = Object.entries(cmdFlags).map(async ([name, flag]) => [
    name,
    {
      aliases: flag.aliases,
      char: flag.char,
      charAliases: flag.charAliases,
      dependsOn: flag.dependsOn,
      deprecateAliases: flag.deprecateAliases,
      deprecated: flag.deprecated,
      description: flag.description,
      env: flag.env,
      exclusive: flag.exclusive,
      helpGroup: flag.helpGroup,
      helpLabel: flag.helpLabel,
      hidden: flag.hidden,
      name,
      noCacheDefault: flag.noCacheDefault,
      relationships: flag.relationships,
      required: flag.required,
      summary: flag.summary,
      ...(flag.type === 'boolean'
        ? {
            allowNo: flag.allowNo,
            type: flag.type,
          }
        : {
            default: await cacheDefaultValue(flag, respectNoCacheDefault),
            delimiter: flag.delimiter,
            hasDynamicHelp: typeof flag.defaultHelp === 'function',
            helpValue: flag.helpValue,
            multiple: flag.multiple,
            options: flag.options,
            type: flag.type,
          }),
    },
  ])
  return Object.fromEntries(await Promise.all(promises))
}

async function cacheArgs(
  cmdArgs: ArgInput<any>,
  respectNoCacheDefault: boolean,
): Promise<Record<string, Command.Arg.Cached>> {
  const promises = Object.entries(cmdArgs).map(async ([name, arg]) => [
    name,
    {
      default: await cacheDefaultValue(arg, respectNoCacheDefault),
      description: arg.description,
      hidden: arg.hidden,
      name,
      noCacheDefault: arg.noCacheDefault,
      options: arg.options,
      required: arg.required,
    },
  ])
  return Object.fromEntries(await Promise.all(promises))
}

export async function cacheCommand(
  uncachedCmd: Command.Class,
  plugin?: IPlugin,
  respectNoCacheDefault = false,
): Promise<Command.Cached> {
  const cmd = mergePrototype(uncachedCmd, uncachedCmd)

  // @ts-expect-error because v2 commands have flags stored in _flags
  const uncachedFlags = cmd.flags ?? cmd._flags
  // @ts-expect-error because v2 commands have base flags stored in _baseFlags
  const uncachedBaseFlags = cmd.baseFlags ?? cmd._baseFlags

  const [flags, args] = await Promise.all([
    cacheFlags(aggregateFlags(uncachedFlags, uncachedBaseFlags, cmd.enableJsonFlag), respectNoCacheDefault),
    cacheArgs(ensureArgObject(cmd.args), respectNoCacheDefault),
  ])

  const stdProperties = {
    aliases: cmd.aliases ?? [],
    args,
    deprecateAliases: cmd.deprecateAliases,
    deprecationOptions: cmd.deprecationOptions,
    description: cmd.description,
    // Support both `examples` and `example` for backwards compatibility.
    examples: cmd.examples ?? (cmd as unknown as {example: string}).example,
    flags,
    hasDynamicHelp: Object.values(flags).some((f) => f.hasDynamicHelp),
    hidden: cmd.hidden,
    hiddenAliases: cmd.hiddenAliases ?? [],
    id: cmd.id,
    pluginAlias: plugin && plugin.alias,
    pluginName: plugin && plugin.name,
    pluginType: plugin && plugin.type,
    state: cmd.state,
    strict: cmd.strict,
    summary: cmd.summary,
    usage: cmd.usage,
  }

  // do not include these properties in manifest
  const ignoreCommandProperties = [
    'plugin',
    '_flags',
    '_enableJsonFlag',
    '_globalFlags',
    '_baseFlags',
    'baseFlags',
    '_--',
    '_base',
  ]

  // Add in any additional properties that are not standard command properties.
  const stdKeysAndIgnored = new Set([...ignoreCommandProperties, ...Object.keys(stdProperties)])
  const keysToAdd = Object.keys(cmd).filter((property) => !stdKeysAndIgnored.has(property))
  const additionalProperties = Object.fromEntries(keysToAdd.map((key) => [key, (cmd as any)[key]]))

  return {...stdProperties, ...additionalProperties}
}
````

## File: src/util/cache-default-value.ts
````typescript
import {Arg, OptionFlag} from '../interfaces/parser'

// when no manifest exists, the default is calculated.  This may throw, so we need to catch it
export const cacheDefaultValue = async (flagOrArg: Arg<any> | OptionFlag<any>, respectNoCacheDefault: boolean) => {
  if (respectNoCacheDefault && flagOrArg.noCacheDefault) return
  // Prefer the defaultHelp function (returns a friendly string for complex types)
  if (typeof flagOrArg.defaultHelp === 'function') {
    try {
      return await flagOrArg.defaultHelp({flags: {}, options: flagOrArg})
    } catch {
      return
    }
  }

  // if not specified, try the default function
  if (typeof flagOrArg.default === 'function') {
    try {
      return await flagOrArg.default({flags: {}, options: flagOrArg})
    } catch {}
  } else {
    return flagOrArg.default
  }
}
````

## File: src/util/determine-priority.ts
````typescript
import {Command} from '../command'

/**
 * This function is responsible for locating the correct plugin to use for a named command id
 * It searches the {Config} registered commands to match either the raw command id or the command alias
 * It is possible that more than one command will be found. This is due the ability of two distinct plugins to
 * create the same command or command alias.
 *
 * In the case of more than one found command, the function will select the command based on the order in which
 * the plugin is included in the package.json `oclif.plugins` list. The command that occurs first in the list
 * is selected as the command to run.
 *
 * Commands can also be present from either an install or a link. When a command is one of these and a core plugin
 * is present, this function defers to the core plugin.
 *
 * If there is not a core plugin command present, this function will return the first
 * plugin as discovered (will not change the order)
 */
export function determinePriority(plugins: string[], commands: Command.Loadable[]): Command.Loadable {
  const commandPlugins = commands.sort((a, b) => {
    const pluginAliasA = a.pluginAlias ?? 'A-Cannot-Find-This'
    const pluginAliasB = b.pluginAlias ?? 'B-Cannot-Find-This'
    const aIndex = plugins.indexOf(pluginAliasA)
    const bIndex = plugins.indexOf(pluginAliasB)
    // When both plugin types are 'core' plugins sort based on index
    if (a.pluginType === 'core' && b.pluginType === 'core') {
      // If b appears first in the pjson.plugins sort it first
      return aIndex - bIndex
    }

    // if b is a core plugin and a is not sort b first
    if (b.pluginType === 'core' && a.pluginType !== 'core') {
      return 1
    }

    // if a is a core plugin and b is not sort a first
    if (a.pluginType === 'core' && b.pluginType !== 'core') {
      return -1
    }

    // if a is a jit plugin and b is not sort b first
    if (a.pluginType === 'jit' && b.pluginType !== 'jit') {
      return 1
    }

    // if b is a jit plugin and a is not sort a first
    if (b.pluginType === 'jit' && a.pluginType !== 'jit') {
      return -1
    }

    // neither plugin is core, so do not change the order
    return 0
  })
  return commandPlugins[0]
}
````

## File: src/util/ensure-arg-object.ts
````typescript
import {Command} from '../command'
import {ArgInput} from '../interfaces/parser'

/**
 * Ensure that the provided args are an object. This is for backwards compatibility with v1 commands which
 * defined args as an array.
 *
 * @param args Either an array of args or an object of args
 * @returns ArgInput
 */
export function ensureArgObject(args?: {[name: string]: Command.Arg.Cached} | ArgInput | any[]): ArgInput {
  return (
    Array.isArray(args) ? (args ?? []).reduce((x, y) => ({...x, [y.name]: y}), {} as ArgInput) : args ?? {}
  ) as ArgInput
}
````

## File: src/util/find-root.ts
````typescript
/* eslint-disable no-await-in-loop */
import type {getPackageInformation, PackageInformation, PackageLocator} from 'pnpapi'

import {basename, dirname, join} from 'node:path'

import {PJSON} from '../interfaces'
import {getLogger} from '../logger'
import {safeReadJson} from './fs'

export function debug(...scope: string[]): (..._: any) => void {
  return (formatter: unknown, ...args: unknown[]) =>
    getLogger(['find-root', ...scope].join(':')).debug(formatter, ...args)
}

// essentially just "cd .."
function* up(from: string) {
  while (dirname(from) !== from) {
    yield from
    from = dirname(from)
  }

  yield from
}

/**
 * Return the plugin root directory from a given file. This will `cd` up the file system until it finds
 * a package.json and then return the dirname of that path.
 *
 * Example: node_modules/@oclif/plugin-version/dist/index.js -> node_modules/@oclif/plugin-version
 */
async function findPluginRoot(root: string, name?: string) {
  // If we know the plugin name then we just need to traverse the file
  // system until we find the directory that matches the plugin name.
  debug(name ?? 'root-plugin')(`Finding root starting at ${root}`)
  if (name) {
    for (const next of up(root)) {
      if (next.endsWith(basename(name))) {
        debug(name)('Found root based on plugin name!')
        return next
      }
    }
  }

  // If there's no plugin name (typically just the root plugin), then we need
  // to traverse the file system until we find a directory with a package.json
  for (const next of up(root)) {
    // Skip the bin directory
    if (
      basename(dirname(next)) === 'bin' &&
      ['dev', 'dev.cmd', 'dev.js', 'run', 'run.cmd', 'run.js'].includes(basename(next))
    ) {
      continue
    }

    try {
      const cur = join(next, 'package.json')
      debug(name ?? 'root-plugin')(`Checking ${cur}`)
      if (await safeReadJson<PJSON>(cur)) {
        debug(name ?? 'root-plugin')('Found root by traversing up from starting point!')
        return dirname(cur)
      }
    } catch {}
  }
}

/**
 * Find plugin root directory for plugins installed into node_modules that don't have a `main` or `export`.
 * This will go up directories until it finds a directory with the plugin installed into it.
 *
 * See https://github.com/oclif/config/pull/289#issuecomment-983904051
 */
async function findRootLegacy(name: string | undefined, root: string): Promise<string | undefined> {
  debug(name ?? 'root-plugin')('Finding root using legacy method')
  for (const next of up(root)) {
    let cur
    if (name) {
      cur = join(next, 'node_modules', name, 'package.json')
      if (await safeReadJson<PJSON>(cur)) return dirname(cur)

      const pkg = await safeReadJson<PJSON>(join(next, 'package.json'))
      if (pkg?.name === name) return next
    } else {
      cur = join(next, 'package.json')
      if (await safeReadJson<PJSON>(cur)) return dirname(cur)
    }
  }
}

let pnp: {
  getPackageInformation: typeof getPackageInformation
  getLocator: (name: string, reference: string | [string, string]) => PackageLocator
  getDependencyTreeRoots: () => PackageLocator[]
}

/**
 * The pnpapi module is only available if running in a pnp environment. Because of that
 * we have to require it from the plugin.
 *
 * Solution taken from here: https://github.com/yarnpkg/berry/issues/1467#issuecomment-642869600
 */
function maybeRequirePnpApi(root: string): unknown {
  if (pnp) return pnp
  try {
    // eslint-disable-next-line n/no-missing-require
    pnp = require(require.resolve('pnpapi', {paths: [root]}))
    return pnp
  } catch {}
}

const getKey = (locator: PackageLocator | string | [string, string] | undefined) => JSON.stringify(locator)
const isPeerDependency = (
  pkg: PackageInformation | undefined,
  parentPkg: PackageInformation | undefined,
  name: string,
) => getKey(pkg?.packageDependencies.get(name)) === getKey(parentPkg?.packageDependencies.get(name))

/**
 * Traverse PnP dependency tree to find plugin root directory.
 *
 * Implementation adapted from https://yarnpkg.com/advanced/pnpapi#traversing-the-dependency-tree
 */
function findPnpRoot(name: string, root: string): string | undefined {
  maybeRequirePnpApi(root)
  if (!pnp) return

  debug(name)('Finding root for using pnp method')
  const seen = new Set()

  const traverseDependencyTree = (locator: PackageLocator, parentPkg?: PackageInformation): string | undefined => {
    // Prevent infinite recursion when A depends on B which depends on A
    const key = getKey(locator)
    if (seen.has(key)) return

    const pkg = pnp.getPackageInformation(locator)

    if (locator.name === name) {
      return pkg.packageLocation
    }

    seen.add(key)

    for (const [name, referencish] of pkg.packageDependencies) {
      // Unmet peer dependencies
      if (referencish === null) continue

      // Avoid iterating on peer dependencies - very expensive
      if (parentPkg !== null && isPeerDependency(pkg, parentPkg, name)) continue

      const childLocator = pnp.getLocator(name, referencish)
      const foundSomething = traverseDependencyTree(childLocator, pkg)
      if (foundSomething) return foundSomething
    }

    // Important: This `delete` here causes the traversal to go over nodes even
    // if they have already been traversed in another branch. If you don't need
    // that, remove this line for a hefty speed increase.
    seen.delete(key)
  }

  // Iterate on each workspace
  for (const locator of pnp.getDependencyTreeRoots()) {
    const foundSomething = traverseDependencyTree(locator)
    if (foundSomething) return foundSomething
  }
}

/**
 * Returns the root directory of the plugin.
 *
 * It first attempts to use require.resolve to find the plugin root.
 * If that returns a path, it will `cd` up the file system until if finds the package.json for the plugin
 * Example: node_modules/@oclif/plugin-version/dist/index.js -> node_modules/@oclif/plugin-version
 *
 * If require.resolve throws an error, it will attempt to find the plugin root by traversing the file system.
 * If we're in a PnP environment (determined by process.versions.pnp), it will use the pnpapi module to
 * traverse the dependency tree. Otherwise, it will traverse the node_modules until it finds a package.json
 * with a matching name.
 *
 * If no path is found, undefined is returned which will eventually result in a thrown Error from Plugin.
 */
export async function findRoot(name: string | undefined, root: string): Promise<string | undefined> {
  if (name) {
    debug(name)(`Finding root using ${root}`)
    let pkgPath
    try {
      pkgPath = require.resolve(name, {paths: [root]})
      debug(name)(`Found starting point with require.resolve`)
    } catch {
      debug(name)(`require.resolve could not find plugin starting point`)
    }

    if (pkgPath) {
      const found = await findPluginRoot(dirname(pkgPath), name)
      if (found) {
        debug(name)(`Found root at ${found}`)
        return found
      }
    }

    const found = process.versions.pnp ? findPnpRoot(name, root) : await findRootLegacy(name, root)
    debug(name)(found ? `Found root at ${found}` : 'No root found!')
    return found
  }

  debug('root-plugin')(`Finding root plugin using ${root}`)
  const found = await findPluginRoot(root)
  debug('root-plugin')(found ? `Found root at ${found}` : 'No root found!')
  return found
}
````

## File: src/util/fs.ts
````typescript
import {existsSync as fsExistsSync, Stats} from 'node:fs'
import {readFile, stat} from 'node:fs/promises'

import {isProd} from './util'

/**
 * Parser for Args.directory and Flags.directory. Checks that the provided path
 * exists and is a directory.
 * @param input flag or arg input
 * @returns Promise<string>
 */
export const dirExists = async (input: string): Promise<string> => {
  let dirStat: Stats
  try {
    dirStat = await stat(input)
  } catch {
    throw new Error(`No directory found at ${input}`)
  }

  if (!dirStat.isDirectory()) {
    throw new Error(`${input} exists but is not a directory`)
  }

  return input
}

/**
 * Parser for Args.file and Flags.file. Checks that the provided path
 * exists and is a file.
 * @param input flag or arg input
 * @returns Promise<string>
 */
export const fileExists = async (input: string): Promise<string> => {
  let fileStat: Stats
  try {
    fileStat = await stat(input)
  } catch {
    throw new Error(`No file found at ${input}`)
  }

  if (!fileStat.isFile()) {
    throw new Error(`${input} exists but is not a file`)
  }

  return input
}

class ProdOnlyCache extends Map<string, string> {
  set(key: string, value: string): this {
    if (isProd() ?? false) {
      super.set(key, value)
    }

    return this
  }
}

const cache = new ProdOnlyCache()

/**
 * Read a file from disk and cache its contents if in production environment.
 *
 * Will throw an error if the file does not exist.
 *
 * @param path file path of JSON file
 * @param useCache if false, ignore cache and read file from disk
 * @returns <T>
 */
export async function readJson<T = unknown>(path: string, useCache = true): Promise<T> {
  if (useCache && cache.has(path)) {
    return JSON.parse(cache.get(path)!) as T
  }

  const contents = await readFile(path, 'utf8')
  cache.set(path, contents)
  return JSON.parse(contents) as T
}

/**
 * Safely read a file from disk and cache its contents if in production environment.
 *
 * Will return undefined if the file does not exist.
 *
 * @param path file path of JSON file
 * @param useCache if false, ignore cache and read file from disk
 * @returns <T> or undefined
 */
export async function safeReadJson<T>(path: string, useCache = true): Promise<T | undefined> {
  try {
    return await readJson<T>(path, useCache)
  } catch {}
}

export function existsSync(path: string): boolean {
  return fsExistsSync(path)
}
````

## File: src/util/ids.ts
````typescript
import {type Config} from '../interfaces/config'

export function toStandardizedId(commandID: string, config: Config): string {
  return commandID.replaceAll(new RegExp(config.topicSeparator, 'g'), ':')
}

export function toConfiguredId(commandID: string, config: Config): string {
  const defaultTopicSeparator = ':'
  return commandID.replaceAll(new RegExp(defaultTopicSeparator, 'g'), config.topicSeparator || defaultTopicSeparator)
}
````

## File: src/util/os.ts
````typescript
import {homedir, platform} from 'node:os'

/**
 * Call os.homedir() and return the result
 *
 * Wrapping this allows us to stub these in tests since os.homedir() is
 * non-configurable and non-writable.
 *
 * @returns The user's home directory
 */
export function getHomeDir(): string {
  return homedir()
}

/**
 * Call os.platform() and return the result
 *
 * Wrapping this allows us to stub these in tests since os.platform() is
 * non-configurable and non-writable.
 *
 * @returns The process' platform
 */
export function getPlatform(): NodeJS.Platform {
  return platform()
}
````

## File: src/util/read-pjson.ts
````typescript
import {lilconfig} from 'lilconfig'
import {join} from 'node:path'

import {PJSON} from '../interfaces'
import {makeDebug} from '../logger'
import {readJson} from './fs'

const debug = makeDebug('read-pjson')

/**
 * Read the package.json file from a given path and add the oclif config (found by lilconfig) if it exists.
 *
 * We can assume that the package.json file exists because the plugin root has already been loaded at this point.
 */
export async function readPjson(path: string): Promise<PJSON> {
  const pjsonPath = join(path, 'package.json')
  if (process.env.OCLIF_DISABLE_RC) {
    debug('OCLIF_DISABLE_RC is set, skipping rc search')
    return readJson<PJSON>(pjsonPath)
  }

  const pjson = await readJson<PJSON>(pjsonPath)

  // don't bother with lilconfig if the plugin's package.json already has an oclif config
  if (pjson.oclif) {
    debug(`found oclif config in ${pjsonPath}`)
    return pjson
  }

  debug(`searching for oclif config in ${path}`)
  const explorer = lilconfig('oclif', {
    /**
     * Remove the following from the defaults:
     * - package.json
     * - any files under .config/
     */
    searchPlaces: [
      '.oclifrc',
      '.oclifrc.json',
      '.oclifrc.js',
      '.oclifrc.mjs',
      '.oclifrc.cjs',
      'oclif.config.js',
      'oclif.config.mjs',
      'oclif.config.cjs',
    ],
    stopDir: path,
  })
  const result = await explorer.search(path)
  if (!result?.config) {
    debug(`no oclif config found in ${path}`)
    return pjson
  }

  debug(`found oclif config for ${path}: %O`, result)
  return {
    ...pjson,
    oclif: result?.config ?? {},
  }
}
````

## File: src/util/read-tsconfig.ts
````typescript
import {readdir, readFile} from 'node:fs/promises'
import {dirname, join} from 'node:path'

import {memoizedWarn} from '../errors/warn'
import {TSConfig} from '../interfaces'
import {makeDebug} from '../logger'
import {mergeNestedObjects} from './util'

const debug = makeDebug('read-tsconfig')

function resolve(root: string, name: string): string | undefined {
  try {
    return require.resolve(name, {paths: [root]})
  } catch {
    // return undefined
  }
}

async function upUntil(path: string, test: (path: string) => Promise<boolean>): Promise<string | undefined> {
  let result: boolean | undefined
  try {
    result = await test(path)
  } catch {
    result = false
  }

  if (result) return path

  const parent = dirname(path)
  if (parent === path) return

  return upUntil(parent, test)
}

export async function readTSConfig(root: string, tsconfigName = 'tsconfig.json'): Promise<TSConfig | undefined> {
  const found: Record<string, any>[] = []

  let typescript: typeof import('typescript') | undefined
  try {
    typescript = require('typescript')
  } catch {
    try {
      typescript = require(root + '/node_modules/typescript')
    } catch {}
  }

  if (!typescript) {
    memoizedWarn(
      'Could not find typescript. Please ensure that typescript is a devDependency. Falling back to compiled source.',
    )
    return
  }

  const read = async (path: string): Promise<unknown> => {
    const localRoot = await upUntil(path, async (p) => (await readdir(p)).includes('package.json'))
    if (!localRoot) return

    try {
      const contents = await readFile(path, 'utf8')
      const parsed = typescript?.parseConfigFileTextToJson(path, contents).config

      found.push(parsed)

      if (parsed.extends) {
        if (parsed.extends.startsWith('.')) {
          const nextPath = resolve(localRoot, parsed.extends)
          return nextPath ? read(nextPath) : undefined
        }

        const resolved = resolve(localRoot, parsed.extends)
        if (resolved) return read(resolved)
      }

      return parsed
    } catch (error) {
      debug(error)
    }
  }

  await read(join(root, tsconfigName))

  return {
    compilerOptions: mergeNestedObjects(found, 'compilerOptions'),
    'ts-node': mergeNestedObjects(found, 'ts-node'),
  }
}
````

## File: src/util/util.ts
````typescript
export function pickBy<T extends {[s: string]: T[keyof T]} | ArrayLike<T[keyof T]>>(
  obj: T,
  fn: (i: T[keyof T]) => boolean,
): Partial<T> {
  return Object.entries(obj).reduce((o, [k, v]) => {
    if (fn(v)) o[k] = v
    return o
  }, {} as any)
}

export function compact<T>(a: (T | undefined)[]): T[] {
  // eslint-disable-next-line unicorn/prefer-native-coercion-functions
  return a.filter((a): a is T => Boolean(a))
}

export function uniqBy<T>(arr: T[], fn: (cur: T) => any): T[] {
  return arr.filter((a, i) => {
    const aVal = fn(a)
    return !arr.some((b, j) => j > i && fn(b) === aVal)
  })
}

export function last<T>(arr?: T[]): T | undefined {
  if (!arr) return
  return arr.at(-1)
}

type SortTypes = boolean | number | string | undefined

function compare(a: SortTypes | SortTypes[], b: SortTypes | SortTypes[]): number {
  a = a === undefined ? 0 : a
  b = b === undefined ? 0 : b

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length === 0 && b.length === 0) return 0
    const diff = compare(a[0], b[0])
    if (diff !== 0) return diff
    return compare(a.slice(1), b.slice(1))
  }

  if (a < b) return -1
  if (a > b) return 1
  return 0
}

export function sortBy<T>(arr: T[], fn: (i: T) => SortTypes | SortTypes[]): T[] {
  return arr.sort((a, b) => compare(fn(a), fn(b)))
}

export function castArray<T>(input?: T | T[]): T[] {
  if (input === undefined) return []
  return Array.isArray(input) ? input : [input]
}

export function isProd(): boolean {
  return !['development', 'test'].includes(process.env.NODE_ENV ?? '')
}

export function maxBy<T>(arr: T[], fn: (i: T) => number): T | undefined {
  if (arr.length === 0) {
    return undefined
  }

  return arr.reduce((maxItem, i) => {
    const curr = fn(i)
    const max = fn(maxItem)
    return curr > max ? i : maxItem
  })
}

export function sumBy<T>(arr: T[], fn: (i: T) => number): number {
  return arr.reduce((sum, i) => sum + fn(i), 0)
}

export function capitalize(s: string): string {
  return s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : ''
}

export function isTruthy(input: string): boolean {
  return ['1', 'true', 'y', 'yes'].includes(input.toLowerCase())
}

export function isNotFalsy(input: string): boolean {
  return !['0', 'false', 'n', 'no'].includes(input.toLowerCase())
}

export function uniq<T>(arr: T[]): T[] {
  return [...new Set(arr)].sort()
}

export function mapValues<T extends Record<string, any>, TResult>(
  obj: {[P in keyof T]: T[P]},
  fn: (i: T[keyof T], k: keyof T) => TResult,
): {[P in keyof T]: TResult} {
  return Object.entries(obj).reduce((o, [k, v]) => {
    o[k] = fn(v as any, k as any)
    return o
  }, {} as any)
}

function get(obj: Record<string, any>, path: string): unknown {
  return path.split('.').reduce((o, p) => o?.[p], obj)
}

export function mergeNestedObjects(objs: Record<string, any>[], path: string): Record<string, any> {
  return Object.fromEntries(objs.flatMap((o) => Object.entries(get(o, path) ?? {})).reverse())
}
````

## File: src/ux/action/base.ts
````typescript
import {inspect} from 'node:util'

import {castArray} from '../../util/util'
import {Options} from './types'

type Task = {
  action: string
  active: boolean
  status: string | undefined
}

export type ActionType = 'debug' | 'simple' | 'spinner'

export class ActionBase {
  std: 'stderr' | 'stdout' = 'stderr'
  protected stdmocks?: ['stderr' | 'stdout', string[]][]
  type!: ActionType
  private stdmockOrigs = {
    stderr: process.stderr.write,
    stdout: process.stdout.write,
  }

  private get globals(): {action: {task?: Task | undefined}; output: string | undefined} {
    ;(globalThis as any).ux = (globalThis as any).ux || {}
    const globals = (globalThis as any).ux
    globals.action = globals.action || {}
    return globals
  }

  protected get output(): string | undefined {
    return this.globals.output
  }

  protected set output(output: string | undefined) {
    this.globals.output = output
  }

  get running(): boolean {
    return Boolean(this.task)
  }

  get status(): string | undefined {
    return this.task ? this.task.status : undefined
  }

  set status(status: string | undefined) {
    const {task} = this
    if (!task) {
      return
    }

    if (task.status === status) {
      return
    }

    this._updateStatus(status, task.status)
    task.status = status
  }

  public get task(): Task | undefined {
    return this.globals.action.task
  }

  public set task(task: Task | undefined) {
    this.globals.action.task = task
  }

  // flush mocked stdout/stderr
  protected _flushStdout(): void {
    try {
      let output = ''
      let std: 'stderr' | 'stdout' | undefined
      while (this.stdmocks && this.stdmocks.length > 0) {
        const cur = this.stdmocks.shift() as ['stderr' | 'stdout', string[]]
        std = cur[0]
        this._write(std, cur[1])
        output += (cur[1][0] as any).toString('utf8')
      }
      // add newline if there isn't one already
      // otherwise we'll just overwrite it when we render

      if (output && std && output.at(-1) !== '\n') {
        this._write(std, '\n')
      }
    } catch (error) {
      this._write('stderr', inspect(error))
    }
  }

  protected _pause(_?: string): void {
    throw new Error('not implemented')
  }

  protected _resume(): void {
    if (this.task) this.start(this.task.action, this.task.status)
  }

  protected _start(_opts: Options): void {
    throw new Error('not implemented')
  }

  // mock out stdout/stderr so it doesn't screw up the rendering
  protected _stdout(toggle: boolean): void {
    try {
      if (toggle) {
        if (this.stdmocks) return
        this.stdmockOrigs = {
          stderr: process.stderr.write,
          stdout: process.stdout.write,
        }

        this.stdmocks = []
        process.stdout.write = (...args: any[]) => {
          this.stdmocks!.push(['stdout', args] as ['stdout', string[]])
          return true
        }

        process.stderr.write = (...args: any[]) => {
          this.stdmocks!.push(['stderr', args] as ['stderr', string[]])
          return true
        }
      } else {
        if (!this.stdmocks) return
        // this._write('stderr', '\nresetstdmock\n\n\n')
        delete this.stdmocks
        process.stdout.write = this.stdmockOrigs.stdout
        process.stderr.write = this.stdmockOrigs.stderr
      }
    } catch (error) {
      this._write('stderr', inspect(error))
    }
  }

  protected _stop(_: string): void {
    throw new Error('not implemented')
  }

  protected _updateStatus(_: string | undefined, __?: string): void {
    // Not implemented
  }

  // write to the real stdout/stderr
  protected _write(std: 'stderr' | 'stdout', s: string | string[]): void {
    switch (std) {
      case 'stderr': {
        this.stdmockOrigs.stderr.apply(process.stderr, castArray(s) as [string])
        break
      }

      case 'stdout': {
        this.stdmockOrigs.stdout.apply(process.stdout, castArray(s) as [string])
        break
      }

      default: {
        throw new Error(`invalid std: ${std}`)
      }
    }
  }

  public pause(fn: () => any, icon?: string): Promise<any> {
    const {task} = this
    const active = task && task.active
    if (task && active) {
      this._pause(icon)
      this._stdout(false)
      task.active = false
    }

    const ret = fn()
    if (task && active) {
      this._resume()
    }

    return ret
  }

  public async pauseAsync<T>(fn: () => Promise<T>, icon?: string): Promise<T> {
    const {task} = this
    const active = task && task.active
    if (task && active) {
      this._pause(icon)
      this._stdout(false)
      task.active = false
    }

    const ret = await fn()
    if (task && active) {
      this._resume()
    }

    return ret
  }

  public start(action: string, status?: string, opts: Options = {}): void {
    this.std = opts.stdout ? 'stdout' : 'stderr'
    const task = {action, active: Boolean(this.task && this.task.active), status}
    this.task = task

    this._start(opts)
    task.active = true
    this._stdout(true)
  }

  public stop(msg = 'done'): void {
    const {task} = this
    if (!task) {
      return
    }

    this._stop(msg)
    task.active = false
    this.task = undefined
    this._stdout(false)
  }
}
````

## File: src/ux/action/simple.ts
````typescript
import {ActionBase, ActionType} from './base'

export default class SimpleAction extends ActionBase {
  public type: ActionType = 'simple'

  protected _pause(icon?: string): void {
    if (icon) this._updateStatus(icon)
    else this._flush()
  }

  protected _resume(): void {
    // Not implemented
  }

  protected _start(): void {
    if (!this.task) return
    this._render(this.task.action, this.task.status)
  }

  protected _stop(status: string): void {
    if (!this.task) return
    this._updateStatus(status, this.task.status, true)
  }

  protected _updateStatus(status: string, prevStatus?: string, newline = false): void {
    if (!this.task) return
    if (this.task.active && !prevStatus) this._write(this.std, ` ${status}`)
    else this._write(this.std, `${this.task.action}... ${status}`)
    if (newline || !prevStatus) this._flush()
  }

  private _flush() {
    this._write(this.std, '\n')
    this._flushStdout()
  }

  private _render(action: string, status?: string) {
    if (!this.task) return
    if (this.task.active) this._flush()
    this._write(this.std, status ? `${action}... ${status}` : `${action}...`)
  }
}
````

## File: src/ux/action/spinner.ts
````typescript
const ansiEscapes = require('ansi-escapes')
import ansis from 'ansis'
import spinners from 'cli-spinners'

import Cache from '../../cache'
import {errtermwidth} from '../../screen'
import {colorize} from '../theme'
import {ActionBase, ActionType} from './base'
import {Options} from './types'

export default class SpinnerAction extends ActionBase {
  public type: ActionType = 'spinner'
  private color = 'magenta'
  private frameIndex: number
  private frames: string[]
  private spinner?: NodeJS.Timeout

  constructor() {
    super()
    this.frames = this.getFrames()
    this.frameIndex = 0
  }

  protected _frame(): string {
    const frame = this.frames[this.frameIndex]
    this.frameIndex = ++this.frameIndex % this.frames.length
    return this.colorize(frame)
  }

  protected _pause(icon?: string): void {
    if (this.spinner) clearInterval(this.spinner)
    this._reset()
    if (icon) this._render(` ${icon}`)
    this.output = undefined
  }

  protected _start(opts: Options): void {
    this.color = (Cache.getInstance().get('config')?.theme?.spinner as string | undefined) ?? this.color
    if (opts.style) this.frames = this.getFrames(opts)

    this._reset()
    if (this.spinner) clearInterval(this.spinner)
    this._render()
    this.spinner = setInterval(
      (icon) => this._render.bind(this)(icon),
      process.platform === 'win32' ? 500 : 100,
      'spinner',
    )
    const interval = this.spinner
    interval.unref()
  }

  protected _stop(status: string): void {
    if (this.task) this.task.status = status
    if (this.spinner) clearInterval(this.spinner)
    this._render()
    this.output = undefined
  }

  protected colorize(s: string): string {
    return colorize(this.color, s)
  }

  private _lines(s: string): number {
    return (ansis.strip(s).split('\n') as any[])
      .map((l) => Math.ceil(l.length / errtermwidth))
      .reduce((c, i) => c + i, 0)
  }

  private _render(icon?: string) {
    if (!this.task) return
    this._reset()
    this._flushStdout()
    const frame = icon === 'spinner' ? ` ${this._frame()}` : icon || ''
    const status = this.task.status ? ` ${this.task.status}` : ''
    this.output = `${this.task.action}...${frame}${status}\n`

    this._write(this.std, this.output)
  }

  private _reset() {
    if (!this.output) return
    const lines = this._lines(this.output)
    this._write(this.std, ansiEscapes.cursorLeft + ansiEscapes.cursorUp(lines) + ansiEscapes.eraseDown)
    this.output = undefined
  }

  private getFrames(opts?: Options) {
    if (opts?.style) return spinners[opts.style].frames

    return spinners[process.platform === 'win32' ? 'line' : 'dots2'].frames
  }
}
````

## File: src/ux/action/types.ts
````typescript
// Use * as for import to ensure the types are portable
import * as spinners from 'cli-spinners'

export type Options = {
  stdout?: boolean
  style?: spinners.SpinnerName | 'random'
}
````

## File: src/ux/colorize-json.ts
````typescript
import {colorize} from './theme'
const tokenTypes = [
  {regex: /^\s+/, tokenType: 'whitespace'},
  {regex: /^[{}]/, tokenType: 'brace'},
  {regex: /^[[\]]/, tokenType: 'bracket'},
  {regex: /^:/, tokenType: 'colon'},
  {regex: /^,/, tokenType: 'comma'},
  {regex: /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?/i, tokenType: 'number'},
  {regex: /^"(?:\\.|[^"\\])*"(?=\s*:)/, tokenType: 'key'},
  {regex: /^"(?:\\.|[^"\\])*"/, tokenType: 'string'},
  {regex: /^true|^false/, tokenType: 'boolean'},
  {regex: /^null/, tokenType: 'null'},
]

type Options = {
  pretty?: boolean | undefined
  theme?: Record<string, string> | undefined
}

type Replacer = (this: any, key: string, value: any) => any

function stringify(value: any, replacer?: Replacer, spaces?: string | number) {
  return JSON.stringify(value, serializer(replacer, replacer), spaces)
}

// Inspired by https://github.com/moll/json-stringify-safe
function serializer(replacer: Replacer | undefined, cycleReplacer: Replacer | undefined) {
  const stack: any[] = []
  const keys: any[] = []

  if (!cycleReplacer)
    cycleReplacer = function (key, value) {
      if (stack[0] === value) return '[Circular ~]'
      return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'
    }

  return function (key: any, value: any) {
    if (stack.length > 0) {
      // @ts-expect-error because `this` is not typed
      const thisPos = stack.indexOf(this)
      // @ts-expect-error because `this` is not typed
      // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unused-expressions
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unused-expressions
      ~thisPos ? keys.splice(thisPos, Number.POSITIVE_INFINITY, key) : keys.push(key)
      // @ts-expect-error because `this` is not typed
      if (stack.includes(value)) value = cycleReplacer.call(this, key, value)
    } else stack.push(value)

    // @ts-expect-error because `this` is not typed
    return replacer ? replacer.call(this, key, value) : value
  }
}

export function stringifyInput(json?: unknown, options?: Options): string {
  const str = options?.pretty
    ? stringify(typeof json === 'string' ? JSON.parse(json) : json, undefined, 2)
    : typeof json === 'string'
      ? json
      : stringify(json)
  return str
}

export function tokenize(json?: unknown, options?: Options) {
  let input = stringifyInput(json, options)
  const tokens = []
  let foundToken = false

  do {
    for (const tokenType of tokenTypes) {
      const match = tokenType.regex.exec(input)
      if (match) {
        tokens.push({type: tokenType.tokenType, value: match[0]})
        input = input.slice(match[0].length)
        foundToken = true
        break
      }
    }
  } while (hasRemainingTokens(input, foundToken))

  return tokens
}

function hasRemainingTokens(input: string | undefined, foundToken: boolean) {
  return (input?.length ?? 0) > 0 && foundToken
}

/**
 * Add color to JSON.
 *
 * options
 *  pretty: set to true to pretty print the JSON (defaults to true)
 *  theme: theme to use for colorizing. See keys below for available options. All keys are optional and must be valid colors (e.g. hex code, rgb, or standard ansi color).
 *
 * Available theme keys:
 * - brace
 * - bracket
 * - colon
 * - comma
 * - key
 * - string
 * - number
 * - boolean
 * - null
 */
export default function colorizeJson(json: unknown, options?: Options) {
  const opts = {...options, pretty: options?.pretty ?? true}
  return tokenize(json, opts).reduce((acc, token) => acc + colorize(options?.theme?.[token.type], token.value), '')
}
````

## File: src/ux/index.ts
````typescript
import {error} from '../errors/error'
import {exit} from '../errors/exit'
import {warn} from '../errors/warn'
import Simple from './action/simple'
import Spinner from './action/spinner'
import colorizeJson from './colorize-json'
import {colorize} from './theme'
import {stderr, stdout} from './write'

export {error} from '../errors/error'
export {exit} from '../errors/exit'
export {warn} from '../errors/warn'
export {default as colorizeJson} from './colorize-json'
export {colorize} from './theme'
export {stderr, stdout} from './write'

const ACTION_TYPE =
  (Boolean(process.stderr.isTTY) &&
    !process.env.CI &&
    !['dumb', 'emacs-color'].includes(process.env.TERM!) &&
    'spinner') ||
  'simple'

export const action = ACTION_TYPE === 'spinner' ? new Spinner() : new Simple()

export const ux = {
  action,
  /**
   * Add color to text.
   * @param color color to use. Can be hex code (e.g. `#ff0000`), rgb (e.g. `rgb(255, 255, 255)`) or a standard ansi color (e.g. `red`)
   * @param text string to colorize
   * @returns colorized string
   */
  colorize,
  /**
   * Add color to JSON.
   *
   * options
   *  pretty: set to true to pretty print the JSON (defaults to true)
   *  theme: theme to use for colorizing. See keys below for available options. All keys are optional and must be valid colors (e.g. hex code, rgb, or standard ansi color).
   *
   * Available theme keys:
   * - brace
   * - bracket
   * - colon
   * - comma
   * - key
   * - string
   * - number
   * - boolean
   * - null
   */
  colorizeJson,
  /**
   * Throw an error.
   *
   * If `exit` option is `false`, the error will be logged to stderr but not exit the process.
   * If `exit` is set to a number, the process will exit with that code.
   */
  error,
  /**
   * Exit the process with provided exit code (defaults to 0).
   */
  exit,
  /**
   * Log a formatted string to stderr.
   *
   * See node's util.format() for formatting options.
   */
  stderr,
  /**
   * Log a formatted string to stdout.
   *
   * See node's util.format() for formatting options.
   */
  stdout,
  /**
   * Prints a pretty warning message to stderr.
   */
  warn,
}
````

## File: src/ux/list.ts
````typescript
const wordwrap = require('wordwrap')

import {stdtermwidth} from '../screen'
import {maxBy} from '../util/util'

function linewrap(length: number, s: string): string {
  return wordwrap(length, stdtermwidth, {
    skipScheme: 'ansi-color',
  })(s).trim()
}

export type IListItem = [string, string | undefined]
export type IList = IListItem[]
export default function renderList(items: IListItem[]): string {
  if (items.length === 0) {
    return ''
  }

  const maxLength = maxBy(items, (item) => item[0].length)?.[0].length ?? 0
  const lines = items.map((i) => {
    let left = i[0]
    let right = i[1]
    if (!right) {
      return left
    }

    left = left.padEnd(maxLength)
    right = linewrap(maxLength + 2, right)
    return `${left}  ${right}`
  })
  return lines.join('\n')
}
````

## File: src/ux/README.md
````markdown
## UX

The `ux` module provides a small number of tools that will help you create a user experience for your CLI. If you need to create a more complex user experience, we suggest the following libraries:

- For prompts: [inquirer](https://www.npmjs.com/package/inquirer)
- For spinners: [ora](https://www.npmjs.com/package/ora)
- For progress bars: [cli-progress](https://www.npmjs.com/package/cli-progress)
- For tables: [tty-table](https://www.npmjs.com/package/tty-table), [cliui](https://www.npmjs.com/package/cliui)
- For trees: [object-treeify](https://www.npmjs.com/package/object-treeify)
- For colored JSON: [color-json](https://www.npmjs.com/package/color-json)
- For notifications: [node-notifier](https://www.npmjs.com/package/node-notifier)
- For links: [terminal-link](https://www.npmjs.com/package/terminal-link)
- For rendering react components: [ink](https://www.npmjs.com/package/ink)

### `action`

`action` is an abstraction for a spinner that automatically detects if the current environment is a TTY or not.

```typescript
import {action} from '@oclif/core/ux'

action.start('Starting process')
action.status = 'Process still in progress'
action.pauseAsync(async () => {
  // pause spinner while you execute an asynchronous function
})
action.stop()
```

### `colorize`

Add color to text. The provided color can be a hex code, rgb string, or standard ANSI color.

```typescript
import {colorize, stdout} from '@oclif/core/ux'

stdout(colorize('#00FFFF', 'hello world'))
stdout(colorize('rgb(0, 255, 255)', 'hello world'))
stdout(colorize('cyan', 'hello world'))
```

### `colorizeJson`

Add color to JSON. The provided theme can consist of hex codes, rgb strings, or standard ANSI colors.

```typescript
import {colorizeJson, stdout} from '@oclif/core/ux'

const json = {
  number: 5,
  string: 'five',
  null: null,
  array: [1, 2, 3],
  object: {
    number: 5,
    string: 'five',
    null: null,
    array: [1, 2, 3],
  },
}

const theme = {
  brace: '#00FFFF',
  bracket: 'rgb(0, 255, 255)',
  colon: 'dim',
  comma: 'yellow',
  key: 'bold',
  string: 'green',
  number: 'blue',
  boolean: 'cyan',
  null: 'redBright',
}

stdout(colorizeJson(json, {theme}))
stdout(colorizeJson(json, {theme}))
stdout(colorizeJson(json, {theme}))
```

### `error`

Throw a standardized error

```typescript
import {error} from '@oclif/core/ux'

// throw with a string and exit with default code (2)
error('Invalid input')
// throw with an Error and exit with default code (2)
error(new Error('Invalid input'))
// log error to stderr but don't exit
error('Invalid input', {exit: false})
// exit with specific code
error('Invalid input', {exit: 999})
```

### `stderr`

Log a formatted string to stderr

```typescript
import {stderr} from '@oclif/core/ux'

// log "hello world" to stderr
stderr('hello %s', 'world')
```

### `stdout`

Log a formatted string to stdout

```typescript
import {stdout} from '@oclif/core/ux'

// log "hello world" to stdout
stdout('hello %s', 'world')
```

### `warn`

Print a warning message to stderr. Input can be a string or `Error`

```typescript
import {warn} from '@oclif/core/ux'

warn('This is a warning.')
warn(new Error('This is a warning.'))
```
````

## File: src/ux/supports-color.ts
````typescript
import {stderr, stdout} from 'supports-color'

export function supportsColor(): boolean {
  return Boolean(stdout) && Boolean(stderr)
}
````

## File: src/ux/theme.ts
````typescript
import ansis from 'ansis'

import {STANDARD_ANSI, StandardAnsi, Theme} from '../interfaces/theme'
import {supportsColor} from './supports-color'

function isStandardAnsi(color: any): color is StandardAnsi {
  return STANDARD_ANSI.includes(color)
}

/**
 * Add color to text.
 * @param color color to use. Can be hex code (e.g. `#ff0000`), rgb (e.g. `rgb(255, 255, 255)`) or a standard ansi color (e.g. `red`)
 * @param text string to colorize
 * @returns colorized string
 */
export function colorize(color: string | StandardAnsi | undefined, text: string): string {
  if (!color) return text
  if (!supportsColor()) return text
  if (isStandardAnsi(color)) return ansis[color](text)
  if (color.startsWith('#')) return ansis.hex(color)(text)
  if (color.startsWith('rgb')) {
    const [red, green, blue] = color
      .slice(4, -1)
      .split(',')
      .map((c) => Number.parseInt(c.trim(), 10))
    return ansis.rgb(red, green, blue)(text)
  }

  return text
}

export function parseTheme(theme: Record<string, string | Record<string, string>>): Theme {
  return Object.fromEntries(
    Object.entries(theme)
      .map(([key, value]) => [key, typeof value === 'string' ? isValid(value) : parseTheme(value)])
      .filter(([_, value]) => value),
  )
}

function isValid(color: string): string | undefined {
  return color.startsWith('#') || color.startsWith('rgb') || isStandardAnsi(color) ? color : undefined
}
````

## File: src/ux/write.ts
````typescript
import {format} from 'node:util'
export const stdout = (str?: string | string[] | undefined, ...args: string[]): void => {
  if (!str && args) {
    console.log(format(...args))
  } else if (!str) {
    console.log()
  } else if (typeof str === 'string') {
    console.log(format(str, ...args))
  } else {
    console.log(format(...str, ...args))
  }
}

export const stderr = (str?: string | string[] | undefined, ...args: string[]): void => {
  if (!str && args) {
    console.error(format(...args))
  } else if (!str) {
    console.error()
  } else if (typeof str === 'string') {
    console.error(format(str, ...args))
  } else {
    console.error(format(...str, ...args))
  }
}
````

## File: src/args.ts
````typescript
import {URL} from 'node:url'

import {Command} from './command'
import {Arg, ArgDefinition} from './interfaces/parser'
import {dirExists, fileExists} from './util/fs'
import {isNotFalsy} from './util/util'

/**
 * Create a custom arg.
 *
 * @example
 * type Id = string
 * type IdOpts = { startsWith: string; length: number };
 *
 * export const myArg = custom<Id, IdOpts>({
 *   parse: async (input, opts) => {
 *     if (input.startsWith(opts.startsWith) && input.length === opts.length) {
 *       return input
 *     }
 *
 *     throw new Error('Invalid id')
 *   },
 * })
 */
export function custom<T = string, P = Record<string, unknown>>(_defaults: Partial<Arg<T, P>>): ArgDefinition<T, P>
export function custom<T, P = Record<string, unknown>>(defaults: Partial<Arg<T, P>>): ArgDefinition<T, P> {
  return (options: any = {}) => ({
    parse: async (i: string, _context: Command, _opts: P) => i,
    ...defaults,
    ...options,
    input: [] as string[],
    type: 'option',
  })
}

export const boolean = custom<boolean>({
  parse: async (b) => Boolean(b) && isNotFalsy(b),
})

export const integer = custom<number, {max?: number; min?: number}>({
  async parse(input, _, opts) {
    if (!/^-?\d+$/.test(input)) throw new Error(`Expected an integer but received: ${input}`)
    const num = Number.parseInt(input, 10)
    if (opts.min !== undefined && num < opts.min)
      throw new Error(`Expected an integer greater than or equal to ${opts.min} but received: ${input}`)
    if (opts.max !== undefined && num > opts.max)
      throw new Error(`Expected an integer less than or equal to ${opts.max} but received: ${input}`)
    return num
  },
})

export const directory = custom<string, {exists?: boolean}>({
  async parse(input, _, opts) {
    if (opts.exists) return dirExists(input)

    return input
  },
})

export const file = custom<string, {exists?: boolean}>({
  async parse(input, _, opts) {
    if (opts.exists) return fileExists(input)

    return input
  },
})

/**
 * Initializes a string as a URL. Throws an error
 * if the string is not a valid URL.
 */
export const url = custom<URL>({
  async parse(input) {
    try {
      return new URL(input)
    } catch {
      throw new Error(`Expected a valid url but received: ${input}`)
    }
  },
})

const stringArg = custom({})
export {stringArg as string}
````

## File: src/cache.ts
````typescript
import {readFileSync} from 'node:fs'
import {join} from 'node:path'

import {Config} from './config/config'
import {OclifConfiguration, Plugin} from './interfaces'

type CacheContents = {
  rootPlugin: Plugin
  config: Config
  exitCodes: OclifConfiguration['exitCodes']
  '@oclif/core': OclifCoreInfo
}

type OclifCoreInfo = {name: string; version: string}

type ValueOf<T> = T[keyof T]

/**
 * A simple cache for storing values that need to be accessed globally.
 */
export default class Cache extends Map<keyof CacheContents, ValueOf<CacheContents>> {
  static instance: Cache

  public constructor() {
    super()
    this.set('@oclif/core', this.getOclifCoreMeta())
  }

  static getInstance(): Cache {
    if (!Cache.instance) {
      Cache.instance = new Cache()
    }

    return Cache.instance
  }

  public get(_key: 'config'): Config | undefined
  public get(_key: '@oclif/core'): OclifCoreInfo
  public get(_key: 'rootPlugin'): Plugin | undefined
  public get(_key: 'exitCodes'): OclifConfiguration['exitCodes'] | undefined
  public get(key: keyof CacheContents): ValueOf<CacheContents> | undefined {
    return super.get(key)
  }

  private getOclifCoreMeta(): OclifCoreInfo {
    try {
      return {name: '@oclif/core', version: require('@oclif/core/package.json').version}
    } catch {
      try {
        return {
          name: '@oclif/core',
          version: JSON.parse(readFileSync(join(__dirname, '..', 'package.json'), 'utf8')).version,
        }
      } catch {
        return {name: '@oclif/core', version: 'unknown'}
      }
    }
  }
}
````

## File: src/command.ts
````typescript
import {fileURLToPath} from 'node:url'
import {inspect} from 'node:util'

import Cache from './cache'
import {Config} from './config'
import * as Errors from './errors'
import {PrettyPrintableError} from './errors'
import {formatCommandDeprecationWarning, formatFlagDeprecationWarning, normalizeArgv} from './help/util'
import {LoadOptions} from './interfaces/config'
import {CommandError} from './interfaces/errors'
import {
  ArgInput,
  ArgOutput,
  ArgProps,
  BooleanFlagProps,
  Deprecation,
  FlagInput,
  FlagOutput,
  Arg as IArg,
  Flag as IFlag,
  Input,
  OptionFlagProps,
  ParserOutput,
} from './interfaces/parser'
import {Plugin} from './interfaces/plugin'
import {makeDebug} from './logger'
import * as Parser from './parser'
import {aggregateFlags} from './util/aggregate-flags'
import {toConfiguredId} from './util/ids'
import {uniq} from './util/util'
import {ux} from './ux'

const pjson = Cache.getInstance().get('@oclif/core')

/**
 * swallows stdout epipe errors
 * this occurs when stdout closes such as when piping to head
 */
process.stdout.on('error', (err: any) => {
  if (err && err.code === 'EPIPE') return
  throw err
})

/**
 * An abstract class which acts as the base for each command
 * in your project.
 */

export abstract class Command {
  private static readonly _base = `${pjson.name}@${pjson.version}`
  /** An array of aliases for this command. */
  public static aliases: string[] = []
  /** An order-dependent object of arguments for the command */
  public static args: ArgInput = {}
  public static baseFlags: FlagInput
  /**
   * Emit deprecation warning when a command alias is used
   */
  static deprecateAliases?: boolean
  public static deprecationOptions?: Deprecation
  /**
   * A full description of how to use the command.
   *
   * If no summary, the first line of the description will be used as the summary.
   */
  public static description: string | undefined
  public static enableJsonFlag = false
  /**
   * An array of examples to show at the end of the command's help.
   *
   * IF only a string is provided, it will try to look for a line that starts
   * with the cmd.bin as the example command and the rest as the description.
   * If found, the command will be formatted appropriately.
   *
   * ```
   * EXAMPLES:
   *   A description of a particular use case.
   *
   *     $ <%= config.bin => command flags
   * ```
   */
  public static examples: Command.Example[]
  /** A hash of flags for the command */
  public static flags: FlagInput
  public static hasDynamicHelp = false
  public static help: string | undefined
  /** Hide the command from help */
  public static hidden: boolean
  /** An array of aliases for this command that are hidden from help. */
  public static hiddenAliases: string[] = []
  /** A command ID, used mostly in error or verbose reporting. */
  public static id: string
  public static plugin: Plugin | undefined
  public static readonly pluginAlias?: string
  public static readonly pluginName?: string
  public static readonly pluginType?: string
  /** Mark the command as a given state (e.g. beta or deprecated) in help */
  public static state?: 'beta' | 'deprecated' | string
  /** When set to false, allows a variable amount of arguments */
  public static strict = true
  /**
   * The tweet-sized description for your class, used in a parent-commands
   * sub-command listing and as the header for the command help.
   */
  public static summary?: string
  /**
   * An override string (or strings) for the default usage documentation.
   */
  public static usage: string | string[] | undefined
  protected debug: (...args: any[]) => void
  public id: string | undefined

  public constructor(
    public argv: string[],
    public config: Config,
  ) {
    this.id = this.ctor.id
    try {
      this.debug = makeDebug(this.id ? `${this.config.bin}:${this.id}` : this.config.bin)
    } catch {
      this.debug = () => {
        // noop
      }
    }
  }

  /**
   * instantiate and run the command
   *
   * @param {Command.Class} this - the command class
   * @param {string[]} argv argv
   * @param {LoadOptions} opts options
   * @returns {Promise<unknown>} result
   */
  public static async run<T extends Command>(
    this: new (argv: string[], config: Config) => T,
    argv?: string[],
    opts?: LoadOptions,
  ): Promise<ReturnType<T['run']>> {
    if (!argv) argv = process.argv.slice(2)

    // Handle the case when a file URL string is passed in such as 'import.meta.url'; covert to file path.
    if (typeof opts === 'string' && opts.startsWith('file://')) {
      opts = fileURLToPath(opts)
    }

    const config = await Config.load(opts || require.main?.filename || __dirname)
    const cache = Cache.getInstance()
    if (!cache.has('config')) cache.set('config', config)

    const cmd = new this(argv, config)
    if (!cmd.id) {
      const id = cmd.constructor.name.toLowerCase()
      cmd.id = id
      cmd.ctor.id = id
    }

    return cmd._run<ReturnType<T['run']>>()
  }

  protected get ctor(): typeof Command {
    return this.constructor as typeof Command
  }

  protected async _run<T>(): Promise<T> {
    let err: Error | undefined
    let result: T | undefined
    try {
      // remove redirected env var to allow subsessions to run autoupdated client
      this.removeEnvVar('REDIRECTED')
      await this.init()
      result = await this.run()
    } catch (error: any) {
      err = error
      await this.catch(error)
    } finally {
      await this.finally(err)
    }

    if (result && this.jsonEnabled()) this.logJson(this.toSuccessJson(result))

    return result as T
  }

  protected async catch(err: CommandError): Promise<any> {
    process.exitCode = process.exitCode ?? err.exitCode ?? 1
    if (this.jsonEnabled()) {
      this.logJson(this.toErrorJson(err))
    } else {
      if (!err.message) throw err
      try {
        ux.action.stop(ux.colorize('bold', ux.colorize('red', '!')))
      } catch {}

      throw err
    }
  }

  public error(input: Error | string, options: {code?: string; exit: false} & PrettyPrintableError): void

  public error(input: Error | string, options?: {code?: string; exit?: number} & PrettyPrintableError): never

  public error(
    input: Error | string,
    options: {code?: string; exit?: false | number} & PrettyPrintableError = {},
  ): void {
    return Errors.error(input, options as any)
  }

  public exit(code = 0): never {
    Errors.exit(code)
  }

  protected async finally(_: Error | undefined): Promise<any> {}

  protected async init(): Promise<any> {
    this.debug('init version: %s argv: %o', this.ctor._base, this.argv)
    const g: any = globalThis
    g['http-call'] = g['http-call'] || {}
    g['http-call']!.userAgent = this.config.userAgent
    this.warnIfCommandDeprecated()
  }

  /**
   * Determine if the command is being run with the --json flag in a command that supports it.
   *
   * @returns {boolean} true if the command supports json and the --json flag is present
   */
  public jsonEnabled(): boolean {
    // If the command doesn't support json, return false
    if (!this.ctor?.enableJsonFlag) return false

    // If the CONTENT_TYPE env var is set to json, return true
    if (this.config.scopedEnvVar?.('CONTENT_TYPE')?.toLowerCase() === 'json') return true

    const passThroughIndex = this.argv.indexOf('--')
    const jsonIndex = this.argv.indexOf('--json')
    return passThroughIndex === -1
      ? // If '--' is not present, then check for `--json` in this.argv
        jsonIndex !== -1
      : // If '--' is present, return true only the --json flag exists and is before the '--'
        jsonIndex !== -1 && jsonIndex < passThroughIndex
  }

  public log(message = '', ...args: any[]): void {
    if (!this.jsonEnabled()) {
      message = typeof message === 'string' ? message : inspect(message)
      ux.stdout(message, ...args)
    }
  }

  protected logJson(json: unknown): void {
    ux.stdout(ux.colorizeJson(json, {pretty: true, theme: this.config.theme?.json}))
  }

  public logToStderr(message = '', ...args: any[]): void {
    if (!this.jsonEnabled()) {
      message = typeof message === 'string' ? message : inspect(message)
      ux.stderr(message, ...args)
    }
  }

  protected async parse<F extends FlagOutput, B extends FlagOutput, A extends ArgOutput>(
    options?: Input<F, B, A>,
    argv = this.argv,
  ): Promise<ParserOutput<F, B, A>> {
    if (!options) options = this.ctor as Input<F, B, A>

    const opts = {
      context: this,
      ...options,
      flags: aggregateFlags<F, B>(options.flags, options.baseFlags, options.enableJsonFlag),
    }

    const hookResult = await this.config.runHook('preparse', {argv: [...argv], options: opts})

    // Since config.runHook will only run the hook for the root plugin, hookResult.successes will always have a length of 0 or 1
    // But to be extra safe, we find the result that matches the root plugin.
    const argvToParse = hookResult.successes?.length
      ? (hookResult.successes.find((s) => s.plugin.root === Cache.getInstance().get('rootPlugin')?.root)?.result ??
        argv)
      : argv
    this.argv = [...argvToParse]
    const results = await Parser.parse<F, B, A>(argvToParse, opts)
    this.warnIfFlagDeprecated(results.flags ?? {})

    return results
  }

  /**
   * actual command run code goes here
   */
  public abstract run(): Promise<any>

  protected toErrorJson(err: unknown): any {
    return {error: err}
  }

  protected toSuccessJson(result: unknown): any {
    return result
  }

  public warn(input: Error | string): Error | string {
    if (!this.jsonEnabled()) Errors.warn(input)
    return input
  }

  protected warnIfCommandDeprecated(): void {
    const [id] = normalizeArgv(this.config)

    if (this.ctor.deprecateAliases && this.ctor.aliases.includes(id)) {
      const cmdName = toConfiguredId(this.ctor.id, this.config)
      const aliasName = toConfiguredId(id, this.config)
      this.warn(formatCommandDeprecationWarning(aliasName, {to: cmdName}))
    }

    if (this.ctor.state === 'deprecated') {
      const cmdName = toConfiguredId(this.ctor.id, this.config)
      this.warn(formatCommandDeprecationWarning(cmdName, this.ctor.deprecationOptions))
    }
  }

  protected warnIfFlagDeprecated(flags: Record<string, unknown>): void {
    const allFlags = aggregateFlags(this.ctor.flags, this.ctor.baseFlags, this.ctor.enableJsonFlag)
    for (const flag of Object.keys(flags)) {
      const flagDef = allFlags[flag]
      const deprecated = flagDef?.deprecated
      if (deprecated) {
        this.warn(formatFlagDeprecationWarning(flag, deprecated))
      }

      const deprecateAliases = flagDef?.deprecateAliases
      if (deprecateAliases) {
        const aliases = uniq([...(flagDef?.aliases ?? []), ...(flagDef?.charAliases ?? [])]).map((a) =>
          a.length === 1 ? `-${a}` : `--${a}`,
        )
        if (aliases.length === 0) return

        const foundAliases = aliases.filter((alias) => this.argv.includes(alias))
        for (const alias of foundAliases) {
          let preferredUsage = `--${flagDef?.name}`
          if (flagDef?.char) {
            preferredUsage += ` | -${flagDef?.char}`
          }

          this.warn(formatFlagDeprecationWarning(alias, {to: preferredUsage}))
        }
      }
    }
  }

  private removeEnvVar(envVar: string): void {
    const keys: string[] = []
    try {
      keys.push(...this.config.scopedEnvVarKeys(envVar))
    } catch {
      keys.push(this.config.scopedEnvVarKey(envVar))
    }

    keys.map((key) => delete process.env[key])
  }
}

export namespace Command {
  /**
   * The Command class exported by a command file.
   */
  export type Class = typeof Command & {
    id: string
    run(argv?: string[], config?: LoadOptions): Promise<any>
  }

  /**
   * A cached command that's had a `load` method attached to it.
   *
   * The `Plugin` class loads the commands from the manifest (if it exists) or requires and caches
   * the commands directly from the commands directory inside the plugin. At this point the plugin
   * is working with `Command.Cached`. It then appends a `load` method to each one. If the a command
   * is executed then the `load` method is used to require the command class.
   */
  export type Loadable = Cached & {
    load(): Promise<Command.Class>
  }

  /**
   * A cached version of the command. This is created by the cachedCommand utility and
   * stored in the oclif.manifest.json.
   */
  export type Cached = {
    [key: string]: unknown
    aliasPermutations?: string[] | undefined
    aliases: string[]
    args: {[name: string]: Arg.Cached}
    deprecateAliases?: boolean | undefined
    deprecationOptions?: Deprecation | undefined
    description?: string | undefined
    examples?: Example[] | undefined
    flags: {[name: string]: Flag.Cached}
    hasDynamicHelp?: boolean
    hidden: boolean
    hiddenAliases: string[]
    id: string
    isESM?: boolean | undefined
    permutations?: string[] | undefined
    pluginAlias?: string | undefined
    pluginName?: string | undefined
    pluginType?: string | undefined
    relativePath?: string[] | undefined
    state?: 'beta' | 'deprecated' | string | undefined
    strict?: boolean | undefined
    summary?: string | undefined
    type?: string | undefined
    usage?: string | string[] | undefined
  }

  export type Flag = IFlag<any>

  export namespace Flag {
    export type Cached = Omit<Flag, 'input' | 'parse'> &
      (BooleanFlagProps | OptionFlagProps) & {hasDynamicHelp?: boolean | undefined}
    export type Any = Cached | Flag
  }

  export type Arg = IArg<any>

  export namespace Arg {
    export type Cached = Omit<Arg, 'input' | 'parse'> & ArgProps
    export type Any = Arg | Cached
  }

  export type Example =
    | {
        command: string
        description: string
      }
    | string
}
````

## File: src/execute.ts
````typescript
import {CLIError} from './errors'
import {handle} from './errors/handle'
import {flush} from './flush'
import {LoadOptions} from './interfaces'
import {run} from './main'
import {settings} from './settings'

/**
 * Load and run oclif CLI
 *
 * @example For ESM dev.js
 * ```
 * #!/usr/bin/env -S node --loader ts-node/esm --no-warnings=ExperimentalWarning
 * import { execute } from '@oclif/core'
 *
 * await execute({development: true, dir: import.meta.url})
 * ```
 *
 * @example For ESM run.js
 * ```
 * #!/usr/bin/env node
 * import { execute } from '@oclif/core'
 *
 * await execute({dir: import.meta.url})
 * ```
 *
 * @example For CJS dev.js
 * ```
 * #!/usr/bin/env ts-node
 * void (async () => {
 *   const oclif = await import('@oclif/core')
 *   await oclif.execute({development: true, dir: __dirname})
 * })()
 * ```
 *
 * @example For CJS run.js
 * ```
 * #!/usr/bin/env node
 * void (async () => {
 *   const oclif = await import('@oclif/core')
 *   await oclif.execute({dir: __dirname})
 * })()
 * ```
 */
export async function execute(options: {
  args?: string[]
  development?: boolean
  dir?: string
  loadOptions?: LoadOptions
}): Promise<unknown> {
  if (!options.dir && !options.loadOptions) {
    throw new CLIError('dir or loadOptions is required.')
  }

  if (options.development) {
    // In dev mode -> use ts-node and dev plugins
    process.env.NODE_ENV = 'development'
    settings.debug = true
  }

  return run(options.args ?? process.argv.slice(2), options.loadOptions ?? options.dir)
    .then(async (result) => {
      flush()
      return result
    })
    .catch(async (error) => handle(error))
}
````

## File: src/flags.ts
````typescript
import {URL} from 'node:url'

import {CLIError} from './errors'
import {loadHelpClass} from './help'
import {BooleanFlag, CustomOptions, FlagDefinition, OptionFlag} from './interfaces'
import {dirExists, fileExists} from './util/fs'

type NotArray<T> = T extends Array<any> ? never : T
/**
 * Create a custom flag.
 *
 * @example
 * type Id = string
 * type IdOpts = { startsWith: string; length: number }
 *
 * export const myFlag = custom<Id, IdOpts>({
 *   parse: async (input, opts) => {
 *     if (input.startsWith(opts.startsWith) && input.length === opts.length) {
 *       return input
 *     }
 *
 *     throw new Error('Invalid id')
 *   },
 * })
 */
export function custom<T = string, P extends CustomOptions = CustomOptions>(
  defaults: Partial<OptionFlag<T[], P>> & {
    multiple: true
  } & ({default: OptionFlag<T[], P>['default']} | {required: true}),
): FlagDefinition<T, P, {multiple: true; requiredOrDefaulted: true}>

export function custom<T = string, P extends CustomOptions = CustomOptions>(
  defaults: Partial<OptionFlag<NotArray<T>, P>> & {
    multiple?: false | undefined
  } & ({default: OptionFlag<NotArray<T>, P>['default']} | {required: true}),
): FlagDefinition<T, P, {multiple: false; requiredOrDefaulted: true}>

export function custom<T = string, P extends CustomOptions = CustomOptions>(
  defaults: Partial<OptionFlag<NotArray<T>, P>> & {
    default?: OptionFlag<NotArray<T>, P>['default'] | undefined
    multiple?: false | undefined
    required?: false | undefined
  },
): FlagDefinition<T, P, {multiple: false; requiredOrDefaulted: false}>

export function custom<T = string, P extends CustomOptions = CustomOptions>(
  defaults: Partial<OptionFlag<T[], P>> & {
    default?: OptionFlag<T[], P>['default'] | undefined
    multiple: true
    required?: false | undefined
  },
): FlagDefinition<T, P, {multiple: true; requiredOrDefaulted: false}>

export function custom<T = string, P extends CustomOptions = CustomOptions>(): FlagDefinition<
  T,
  P,
  {multiple: false; requiredOrDefaulted: false}
>

export function custom<T = string, P extends CustomOptions = CustomOptions>(
  defaults?: Partial<OptionFlag<T, P>>,
): FlagDefinition<T, P, {multiple: boolean; requiredOrDefaulted: boolean}> {
  return (options: any = {}) => ({
    parse: async (input, _ctx, _opts) => input,
    ...defaults,
    ...options,
    input: [] as string[],
    multiple: Boolean(options.multiple === undefined ? (defaults?.multiple ?? false) : options.multiple),
    type: 'option',
  })
}

/**
 * A boolean flag. Defaults to `false` unless default is set to `true`.
 *
 * - `allowNo` option allows `--no-` prefix to negate boolean flag.
 */
export function boolean<T = boolean>(options: Partial<BooleanFlag<T>> = {}): BooleanFlag<T> {
  return {
    parse: async (b, _) => b,
    ...options,
    allowNo: Boolean(options.allowNo),
    type: 'boolean',
  } as BooleanFlag<T>
}

/**
 * An integer flag. Throws an error if the provided value is not a valid integer.
 *
 * - `min` option allows to set a minimum value.
 * - `max` option allows to set a maximum value.
 */
export const integer = custom<number, {max?: number; min?: number}>({
  async parse(input, _, opts) {
    if (!/^-?\d+$/.test(input)) throw new CLIError(`Expected an integer but received: ${input}`)
    const num = Number.parseInt(input, 10)
    if (opts.min !== undefined && num < opts.min)
      throw new CLIError(`Expected an integer greater than or equal to ${opts.min} but received: ${input}`)
    if (opts.max !== undefined && num > opts.max)
      throw new CLIError(`Expected an integer less than or equal to ${opts.max} but received: ${input}`)
    return num
  },
})

/**
 * A directory flag.
 *
 * - `exists` option allows you to throw an error if the directory does not exist.
 */
export const directory = custom<string, {exists?: boolean}>({
  async parse(input, _, opts) {
    if (opts.exists) return dirExists(input)

    return input
  },
})

/**
 * A file flag.
 *
 * - `exists` option allows you to throw an error if the file does not exist.
 */
export const file = custom<string, {exists?: boolean}>({
  async parse(input, _, opts) {
    if (opts.exists) return fileExists(input)

    return input
  },
})

/**
 * A URL flag that converts the provided value is a string.
 *
 * Throws an error if the string is not a valid URL.
 */
export const url = custom<URL>({
  async parse(input) {
    try {
      return new URL(input)
    } catch {
      throw new CLIError(`Expected a valid url but received: ${input}`)
    }
  },
})

/**
 * A string flag.
 */
export const string = custom()

/**
 * Version flag that will print the CLI version and exit.
 */
export const version = (opts: Partial<BooleanFlag<boolean>> = {}): BooleanFlag<void> =>
  boolean({
    description: 'Show CLI version.',
    ...opts,
    async parse(_, ctx) {
      ctx.log(ctx.config.userAgent)
      ctx.exit(0)
    },
  })

/**
 * A help flag that will print the CLI help and exit.
 */
export const help = (opts: Partial<BooleanFlag<boolean>> = {}): BooleanFlag<void> =>
  boolean({
    description: 'Show CLI help.',
    ...opts,
    async parse(_, cmd) {
      const Help = await loadHelpClass(cmd.config)
      await new Help(cmd.config, cmd.config.pjson.oclif.helpOptions ?? cmd.config.pjson.helpOptions).showHelp(
        cmd.id ? [cmd.id, ...cmd.argv] : cmd.argv,
      )
      cmd.exit(0)
    },
  })

type ReadonlyElementOf<T extends ReadonlyArray<unknown>> = T[number]
/**
 * Create a custom flag that infers the flag type from the provided options.
 *
 * The provided `options` must be a readonly array in order for type inference to work.
 *
 * @example
 * export default class MyCommand extends Command {
 *   static flags = {
 *     name: Flags.option({
 *       options: ['foo', 'bar'] as const,
 *     })(),
 *   }
 * }
 */
export function option<T extends readonly string[], P extends CustomOptions>(
  defaults: Partial<OptionFlag<ReadonlyElementOf<T>[], P>> & {
    multiple: true
    options: T
  } & (
      | {
          default: OptionFlag<ReadonlyElementOf<T>[], P>['default'] | undefined
        }
      | {required: true}
    ),
): FlagDefinition<(typeof defaults.options)[number], P, {multiple: true; requiredOrDefaulted: true}>

export function option<T extends readonly string[], P extends CustomOptions>(
  defaults: Partial<OptionFlag<ReadonlyElementOf<T>, P>> & {
    multiple?: false | undefined
    options: T
  } & ({default: OptionFlag<ReadonlyElementOf<T>, P>['default']} | {required: true}),
): FlagDefinition<(typeof defaults.options)[number], P, {multiple: false; requiredOrDefaulted: true}>

export function option<T extends readonly string[], P extends CustomOptions>(
  defaults: Partial<OptionFlag<ReadonlyElementOf<T>, P>> & {
    default?: OptionFlag<ReadonlyElementOf<T>, P>['default'] | undefined
    multiple?: false | undefined
    options: T
    required?: false | undefined
  },
): FlagDefinition<(typeof defaults.options)[number], P, {multiple: false; requiredOrDefaulted: false}>

export function option<T extends readonly string[], P extends CustomOptions>(
  defaults: Partial<OptionFlag<ReadonlyElementOf<T>[], P>> & {
    default?: OptionFlag<ReadonlyElementOf<T>[], P>['default'] | undefined
    multiple: true
    options: T
    required?: false | undefined
  },
): FlagDefinition<(typeof defaults.options)[number], P, {multiple: true; requiredOrDefaulted: false}>

export function option<T extends readonly string[], P extends CustomOptions>(
  defaults: Partial<OptionFlag<ReadonlyElementOf<T>, P>> & {options: T},
): FlagDefinition<(typeof defaults.options)[number], P, {multiple: boolean; requiredOrDefaulted: boolean}> {
  return (options: any = {}) => ({
    parse: async (input, _ctx, _opts) => input,
    ...defaults,
    ...options,
    input: [] as string[],
    multiple: Boolean(options.multiple === undefined ? defaults.multiple : options.multiple),
    type: 'option',
  })
}
````

## File: src/flush.ts
````typescript
import {error} from './errors/error'

function timeout(p: Promise<any>, ms: number) {
  function wait(ms: number, unref = false) {
    return new Promise((resolve) => {
      const t: any = setTimeout(() => resolve(null), ms)
      if (unref) t.unref()
    })
  }

  return Promise.race([p, wait(ms, true).then(() => error('timed out'))])
}

async function _flush() {
  const p = new Promise((resolve) => {
    process.stdout.once('drain', () => resolve(null))
  })
  const flushed = process.stdout.write('')

  if (flushed) return

  return p
}

export async function flush(ms = 10_000): Promise<void> {
  await timeout(_flush(), ms)
}
````

## File: src/index.ts
````typescript
import {isTruthy} from './util/util'
function checkCWD() {
  try {
    process.cwd()
  } catch (error: any) {
    if (error.code === 'ENOENT') {
      process.stderr.write('WARNING: current directory does not exist\n')
    }
  }
}

function checkNodeVersion() {
  if (process.env.OCLIF_DISABLE_ENGINE_WARNING && isTruthy(process.env.OCLIF_DISABLE_ENGINE_WARNING)) return
  try {
    const path = require('node:path')
    const semver = require('semver')
    const root = path.join(__dirname, '..')
    const pjson = require(path.join(root, 'package.json'))
    if (!semver.satisfies(process.versions.node, pjson.engines.node)) {
      process.emitWarning(
        `Node version must be ${pjson.engines.node} to use this CLI. Current node version: ${process.versions.node}`,
      )
    }
  } catch {
    // ignore
  }
}

checkCWD()
checkNodeVersion()

export * as Args from './args'
export {Command} from './command'
export {Config, Plugin} from './config'
export * as Errors from './errors'
export {handle} from './errors/handle'
export {execute} from './execute'
export * as Flags from './flags'
export {flush} from './flush'
export {
  CommandHelp,
  Help,
  HelpBase,
  type HelpSection,
  type HelpSectionKeyValueTable,
  type HelpSectionRenderer,
  loadHelpClass,
} from './help'
export * as Interfaces from './interfaces'
export {type Hook} from './interfaces/hooks'
export {getLogger} from './logger'
export {run} from './main'
export * as ModuleLoader from './module-loader'
export * as Parser from './parser'
export {Performance} from './performance'
export {type Settings, settings} from './settings'
export {toConfiguredId, toStandardizedId} from './util/ids'
export {ux} from './ux'
````

## File: src/logger.ts
````typescript
import makeDebugger from 'debug'

import {LoadOptions} from './interfaces/config'
import {Logger} from './interfaces/logger'

const OCLIF_NS = 'oclif'

function makeLogger(namespace: string = OCLIF_NS): Logger {
  const debug = makeDebugger(namespace)
  return {
    child: (ns: string, delimiter?: string) => makeLogger(`${namespace}${delimiter ?? ':'}${ns}`),
    debug,
    error: (formatter: unknown, ...args: unknown[]) => makeLogger(`${namespace}:error`).debug(formatter, ...args),
    info: debug,
    namespace,
    trace: debug,
    warn: debug,
  }
}

/**
 * Cache of logger instances. This is used to prevent creating multiple logger instances for the same namespace.
 *
 * The root logger is stored under the 'root' key as well as it's namespace.
 */
const cachedLoggers = new Map<string, Logger>()

/**
 * Returns a logger instance for the given namespace.
 * If a namespace is provided, a child logger is returned.
 * If no namespace is provided, the root logger is returned.
 */
export function getLogger(namespace?: string): Logger {
  let rootLogger = cachedLoggers.get('root')
  if (!rootLogger) {
    set(makeLogger(OCLIF_NS))
  }

  rootLogger = cachedLoggers.get('root')!

  if (namespace) {
    const cachedLogger = cachedLoggers.get(namespace)
    if (cachedLogger) return cachedLogger

    const logger = rootLogger.child(namespace)
    cachedLoggers.set(namespace, logger)
    return logger
  }

  return rootLogger
}

function ensureItMatchesInterface(newLogger: Logger): boolean {
  return (
    typeof newLogger.child === 'function' &&
    typeof newLogger.debug === 'function' &&
    typeof newLogger.error === 'function' &&
    typeof newLogger.info === 'function' &&
    typeof newLogger.trace === 'function' &&
    typeof newLogger.warn === 'function' &&
    typeof newLogger.namespace === 'string'
  )
}

function set(newLogger: Logger): void {
  if (cachedLoggers.has(newLogger.namespace)) return
  if (cachedLoggers.has('root')) return

  if (ensureItMatchesInterface(newLogger)) {
    cachedLoggers.set(newLogger.namespace, newLogger)
    cachedLoggers.set('root', newLogger)
  } else {
    process.emitWarning('Logger does not match the Logger interface. Using default logger.')
  }
}

/**
 * Convenience function to create a debug function for a specific namespace
 */
export function makeDebug(namespace: string): Logger['debug'] {
  return (formatter: unknown, ...args: unknown[]) => getLogger(namespace).debug(formatter, ...args)
}

export function setLogger(loadOptions: LoadOptions) {
  if (loadOptions && typeof loadOptions !== 'string' && 'logger' in loadOptions && loadOptions.logger) {
    set(loadOptions.logger)
  } else {
    set(makeLogger(OCLIF_NS))
  }
}

export function clearLoggers() {
  cachedLoggers.clear()
}
````

## File: src/main.ts
````typescript
import {fileURLToPath, URL} from 'node:url'

import Cache from './cache'
import {Config} from './config'
import {getHelpFlagAdditions, loadHelpClass, normalizeArgv} from './help'
import * as Interfaces from './interfaces'
import {getLogger, setLogger} from './logger'
import {OCLIF_MARKER_OWNER, Performance} from './performance'
import {SINGLE_COMMAND_CLI_SYMBOL} from './symbols'
import {ux} from './ux'

export const helpAddition = (argv: string[], config: Interfaces.Config): boolean => {
  if (argv.length === 0 && !config.isSingleCommandCLI) return true
  const mergedHelpFlags = getHelpFlagAdditions(config)
  for (const arg of argv) {
    if (mergedHelpFlags.includes(arg)) return true
    if (arg === '--') return false
  }

  return false
}

export const versionAddition = (argv: string[], config?: Interfaces.Config): boolean => {
  const additionalVersionFlags = config?.pjson.oclif.additionalVersionFlags ?? []
  const mergedVersionFlags = [...new Set(['--version', ...additionalVersionFlags]).values()]
  if (mergedVersionFlags.includes(argv[0])) return true
  return false
}

export async function run(argv?: string[], options?: Interfaces.LoadOptions): Promise<unknown> {
  const marker = Performance.mark(OCLIF_MARKER_OWNER, 'main.run')

  const initMarker = Performance.mark(OCLIF_MARKER_OWNER, 'main.run#init')

  const showHelp = async (argv: string[]) => {
    const Help = await loadHelpClass(config)
    const help = new Help(config, config.pjson.oclif.helpOptions ?? config.pjson.helpOptions)
    await help.showHelp(argv)
  }

  setLogger(options)

  const {debug} = getLogger('main')
  debug(`process.execPath: ${process.execPath}`)
  debug(`process.execArgv: ${process.execArgv}`)
  debug('process.argv: %O', process.argv)

  argv = argv ?? process.argv.slice(2)
  // Handle the case when a file URL string or URL is passed in such as 'import.meta.url'; covert to file path.
  if (options && ((typeof options === 'string' && options.startsWith('file://')) || options instanceof URL)) {
    options = fileURLToPath(options)
  }

  const config = await Config.load(options ?? require.main?.filename ?? __dirname)
  Cache.getInstance().set('config', config)
  // If this is a single command CLI, then insert the SINGLE_COMMAND_CLI_SYMBOL into the argv array to serve as the command id.
  if (config.isSingleCommandCLI) {
    argv = [SINGLE_COMMAND_CLI_SYMBOL, ...argv]
  }

  const [id, ...argvSlice] = normalizeArgv(config, argv)

  const runFinally = async () => {
    marker?.stop()
    if (!initMarker?.stopped) initMarker?.stop()
    await Performance.collect()
    Performance.debug()
    await config.runHook('finally', {argv: argvSlice, id})
  }

  // run init hook
  await config.runHook('init', {argv: argvSlice, id})

  // display version if applicable
  if (versionAddition(argv, config)) {
    ux.stdout(config.userAgent)
    await runFinally()
    return
  }

  // display help version if applicable
  if (helpAddition(argv, config)) {
    await showHelp(argv)
    await runFinally()
    return
  }

  // find & run command
  const cmd = config.findCommand(id)
  if (!cmd) {
    const topic = config.flexibleTaxonomy ? null : config.findTopic(id)
    if (topic) {
      await showHelp([id])
      await runFinally()
      return
    }
  }

  initMarker?.stop()

  try {
    return await config.runCommand(id, argvSlice, cmd)
  } finally {
    await runFinally()
  }
}
````

## File: src/module-loader.ts
````typescript
const getPackageType = require('get-package-type')
import {lstatSync} from 'node:fs'
import {extname, join, sep} from 'node:path'
import {pathToFileURL} from 'node:url'

import {Command} from './command'
import {tsPath} from './config/ts-path'
import {ModuleLoadError} from './errors/errors/module-load'
import {Config as IConfig, Plugin as IPlugin} from './interfaces'
import {existsSync} from './util/fs'

/**
 * Defines file extension resolution when source files do not have an extension.
 */

const SUPPORTED_EXTENSIONS: string[] = ['.ts', '.js', '.mjs', '.cjs', '.mts', '.cts', '.tsx', '.jsx']

const isPlugin = (config: IConfig | IPlugin): config is IPlugin => (<IPlugin>config).type !== undefined

function handleError(error: any, isESM: boolean | undefined, path: string): never {
  if (error.code === 'MODULE_NOT_FOUND' || error.code === 'ERR_MODULE_NOT_FOUND') {
    throw new ModuleLoadError(`${isESM ? 'import()' : 'require'} failed to load ${path}: ${error.message}`)
  }

  throw error
}

/**
 * Loads and returns a module.
 *
 * Uses `getPackageType` to determine if `type` is set to 'module. If so loads '.js' files as ESM otherwise uses
 * a bare require to load as CJS. Also loads '.mjs' files as ESM.
 *
 * Uses dynamic import to load ESM source or require for CommonJS.
 *
 * A unique error, ModuleLoadError, combines both CJS and ESM loader module not found errors into a single error that
 * provides a consistent stack trace and info.
 *
 * @param {IConfig|IPlugin} config - Oclif config or plugin config.
 * @param {string} modulePath - NPM module name or file path to load.
 *
 * @returns {Promise<*>} The entire ESM module from dynamic import or CJS module by require.
 */
export async function load<T = any>(config: IConfig | IPlugin, modulePath: string): Promise<T> {
  let filePath: string | undefined
  let isESM: boolean | undefined
  try {
    ;({filePath, isESM} = await resolvePath(config, modulePath))
    return (isESM ? await import(pathToFileURL(filePath).href) : require(filePath)) as T
  } catch (error: any) {
    handleError(error, isESM, filePath ?? modulePath)
  }
}

/**
 * Loads a module and returns an object with the module and data about the module.
 *
 * Uses `getPackageType` to determine if `type` is set to `module`. If so loads '.js' files as ESM otherwise uses
 * a bare require to load as CJS. Also loads '.mjs' files as ESM.
 *
 * Uses dynamic import to load ESM source or require for CommonJS.
 *
 * A unique error, ModuleLoadError, combines both CJS and ESM loader module not found errors into a single error that
 * provides a consistent stack trace and info.
 *
 * @param {IConfig|IPlugin} config - Oclif config or plugin config.
 * @param {string} modulePath - NPM module name or file path to load.
 *
 * @returns {Promise<{isESM: boolean, module: *, filePath: string}>} An object with the loaded module & data including
 *                                                                   file path and whether the module is ESM.
 */
export async function loadWithData<T = any>(
  config: IConfig | IPlugin,
  modulePath: string,
): Promise<{filePath: string; isESM: boolean; module: T}> {
  let filePath: string | undefined
  let isESM: boolean | undefined
  try {
    ;({filePath, isESM} = await resolvePath(config, modulePath))
    const module = isESM ? await import(pathToFileURL(filePath).href) : require(filePath)
    return {filePath, isESM, module}
  } catch (error: any) {
    handleError(error, isESM, filePath ?? modulePath)
  }
}

/**
 * Loads a module and returns an object with the module and data about the module.
 *
 * Uses cached `isESM` and `relativePath` in plugin manifest to determine if dynamic import (isESM = true)
 * or require (isESM = false | undefined) should be used.
 *
 * A unique error, ModuleLoadError, combines both CJS and ESM loader module not found errors into a single error that
 * provides a consistent stack trace and info.
 *
 * @param {Command.Cached} cached - Cached command data from plugin manifest.
 * @param {string} modulePath - NPM module name or file path to load.
 *
 * @returns {Promise<{isESM: boolean, module: *, filePath: string}>} An object with the loaded module & data including
 *                                                                   file path and whether the module is ESM.
 */
export async function loadWithDataFromManifest<T = any>(
  cached: Command.Cached,
  modulePath: string,
): Promise<{filePath: string; isESM: boolean; module: T}> {
  const {id, isESM, relativePath} = cached
  if (!relativePath) {
    throw new ModuleLoadError(`Cached command ${id} does not have a relative path`)
  }

  if (isESM === undefined) {
    throw new ModuleLoadError(`Cached command ${id} does not have the isESM property set`)
  }

  const filePath = join(modulePath, relativePath.join(sep))
  try {
    const module = isESM ? await import(pathToFileURL(filePath).href) : require(filePath)
    return {filePath, isESM, module}
  } catch (error: any) {
    handleError(error, isESM, filePath ?? modulePath)
  }
}

/**
 * For `.js` files uses `getPackageType` to determine if `type` is set to `module` in associated `package.json`. If
 * the `modulePath` provided ends in `.mjs` it is assumed to be ESM.
 *
 * @param {string} filePath - File path to test.
 *
 * @returns {boolean} The modulePath is an ES Module.
 * @see https://www.npmjs.com/package/get-package-type
 */
export function isPathModule(filePath: string): boolean {
  const extension = extname(filePath).toLowerCase()

  switch (extension) {
    case '.js':
    case '.jsx':
    case '.ts':
    case '.tsx': {
      return getPackageType.sync(filePath) === 'module'
    }

    case '.mjs':
    case '.mts': {
      return true
    }

    default: {
      return false
    }
  }
}

/**
 * Resolves a modulePath first by `require.resolve` to allow Node to resolve an actual module. If this fails then
 * the `modulePath` is resolved from the root of the provided config. `Config.tsPath` is used for initial resolution.
 * If this file path does not exist then several extensions are tried from `s_EXTENSIONS` in order: '.js', '.mjs',
 * '.cjs'. After a file path has been selected `isPathModule` is used to determine if the file is an ES Module.
 *
 * @param {IConfig|IPlugin} config - Oclif config or plugin config.
 * @param {string} modulePath - File path to load.
 *
 * @returns {{isESM: boolean, filePath: string}} An object including file path and whether the module is ESM.
 */
async function resolvePath(config: IConfig | IPlugin, modulePath: string): Promise<{filePath: string; isESM: boolean}> {
  let isESM: boolean
  let filePath: string | undefined

  try {
    filePath = require.resolve(modulePath)
    isESM = isPathModule(filePath)
  } catch {
    filePath =
      (isPlugin(config) ? await tsPath(config.root, modulePath, config) : await tsPath(config.root, modulePath)) ??
      modulePath

    let fileExists = false
    let isDirectory = false
    if (existsSync(filePath)) {
      fileExists = true
      try {
        if (lstatSync(filePath)?.isDirectory?.()) {
          fileExists = false
          isDirectory = true
        }
      } catch {}
    }

    if (!fileExists) {
      // Try all supported extensions.
      let foundPath = findFile(filePath)
      if (!foundPath && isDirectory) {
        // Since filePath is a directory, try looking for index file.
        foundPath = findFile(join(filePath, 'index'))
      }

      if (foundPath) {
        filePath = foundPath
      }
    }

    isESM = isPathModule(filePath)
  }

  return {filePath, isESM}
}

/**
 * Try adding the different extensions from `s_EXTENSIONS` to find the file.
 *
 * @param {string} filePath - File path to load.
 *
 * @returns {string | null} Modified file path including extension or null if file is not found.
 */
function findFile(filePath: string): null | string {
  for (const extension of SUPPORTED_EXTENSIONS) {
    const testPath = `${filePath}${extension}`

    if (existsSync(testPath)) {
      return testPath
    }
  }

  return null
}
````

## File: src/performance.ts
````typescript
import {performance, PerformanceObserver} from 'node:perf_hooks'

import {makeDebug} from './logger'
import {settings} from './settings'

type Details = Record<string, boolean | number | string | string[]>
type PerfResult = {
  details: Details
  duration: number
  method: string | undefined
  module: string
  name: string
  scope: string | undefined
}

type PerfHighlights = {
  hookRunTimes: Record<string, Record<string, number>>
  'oclif.commandLoadMs': number
  'oclif.commandRunMs': number
  'oclif.configLoadMs': number
  'oclif.corePluginsLoadMs': number
  'oclif.initHookMs': number
  'oclif.initMs': number
  'oclif.linkedPluginsLoadMs': number
  'oclif.postrunHookMs': number
  'oclif.prerunHookMs': number
  'oclif.runMs': number
  'oclif.userPluginsLoadMs': number
  pluginLoadTimes: Record<string, {details: Details; duration: number}>
}
export const OCLIF_MARKER_OWNER = '@oclif/core'

class Marker {
  public method: string
  public module: string
  public scope: string
  public stopped = false
  private startMarker: string
  private stopMarker: string

  constructor(
    public owner: string,
    public name: string,
    public details: Details = {},
  ) {
    this.startMarker = `${this.name}-start`
    this.stopMarker = `${this.name}-stop`
    const [caller, scope] = name.split('#')
    const [module, method] = caller.split('.')
    this.module = module
    this.method = method
    this.scope = scope

    performance.mark(this.startMarker)
  }

  public addDetails(details: Details): void {
    this.details = {...this.details, ...details}
  }

  public measure() {
    performance.measure(this.name, this.startMarker, this.stopMarker)
  }

  public stop() {
    this.stopped = true
    performance.mark(this.stopMarker)
  }
}

export class Performance {
  private static _oclifPerf: PerfHighlights
  /* Key: marker.owner */
  private static _results = new Map<string, PerfResult[]>()
  /* Key: marker.name */
  private static markers = new Map<string, Marker>()

  /**
   * Collect performance results into static Performance.results
   *
   * @returns Promise<void>
   */
  public static async collect(): Promise<void> {
    if (!Performance.enabled) return

    if (Performance._results.size > 0) return

    const markers = [...Performance.markers.values()]
    if (markers.length === 0) return

    for (const marker of markers.filter((m) => !m.stopped)) {
      marker.stop()
    }

    return new Promise((resolve) => {
      // eslint-disable-next-line complexity
      const perfObserver = new PerformanceObserver((items) => {
        for (const entry of items.getEntries()) {
          const marker = Performance.markers.get(entry.name)
          if (marker) {
            const result = {
              details: marker.details,
              duration: entry.duration,
              method: marker.method,
              module: marker.module,
              name: entry.name,
              scope: marker.scope,
            }

            const existing = Performance._results.get(marker.owner) ?? []
            Performance._results.set(marker.owner, [...existing, result])
          }
        }

        const oclifResults = Performance._results.get(OCLIF_MARKER_OWNER) ?? []
        const command = oclifResults.find((r) => r.name.startsWith('config.runCommand'))
        const commandLoadTime = command
          ? (Performance.getResult(
              OCLIF_MARKER_OWNER,
              `plugin.findCommand#${command.details.plugin}.${command.details.command}`,
            )?.duration ?? 0)
          : 0

        const pluginLoadTimes = Object.fromEntries(
          oclifResults
            .filter(({name}) => name.startsWith('plugin.load#'))
            .sort((a, b) => b.duration - a.duration)
            .map(({details, duration, scope}) => [scope, {details, duration}]),
        )

        const hookRunTimes = oclifResults
          .filter(({name}) => name.startsWith('config.runHook#'))
          .reduce(
            (acc, perfResult) => {
              const event = perfResult.details.event as string
              if (event) {
                if (!acc[event]) acc[event] = {}
                acc[event][perfResult.scope!] = perfResult.duration
              } else {
                const event = perfResult.scope!
                if (!acc[event]) acc[event] = {}
                acc[event].total = perfResult.duration
              }

              return acc
            },
            {} as Record<string, Record<string, number>>,
          )

        const pluginLoadTimeByType = Object.fromEntries(
          oclifResults
            .filter(({name}) => name.startsWith('config.loadPlugins#'))
            .sort((a, b) => b.duration - a.duration)
            .map(({duration, scope}) => [scope, duration]),
        )

        Performance._oclifPerf = {
          hookRunTimes,
          'oclif.commandLoadMs': commandLoadTime,
          'oclif.commandRunMs': oclifResults.find(({name}) => name.startsWith('config.runCommand#'))?.duration ?? 0,
          'oclif.configLoadMs': Performance.getResult(OCLIF_MARKER_OWNER, 'config.load')?.duration ?? 0,
          'oclif.corePluginsLoadMs': pluginLoadTimeByType.core ?? 0,
          'oclif.initHookMs': hookRunTimes.init?.total ?? 0,
          'oclif.initMs': Performance.getResult(OCLIF_MARKER_OWNER, 'main.run#init')?.duration ?? 0,
          'oclif.linkedPluginsLoadMs': pluginLoadTimeByType.link ?? 0,

          'oclif.postrunHookMs': hookRunTimes.postrun?.total ?? 0,
          'oclif.prerunHookMs': hookRunTimes.prerun?.total ?? 0,
          'oclif.runMs': Performance.getResult(OCLIF_MARKER_OWNER, 'main.run')?.duration ?? 0,
          'oclif.userPluginsLoadMs': pluginLoadTimeByType.user ?? 0,
          pluginLoadTimes,
        }

        resolve()
      })
      perfObserver.observe({buffered: true, entryTypes: ['measure']})

      for (const marker of markers) {
        try {
          marker.measure()
        } catch {
          // ignore
        }
      }

      performance.clearMarks()
    })
  }

  /**
   * Add debug logs for plugin loading performance
   */
  public static debug(): void {
    if (!Performance.enabled) return

    const oclifDebug = makeDebug('perf')
    const processUpTime = (process.uptime() * 1000).toFixed(4)
    oclifDebug('Process Uptime: %sms', processUpTime)
    oclifDebug('Oclif Time: %sms', Performance.oclifPerf['oclif.runMs'].toFixed(4))
    oclifDebug('Init Time: %sms', Performance.oclifPerf['oclif.initMs'].toFixed(4))
    oclifDebug('Config Load Time: %sms', Performance.oclifPerf['oclif.configLoadMs'].toFixed(4))
    oclifDebug(
      '  â€¢ Root Plugin Load Time: %sms',
      Performance.getResult(OCLIF_MARKER_OWNER, 'plugin.load#root')?.duration.toFixed(4) ?? 0,
    )
    oclifDebug(
      '  â€¢ Plugins Load Time: %sms',
      Performance.getResult(OCLIF_MARKER_OWNER, 'config.loadAllPlugins')?.duration.toFixed(4) ?? 0,
    )
    oclifDebug(
      '  â€¢ Commands Load Time: %sms',
      Performance.getResult(OCLIF_MARKER_OWNER, 'config.loadAllCommands')?.duration.toFixed(4) ?? 0,
    )
    oclifDebug('Core Plugin Load Time: %sms', Performance.oclifPerf['oclif.corePluginsLoadMs'].toFixed(4))
    oclifDebug('User Plugin Load Time: %sms', Performance.oclifPerf['oclif.userPluginsLoadMs'].toFixed(4))
    oclifDebug('Linked Plugin Load Time: %sms', Performance.oclifPerf['oclif.linkedPluginsLoadMs'].toFixed(4))
    oclifDebug('Plugin Load Times:')
    for (const [plugin, result] of Object.entries(Performance.oclifPerf.pluginLoadTimes)) {
      if (result.details.hasManifest) {
        oclifDebug(`  ${plugin}: ${result.duration.toFixed(4)}ms`)
      } else {
        oclifDebug(`  ${plugin}: ${result.duration.toFixed(4)}ms (no manifest!)`)
      }
    }

    oclifDebug('Hook Run Times:')
    for (const [event, runTimes] of Object.entries(Performance.oclifPerf.hookRunTimes)) {
      oclifDebug(`  ${event}:`)
      for (const [plugin, duration] of Object.entries(runTimes)) {
        oclifDebug(`    ${plugin}: ${duration.toFixed(4)}ms`)
      }
    }

    oclifDebug('Command Load Time: %sms', Performance.oclifPerf['oclif.commandLoadMs'].toFixed(4))
    oclifDebug('Command Run Time: %sms', Performance.oclifPerf['oclif.commandRunMs'].toFixed(4))
    if (Performance.oclifPerf['oclif.configLoadMs'] > Performance.oclifPerf['oclif.runMs']) {
      oclifDebug(
        '! Config load time is greater than total oclif time. This might mean that Config was instantiated before oclif was run.',
      )
    }

    const nonCoreDebug = makeDebug('non-oclif-perf')

    const nonCorePerf = Performance.results
    if (nonCorePerf.size > 0) {
      nonCoreDebug('Non-Core Performance Measurements:')
      for (const [owner, results] of nonCorePerf) {
        nonCoreDebug(`  ${owner}:`)
        for (const result of results) {
          nonCoreDebug(`    ${result.name}: ${result.duration.toFixed(4)}ms`)
        }
      }
    }
  }

  public static getResult(owner: string, name: string): PerfResult | undefined {
    return Performance._results.get(owner)?.find((r) => r.name === name)
  }

  /**
   * Add a new performance marker
   *
   * @param owner An npm package like `@oclif/core` or `@salesforce/source-tracking`
   * @param name Name of the marker. Use `module.method#scope` format
   * @param details Arbitrary details to attach to the marker
   * @returns Marker instance
   */
  public static mark(owner: string, name: string, details: Details = {}): Marker | undefined {
    if (!Performance.enabled) return

    const marker = new Marker(owner, name, details)
    Performance.markers.set(marker.name, marker)

    return marker
  }

  public static get enabled(): boolean {
    return settings.performanceEnabled ?? false
  }

  public static get oclifPerf(): PerfHighlights | Record<string, never> {
    if (!Performance.enabled) return {}

    if (Performance._oclifPerf) return Performance._oclifPerf

    throw new Error('Perf results not available. Did you forget to call await Performance.collect()?')
  }

  /** returns a map of owner, PerfResult[].  Excludes oclif PerfResult, which you can get from oclifPerf */
  public static get results(): Map<string, PerfResult[]> {
    if (!Performance.enabled) return new Map()
    return new Map<string, PerfResult[]>(
      [...Performance._results.entries()].filter(([owner]) => owner !== OCLIF_MARKER_OWNER),
    )
  }
}
````

## File: src/screen.ts
````typescript
import {settings} from './settings'

function termwidth(stream: any): number {
  if (!stream.isTTY) {
    return 80
  }

  const width = stream.getWindowSize()[0]
  if (width < 1) {
    return 80
  }

  if (width < 40) {
    return 40
  }

  return width
}

const columns = Number.parseInt(process.env.OCLIF_COLUMNS!, 10) || settings.columns

export const stdtermwidth = columns || termwidth(process.stdout)
export const errtermwidth = columns || termwidth(process.stderr)
````

## File: src/settings.ts
````typescript
export type Settings = {
  /**
   * Set the terminal width to a specified number of columns (characters)
   *
   * Environment Variable:
   *   OCLIF_COLUMNS=80
   */
  columns?: number | undefined
  /**
   * Show additional debug output without DEBUG. Mainly shows stackstraces.
   *
   * Useful to set in the ./bin/dev.js script.
   * oclif.settings.debug = true;
   */
  debug?: boolean | undefined
  /**
   * Enable performance tracking. Resulting data is available in the `perf` property of the `Config` class.
   * This will be overridden by the `enablePerf` property passed into Config constructor.
   */
  performanceEnabled?: boolean | undefined
  /**
   * Try to use ts-node to load typescript source files instead of javascript files.
   * Defaults to true in development and test environments (e.g. using bin/dev.js or
   * NODE_ENV=development or NODE_ENV=test).
   *
   * @deprecated use enableAutoTranspile instead.
   */
  tsnodeEnabled?: boolean | undefined
  /**
   * Enable automatic transpilation of TypeScript files to JavaScript.
   *
   * Defaults to true in development and test environments (e.g. using bin/dev.js or NODE_ENV=development or NODE_ENV=test).
   */
  enableAutoTranspile?: boolean | undefined
}

// Set global.oclif to the new object if it wasn't set before
if (!(globalThis as any).oclif) (globalThis as any).oclif = {}

export const settings: Settings = (globalThis as any).oclif as Settings
````

## File: src/symbols.ts
````typescript
export const SINGLE_COMMAND_CLI_SYMBOL = Symbol('SINGLE_COMMAND_CLI').toString()
````

## File: test/command/fixtures/bundled-cli/src/commands/foo/bar.ts
````typescript
import {Command} from '../../../../../../../src/index'

export default class FooBar extends Command {
  public static description = 'foo bar description'
  public async run(): Promise<void> {
    this.log('hello world!')
  }
}
````

## File: test/command/fixtures/bundled-cli/src/commands/foo/baz.ts
````typescript
import {Command} from '../../../../../../../src/index'

export default class FooBaz extends Command {
  public static description = 'foo baz description'
  public async run(): Promise<void> {}
}
````

## File: test/command/fixtures/bundled-cli/src/hooks/init.ts
````typescript
import {Hook, ux} from '../../../../../../src/index'

const hook: Hook.Init = async function (opts) {
  ux.stdout(`example hook running ${opts.id}`)
}

export default hook
````

## File: test/command/fixtures/bundled-cli/src/index.ts
````typescript
import FooBar from './commands/foo/bar'
import FooBaz from './commands/foo/baz'
export {default as initHook} from './hooks/init'

export const commands = {
  'foo:bar': FooBar,
  'foo:baz': FooBaz,
  'foo:alias': FooBar,
}
````

## File: test/command/fixtures/bundled-cli/package.json
````json
{
  "name": "oclif",
  "version": "0.0.0",
  "description": "base library for oclif CLIs",
  "private": true,
  "files": [],
  "oclif": {
    "commands": {
      "strategy": "explicit",
      "target": "./lib/index.js",
      "identifier": "commands"
    },
    "hooks": {
      "init": {
        "target": "./lib/index.js",
        "identifier": "initHook"
      }
    },
    "topicSeparator": " ",
    "plugins": [
      "@oclif/plugin-help",
      "@oclif/plugin-plugins"
    ],
    "topics": {
      "foo": {
        "description": "foo topic description",
        "subtopics": {
          "bar": {
            "description": "foo bar topic description"
          }
        }
      }
    }
  }
}
````

## File: test/command/fixtures/bundled-cli/tsconfig.json
````json
{
  "compilerOptions": {
    "outDir": "./lib",
    "rootDirs": ["./src"]
  },
  "include": ["./src/**/*"]
}
````

## File: test/command/fixtures/esm/src/commands/foo/bar/fail.js
````javascript
export class Command {
  static description = 'fail description'

  static run() {
    console.log('it fails!')
    throw new Error('random error')
  }
}
````

## File: test/command/fixtures/esm/src/commands/foo/bar/succeed.js
````javascript
export class Command {
  static description = 'succeed description'

  static run() {
    console.log('it works!')
    return 'returned success!'
  }
}
````

## File: test/command/fixtures/esm/src/commands/foo/baz.js
````javascript
export class Command {
  static description = 'foo baz description'

  static run() {
    console.log('running Baz')
  }
}
````

## File: test/command/fixtures/esm/package.json
````json
{
  "name": "oclif-esm",
  "version": "0.0.0",
  "description": "base library for oclif CLIs w/ ESM",
  "private": true,
  "type": "module",
  "files": [],
  "oclif": {
    "commands": "./src/commands",
    "topicSeparator": " ",
    "plugins": [
      "@oclif/plugin-help",
      "@oclif/plugin-plugins"
    ],
    "topics": {
      "foo": {
        "description": "foo topic description",
        "subtopics": {
          "bar": {
            "description": "foo bar topic description"
          }
        }
      }
    }
  }
}
````

## File: test/command/fixtures/single-cmd-cli/src/index.ts
````typescript
import {Command} from '../../../../../src/index'

export default class FooBar extends Command {
  public static description = 'Description of single command CLI.'
  public async run(): Promise<void> {
    this.log('hello world!')
  }
}
````

## File: test/command/fixtures/single-cmd-cli/package.json
````json
{
  "name": "single-cmd-cli",
  "version": "0.0.0",
  "description": "Single Command CLI",
  "private": true,
  "oclif": {
    "commands": {
      "strategy": "single",
      "target": "./dist"
    }
  }
}
````

## File: test/command/fixtures/single-cmd-cli/tsconfig.json
````json
{
  "compilerOptions": {
    "outDir": "dist",
    "rootDirs": ["./src"]
  },
  "include": ["./src/**/*"]
}
````

## File: test/command/fixtures/typescript/src/commands/foo/bar/fail.ts
````typescript
export const Command = {
  description: 'fail description',

  run(): void {
    console.log('it fails!')
    throw new Error('random error')
  },
}
````

## File: test/command/fixtures/typescript/src/commands/foo/bar/succeed.ts
````typescript
export const Command = {
  description: 'succeed description',

  run(): string {
    console.log('it works!')
    return 'returned success!'
  },
}
````

## File: test/command/fixtures/typescript/src/commands/foo/baz.ts
````typescript
export const Command = {
  description: 'foo baz description',

  run(): void {
    console.log('running Baz')
  },
}
````

## File: test/command/fixtures/typescript/package.json
````json
{
  "name": "oclif",
  "version": "0.0.0",
  "description": "base library for oclif CLIs",
  "private": true,
  "files": [],
  "oclif": {
    "commands": "./lib/commands",
    "topicSeparator": " ",
    "plugins": [
      "@oclif/plugin-help",
      "@oclif/plugin-plugins"
    ],
    "topics": {
      "foo": {
        "description": "foo topic description",
        "subtopics": {
          "bar": {
            "description": "foo bar topic description"
          }
        }
      }
    }
  }
}
````

## File: test/command/fixtures/typescript/tsconfig.json
````json
{
  "compilerOptions": {
    "outDir": "./lib",
    "rootDirs": ["./src"]
  },
  "include": ["./src/**/*"]
}
````

## File: test/command/helpers/test-help-in-lib/lib/test-help-plugin.js
````javascript
/* eslint-disable */
'use strict'
Object.defineProperty(exports, '__esModule', {value: true})
const sinon_1 = require('sinon')
class default_1 {
  constructor(config, opts) {
    this.showCommandHelp = sinon_1.spy(() => {
      console.log('hello from test-help-plugin #showCommandHelp in the lib folder and in compiled javascript')
    })
    this.showHelp = sinon_1.spy(() => {
      console.log('hello showHelp')
    })
    config.showCommandHelpSpy = this.showCommandHelp
    config.showHelpSpy = this.showHelp
  }
  command() {
    throw new Error('not needed for testing @oclif/command')
  }
}
exports.default = default_1
````

## File: test/command/helpers/test-help-in-src/src/test-help-plugin.ts
````typescript
import {SinonSpy, spy} from 'sinon'

import {HelpBase, Interfaces} from '../../../../../src'

export type TestHelpClassConfig = Interfaces.Config & {showCommandHelpSpy?: SinonSpy; showHelpSpy?: SinonSpy}

export default class CustomHelp extends HelpBase {
  showCommandHelp = spy(async () => {
    console.log('hello from test-help-plugin #showCommandHelp')
  })

  showHelp = spy(async () => {
    console.log('hello showHelp')
  })

  constructor(config: any, opts: any) {
    super(config, opts)
    config.showCommandHelpSpy = this.showCommandHelp
    config.showHelpSpy = this.showHelp
  }

  getCommandHelpForReadme(): string {
    throw new Error('not needed for testing @oclif/command')
  }
}
````

## File: test/command/command.test.ts
````typescript
import {captureOutput} from '@oclif/test'
import {expect} from 'chai'

import {Command as Base, Flags} from '../../src'

class Command extends Base {
  static description = 'test command'

  async run() {
    this.parse()
    this.log('foo')
  }
}

class CodeError extends Error {
  constructor(private readonly code: string) {
    super(code)
  }
}

describe('command', () => {
  it('logs to stdout', async () => {
    const {stdout} = await captureOutput(async () => Command.run([]))
    expect(stdout).to.equal('foo\n')
  })

  it('returns value', async () => {
    class Command extends Base {
      static description = 'test command'

      async run() {
        return 101
      }
    }

    const {result} = await captureOutput(async () => Command.run([]))
    expect(result).to.equal(101)
  })

  it('errors out', async () => {
    class Command extends Base {
      async run() {
        throw new Error('new x error')
      }
    }

    const {error} = await captureOutput(async () => Command.run([]))
    expect(error?.message).to.equal('new x error')
  })

  it('exits with 0', async () => {
    class Command extends Base {
      async run() {
        this.exit(0)
      }
    }

    const {error} = await captureOutput(async () => Command.run([]))
    expect(error?.code).to.equal('EEXIT')
    expect(error?.oclif?.exit).to.equal(0)
  })

  describe('parse', () => {
    it('has a flag', async () => {
      class CMD extends Base {
        static flags = {
          foo: Flags.string(),
        }

        async run() {
          const {flags} = await this.parse(CMD)
          this.log(flags.foo)
        }
      }

      const {stdout} = await captureOutput(async () => CMD.run(['--foo=bar']))
      expect(stdout).to.equal('bar\n')
    })
  })

  describe('.log()', () => {
    it('uses util.format()', async () => {
      class CMD extends Base {
        async run() {
          this.log('json output: %j', {a: 'foobar'})
        }
      }

      const {stdout} = await captureOutput(async () => CMD.run([]))
      expect(stdout).to.equal('json output: {"a":"foobar"}\n')
    })
  })

  describe('flags with deprecated aliases', () => {
    class CMD extends Command {
      static flags = {
        name: Flags.string({
          aliases: ['username', 'target-user', 'u', 'nam'],
          deprecateAliases: true,
          char: 'o',
        }),
        other: Flags.string(),
      }

      async run() {
        await this.parse(CMD)
        this.log('running command')
      }
    }

    it('shows warning for deprecated flag alias', async () => {
      const {stderr} = await captureOutput(async () => CMD.run(['--username', 'astro']))
      expect(stderr).to.include('Warning: The "--username" flag has been deprecated. Use "--name | -o"')
    })

    it('shows warning for deprecated flag alias', async () => {
      const {stderr} = await captureOutput(async () => CMD.run(['--target-user', 'astro']))
      expect(stderr).to.include('Warning: The "--target-user" flag has been deprecated. Use "--name | -o"')
    })

    it('shows warning for deprecated short char flag alias', async () => {
      const {stderr} = await captureOutput(async () => CMD.run(['-u', 'astro']))
      expect(stderr).to.include('Warning: The "-u" flag has been deprecated. Use "--name | -o"')
    })

    it('shows no warning when using proper flag name with a value that matches a flag alias', async () => {
      const {stderr} = await captureOutput(async () => CMD.run(['--name', 'username']))
      expect(stderr).to.be.empty
    })

    it('shows no warning when using another flag with a value that matches a deprecated flag alias', async () => {
      const {stderr} = await captureOutput(async () => CMD.run(['--other', 'target-user']))
      expect(stderr).to.be.empty
    })

    it('shows no warning when proper flag name with a value that matches a short char flag alias', async () => {
      const {stderr} = await captureOutput(async () => CMD.run(['--name', 'u']))
      expect(stderr).to.be.empty
    })

    it('shows no warning when using flag with deprecated alias that starts with the actual flag', async () => {
      const {stderr} = await captureOutput(async () => CMD.run(['--name', 'astro']))
      expect(stderr).to.be.empty
    })
  })

  describe('deprecated flags', () => {
    it('shows warning for deprecated flags', async () => {
      class CMD extends Command {
        static flags = {
          name: Flags.string({
            deprecated: {
              to: '--full-name',
            },
          }),
          force: Flags.boolean(),
        }

        async run() {
          await this.parse(CMD)
          this.log('running command')
        }
      }

      const {stderr} = await captureOutput(async () => CMD.run(['--name', 'astro']))
      expect(stderr).to.include('Warning: The "name" flag has been deprecated. Use "--full-name"')
    })
  })

  describe('deprecated flags that are not provided', () => {
    it('does not show warning for deprecated flags if they are not provided', async () => {
      class CMD extends Command {
        static flags = {
          name: Flags.string({
            deprecated: {
              to: '--full-name',
              version: '2.0.0',
            },
          }),
          force: Flags.boolean(),
        }

        async run() {
          await this.parse(CMD)
          this.log('running command')
        }
      }

      const {stderr} = await captureOutput(async () => CMD.run(['--force']))
      expect(stderr).to.not.include('Warning: The "name" flag has been deprecated')
    })
  })

  describe('deprecated state', () => {
    it('shows warning for deprecated command', async () => {
      class CMD extends Command {
        static id = 'my:command'
        static state = 'deprecated'

        async run() {
          this.log('running command')
        }
      }

      const {stderr} = await captureOutput(async () => CMD.run([]))
      expect(stderr).to.include('Warning: The "my:command" command has been deprecated')
    })
  })

  describe('deprecated state with options', () => {
    it('shows warning for deprecated command with custom options', async () => {
      class CMD extends Command {
        static deprecationOptions = {
          version: '2.0.0',
          to: 'my:other:command',
        }

        static id = 'my:command'
        static state = 'deprecated'

        async run() {
          this.log('running command')
        }
      }

      const {stderr} = await captureOutput(async () => CMD.run([]))
      expect(stderr).to.include('Warning: The "my:command" command has been deprecated')
      expect(stderr).to.include('in version 2.0.0')
      expect(stderr).to.include('Use "my:other:command" instead')
    })
  })

  describe('stdout err', () => {
    it('handles errors thrown from stdout', async () => {
      class CMD extends Command {
        async run() {
          process.stdout.emit('error', new CodeError('dd'))
        }
      }

      const {error} = await captureOutput(async () => CMD.run([]))
      expect(error?.message).to.equal('dd')
    })

    it('handles EPIPE errors', async () => {
      class CMD extends Command {
        async run() {
          process.stdout.emit('error', new CodeError('EPIPE'))
          this.log('json output: %j', {a: 'foobar'})
        }
      }

      const {stdout} = await captureOutput(async () => CMD.run([]))
      expect(stdout).to.equal('json output: {"a":"foobar"}\n')
    })
  })

  describe('json enabled and pass-through tests', () => {
    it('json enabled/pass through disabled/no --json flag/jsonEnabled() should be false', async () => {
      class CMD extends Command {
        static enableJsonFlag = true

        async run() {
          this.log('not json output')
        }
      }

      const cmd = new CMD([], {} as any)
      expect(cmd.jsonEnabled()).to.equal(false)
    })

    it('json enabled/pass through disabled/--json flag before --/jsonEnabled() should be true', async () => {
      class CMD extends Command {
        static enableJsonFlag = true

        async run() {}
      }

      const cmd = new CMD(['--json'], {} as any)
      expect(cmd.jsonEnabled()).to.equal(true)
    })

    it('json enabled from env', async () => {
      class CMD extends Command {
        static enableJsonFlag = true
        async run() {}
      }

      // mock a scopedEnvVar being set to JSON
      const cmd = new CMD([], {
        bin: 'FOO',
        scopedEnvVar: (foo: string) => (foo.includes('CONTENT_TYPE') ? 'json' : undefined),
      } as any)
      expect(cmd.jsonEnabled()).to.equal(true)
    })

    it('json enabled/pass through enabled/--json flag before --/jsonEnabled() should be true', async () => {
      class CMD extends Command {
        static enableJsonFlag = true

        async run() {
          const {flags} = await cmd.parse(CMD, ['--json'])
          expect(flags.json).to.equal(true, 'json flag should be true')
        }
      }

      const cmd = new CMD(['--json'], {} as any)
      expect(cmd.jsonEnabled()).to.equal(true)
    })

    it('json enabled/pass through enabled/--json flag after --/jsonEnabled() should be false', async () => {
      class CMD extends Command {
        static enableJsonFlag = true

        async run() {
          const {flags} = await cmd.parse(CMD, ['--', '--json'])
          expect(flags.json).to.equal(false, 'json flag should be false')
        }
      }

      const cmd = new CMD(['--', '--json'], {} as any)
      expect(cmd.jsonEnabled()).to.equal(false)
    })

    it('json enabled/pass through enabled/--json flag before --/extra param/jsonEnabled() should be true', async () => {
      class CMD extends Command {
        static enableJsonFlag = true

        async run() {
          const {flags} = await cmd.parse(CMD, ['--foo', '--json'])
          expect(flags.json).to.equal(true, 'json flag should be true')
        }
      }

      const cmd = new CMD(['foo', '--json'], {} as any)
      expect(cmd.jsonEnabled()).to.equal(true)
    })

    it('json enabled/pass through enabled/--json flag after --/extra param/jsonEnabled() should be false', async () => {
      class CMD extends Command {
        static enableJsonFlag = true

        async run() {
          const {flags} = await cmd.parse(CMD, ['--foo', '--', '--json'])
          expect(flags.json).to.equal(false, 'json flag should be false')
        }
      }

      const cmd = new CMD(['--foo', '--', '--json'], {} as any)
      expect(cmd.jsonEnabled()).to.equal(false)
    })

    it('json enabled/pass through enabled/--json flag before --/jsonEnabled() should be true', async () => {
      class CMD extends Command {
        static enableJsonFlag = true

        async run() {}
      }

      const cmd = new CMD(['--json', '--'], {} as any)
      expect(cmd.jsonEnabled()).to.equal(true)
    })

    it('json disabled/pass through enable/--json flag before --/jsonEnabled() should be false', async () => {
      class CMD extends Command {
        static enableJsonFlag = false

        async run() {}
      }

      const cmd = new CMD(['--json'], {} as any)
      expect(cmd.jsonEnabled()).to.equal(false)
    })
  })
})
````

## File: test/command/explicit-command-strategy.test.ts
````typescript
import {runCommand} from '@oclif/test'
import {expect} from 'chai'
import {resolve} from 'node:path'

const root = resolve(__dirname, 'fixtures/bundled-cli/package.json')

describe('explicit command discovery strategy', () => {
  it('should show help for commands', async () => {
    const {stdout} = await runCommand(['--help', 'foo'], {root})
    expect(stdout).to.include('example hook running --help')
    expect(stdout).to.include(`foo topic description

USAGE
  $ oclif foo COMMAND

COMMANDS
  foo alias  foo bar description
  foo bar    foo bar description
  foo baz    foo baz description

`)
  })

  it('should run command', async () => {
    const {stdout} = await runCommand(['foo:bar'], {root})
    expect(stdout).to.equal('example hook running foo:bar\nhello world!\n')
  })

  it('should run alias', async () => {
    const {stdout} = await runCommand(['foo:alias'], {root})
    expect(stdout).to.equal('example hook running foo:alias\nhello world!\n')
  })
})
````

## File: test/command/main-esm.test.ts
````typescript
import {runCommand} from '@oclif/test'
import {expect} from 'chai'
import {resolve} from 'node:path'
import {pathToFileURL} from 'node:url'

// This tests file URL / import.meta.url simulation.
const convertToFileURL = (filepath: string) => pathToFileURL(filepath).toString()

let root = resolve(__dirname, '../../package.json')
const pjson = require(root)
const version = `@oclif/core/${pjson.version} ${process.platform}-${process.arch} node-${process.version}`

root = convertToFileURL(root)

describe('main-esm', () => {
  it('runs plugins', async () => {
    const {stdout} = await runCommand(['plugins'], {root})
    expect(stdout).to.equal('No plugins installed.\n')
  })

  it('runs --version', async () => {
    const {stdout} = await runCommand(['--version'], {root})
    expect(stdout).to.equal(version + '\n')
  })

  it('runs --help', async () => {
    const {stdout} = await runCommand(['--help'], {root})
    expect(stdout).to.equal(`base library for oclif CLIs

VERSION
  ${version}

USAGE
  $ oclif [COMMAND]

TOPICS
  plugins  List installed plugins.

COMMANDS
  help     Display help for oclif.
  plugins  List installed plugins.

`)
  })

  it('runs spaced topic help', async () => {
    const {stdout} = await runCommand(
      ['--help', 'foo'],
      convertToFileURL(resolve(__dirname, 'fixtures/esm/package.json')),
    )
    expect(stdout).to.equal(`foo topic description

USAGE
  $ oclif-esm foo COMMAND

TOPICS
  foo bar  foo bar topic description

COMMANDS
  foo baz  foo baz description

`)
  })

  it('runs spaced topic help v2', async () => {
    const {stdout} = await runCommand(
      ['foo', 'bar', '--help'],
      convertToFileURL(resolve(__dirname, 'fixtures/esm/package.json')),
    )
    expect(stdout).to.equal(`foo bar topic description

USAGE
  $ oclif-esm foo bar COMMAND

COMMANDS
  foo bar fail     fail description
  foo bar succeed  succeed description

`)
  })

  it('runs foo:baz with space separator', async () => {
    const {stdout} = await runCommand(['foo', 'baz'], convertToFileURL(resolve(__dirname, 'fixtures/esm/package.json')))
    expect(stdout).to.equal('running Baz\n')
  })

  it('runs foo:bar:succeed with space separator', async () => {
    const {stdout} = await runCommand(
      ['foo', 'bar', 'succeed'],
      convertToFileURL(resolve(__dirname, 'fixtures/esm/package.json')),
    )
    expect(stdout).to.equal('it works!\n')
  })
})
````

## File: test/command/main.test.ts
````typescript
import {runCommand} from '@oclif/test'
import {expect} from 'chai'
import {readFileSync} from 'node:fs'
import {join, resolve} from 'node:path'

const pjson = JSON.parse(readFileSync(join(__dirname, '..', '..', 'package.json'), 'utf8'))
const version = `@oclif/core/${pjson.version} ${process.platform}-${process.arch} node-${process.version}`

describe('main', () => {
  it('should run plugins', async () => {
    const {result} = await runCommand<
      Array<{
        name: string
        type: string
      }>
    >(['plugins'])
    expect(result?.length).to.equal(3)
    const rootPlugin = result?.find((r) => r.name === '@oclif/core')
    const pluginHelp = result?.find((r) => r.name === '@oclif/plugin-help')
    const pluginPlugins = result?.find((r) => r.name === '@oclif/plugin-plugins')

    expect(rootPlugin).to.exist
    expect(pluginHelp).to.exist
    expect(pluginPlugins).to.exist
  })

  it('should run version', async () => {
    const {stdout} = await runCommand(['--version'])
    expect(stdout).to.equal(`${version}\n`)
  })

  it('should run help', async () => {
    const {stdout} = await runCommand(['--help'])
    expect(stdout).to.equal(`base library for oclif CLIs

VERSION
  ${version}

USAGE
  $ oclif [COMMAND]

TOPICS
  plugins  List installed plugins.

COMMANDS
  help     Display help for oclif.
  plugins  List installed plugins.

`)
  })

  it('should show help for topics with spaces', async () => {
    const {stdout} = await runCommand(['--help', 'foo'], {root: resolve(__dirname, 'fixtures/typescript/package.json')})
    expect(stdout).to.equal(`foo topic description

USAGE
  $ oclif foo COMMAND

TOPICS
  foo bar  foo bar topic description

COMMANDS
  foo baz  foo baz description

`)
  })

  it('should run spaced topic help v2', async () => {
    const {stdout} = await runCommand(['foo', 'bar', '--help'], {
      root: resolve(__dirname, 'fixtures/typescript/package.json'),
    })
    expect(stdout).to.equal(`foo bar topic description

USAGE
  $ oclif foo bar COMMAND

COMMANDS
  foo bar fail     fail description
  foo bar succeed  succeed description

`)
  })

  it('should run foo:baz with space separator', async () => {
    const {stdout} = await runCommand(['foo', 'baz'], {root: resolve(__dirname, 'fixtures/typescript/package.json')})
    expect(stdout).to.equal('running Baz\n')
  })

  it('should run foo:bar:succeed with space separator', async () => {
    const {stdout} = await runCommand(['foo', 'bar', 'succeed'], {
      root: resolve(__dirname, 'fixtures/typescript/package.json'),
    })
    expect(stdout).to.equal('it works!\n')
  })
})
````

## File: test/command/single-command-cli.test.ts
````typescript
import {runCommand} from '@oclif/test'
import {expect} from 'chai'
import {resolve} from 'node:path'

describe('single command cli', () => {
  it('should show help for commands', async () => {
    const {stdout} = await runCommand(['--help'], {root: resolve(__dirname, 'fixtures/single-cmd-cli/package.json')})
    expect(stdout).to.equal(`Description of single command CLI.

USAGE
  $ single-cmd-cli

DESCRIPTION
  Description of single command CLI.

`)
  })

  it('should run command', async () => {
    const {stdout} = await runCommand([], {root: resolve(__dirname, 'fixtures/single-cmd-cli/package.json')})
    expect(stdout).to.equal('hello world!\n')
  })
})
````

## File: test/config/fixtures/esm/src/commands/foo/bar/baz.js
````javascript
export class Command {
  static run() {
    console.log('it works!')
  }
}
````

## File: test/config/fixtures/esm/src/commands/foo/bar/fail.js
````javascript
export class Command {
  static run() {
    console.log('it fails!')
    throw new Error('random error')
  }
}
````

## File: test/config/fixtures/esm/src/commands/foo/bar/test-result.js
````javascript
export class Command {
  static run() {
    console.log('it works!')
    return 'returned success!'
  }
}
````

## File: test/config/fixtures/esm/src/hooks/init.js
````javascript
export function init() {
  console.log('running esm init hook')
}
````

## File: test/config/fixtures/esm/src/hooks/postrun.js
````javascript
export default function postrun(options) {
  console.log('running esm postrun hook')
  if (options.Command.id === 'foo:bar:test-result') {
    console.log(options.result)
  }
}
````

## File: test/config/fixtures/esm/src/hooks/prerun.js
````javascript
export default function prerun() {
  console.log('running esm prerun hook')
}
````

## File: test/config/fixtures/esm/package.json
````json
{
  "name": "esm-plugin",
  "description": "Module type ESM; All ESM source",
  "private": true,
  "type": "module",
  "files": [],
  "oclif": {
    "commands": "./src/commands",
    "hooks": {
      "init": "./src/hooks/init",
      "prerun": [
        "./src/hooks/prerun"
      ],
      "postrun": [
        "./src/hooks/postrun"
      ]
    }
  },
  "devDependencies": {
    "tinyglobby": "^0.2.13"
  }
}
````

## File: test/config/fixtures/help/src/commands/foo/bar/baz.js
````javascript
export class Command {
  static run() {
    console.log('it works!')
  }
}
````

## File: test/config/fixtures/help/package.json
````json
{
  "name": "help-plugin",
  "description": "Module type ESM; Configure help and version flag overrides",
  "private": true,
  "type": "module",
  "files": [],
  "oclif": {
    "commands": "./src/commands",
    "additionalHelpFlags": [
      "-h",
      "--mycommandhelp"
    ],
    "additionalVersionFlags": [
      "-v",
      "myversion",
      "version"
    ]
  }
}
````

## File: test/config/fixtures/mixed-cjs-esm/src/commands/foo/bar/baz.mjs
````
export class Command {
  static run() {
    console.log('it works!')
  }
}
````

## File: test/config/fixtures/mixed-cjs-esm/src/commands/foo/bar/fail.cjs
````
class Command {
  static run() {
    console.log('it fails!')
    throw new Error('random error')
  }
}

module.exports = Command
````

## File: test/config/fixtures/mixed-cjs-esm/src/commands/foo/bar/test-result.js
````javascript
class Command {
  static run() {
    console.log('it works!')
    return 'returned success!'
  }
}

module.exports = Command
````

## File: test/config/fixtures/mixed-cjs-esm/src/hooks/init.js
````javascript
function init() {
  console.log('running mixed-cjs-esm init hook')
}

module.exports = init
````

## File: test/config/fixtures/mixed-cjs-esm/src/hooks/postrun.mjs
````
export default function postrun(options) {
  console.log('running mixed-cjs-esm postrun hook')
  if (options.Command.id === 'foo:bar:test-result') {
    console.log(options.result)
  }
}
````

## File: test/config/fixtures/mixed-cjs-esm/src/hooks/prerun.cjs
````
function prerun() {
  console.log('running mixed-cjs-esm prerun hook')
}

module.exports = prerun
````

## File: test/config/fixtures/mixed-cjs-esm/package.json
````json
{
  "name": "mixed-cjs-esm-plugin",
  "description": "CommonJS module, but mixed w/ ESM by .mjs extension",
  "private": true,
  "files": [],
  "oclif": {
    "commands": "./src/commands",
    "hooks": {
      "init": "./src/hooks/init",
      "prerun": [
        "./src/hooks/prerun"
      ],
      "postrun": [
        "./src/hooks/postrun"
      ]
    }
  },
  "devDependencies": {
    "tinyglobby": "^0.2.13"
  }
}
````

## File: test/config/fixtures/mixed-esm-cjs/src/commands/foo/bar/baz.js
````javascript
export class Command {
  static run() {
    console.log('it works!')
  }
}
````

## File: test/config/fixtures/mixed-esm-cjs/src/commands/foo/bar/fail.cjs
````
class Command {
  static run() {
    console.log('it fails!')
    throw new Error('random error')
  }
}

module.exports = Command
````

## File: test/config/fixtures/mixed-esm-cjs/src/commands/foo/bar/test-result.js
````javascript
export default class Command {
  static run() {
    console.log('it works!')
    return 'returned success!'
  }
}
````

## File: test/config/fixtures/mixed-esm-cjs/src/hooks/init.js
````javascript
export default function init() {
  console.log('running mixed-esm-cjs init hook')
}
````

## File: test/config/fixtures/mixed-esm-cjs/src/hooks/postrun.js
````javascript
export default function postrun(options) {
  console.log('running mixed-esm-cjs postrun hook')
  if (options.Command.id === 'foo:bar:test-result') {
    console.log(options.result)
  }
}
````

## File: test/config/fixtures/mixed-esm-cjs/src/hooks/prerun.cjs
````
function prerun() {
  console.log('running mixed-esm-cjs prerun hook')
}

module.exports = prerun
````

## File: test/config/fixtures/mixed-esm-cjs/package.json
````json
{
  "name": "mixed-esm-cjs-plugin",
  "description": "Module type ESM, but mixed w/ CommonJS by .cjs extension",
  "private": true,
  "type": "module",
  "files": [],
  "oclif": {
    "commands": "./src/commands",
    "hooks": {
      "init": "./src/hooks/init",
      "prerun": [
        "./src/hooks/prerun"
      ],
      "postrun": [
        "./src/hooks/postrun"
      ]
    }
  },
  "devDependencies": {
    "tinyglobby": "^0.2.13"
  }
}
````

## File: test/config/fixtures/typescript/src/commands/foo/bar/baz.ts
````typescript
export const Command = {
  run(): void {
    console.log('it works!')
  },
}
````

## File: test/config/fixtures/typescript/src/commands/foo/bar/fail.ts
````typescript
export const Command = {
  run(): void {
    console.log('it fails!')
    throw new Error('random error')
  },
}
````

## File: test/config/fixtures/typescript/src/commands/foo/bar/test-result.ts
````typescript
export const Command = {
  run(): string {
    console.log('it works!')
    return 'returned success!'
  },
}
````

## File: test/config/fixtures/typescript/src/hooks/init.ts
````typescript
export function init(): void {
  console.log('running ts init hook')
}
````

## File: test/config/fixtures/typescript/src/hooks/postrun.ts
````typescript
export default function postrun(options: any): void {
  console.log('running ts postrun hook')
  if (options.Command.id === 'foo:bar:test-result') {
    console.log(options.result)
  }
}
````

## File: test/config/fixtures/typescript/src/hooks/prerun.ts
````typescript
export default function prerun(): void {
  console.log('running ts prerun hook')
}
````

## File: test/config/fixtures/typescript/package.json
````json
{
  "name": "ts-plugin",
  "private": true,
  "files": [],
  "oclif": {
    "commands": "./lib/commands",
    "hooks": {
      "init": "./lib/hooks/init",
      "prerun": [
        "./lib/hooks/prerun"
      ],
      "postrun": [
        "./lib/hooks/postrun"
      ]
    }
  },
  "devDependencies": {
    "tinyglobby": "^0.2.13",
    "ts-node": "^6.0.2"
  }
}
````

## File: test/config/fixtures/typescript/tsconfig.json
````json
{
  "compilerOptions": {
    "outDir": "./lib",
    "rootDirs": ["./src"]
  },
  "include": ["./src/**/*"]
}
````

## File: test/config/fixtures/wildcard/src/commands/foo.ts
````typescript
import {Command} from '../../../../../../src/index'

export default class Foo extends Command {
  public static description = 'foo description'
  public async run(): Promise<void> {
    this.log('hello world!')
  }
}
````

## File: test/config/fixtures/wildcard/package.json
````json
{
  "name": "wildcard-plugins-fixture",
  "version": "0.0.0",
  "description": "fixture for testing wildcard plugins",
  "private": true,
  "files": [],
  "dependencies": {
    "@oclif/core": "^3",
    "@oclif/plugin-help": "^6",
    "@oclif/plugin-plugins": "^4"
  },
  "oclif": {
    "commands": "./lib/commands",
    "topicSeparator": " ",
    "plugins": [
      "@oclif/plugin-*"
    ]
  }
}
````

## File: test/config/fixtures/wildcard/tsconfig.json
````json
{
  "compilerOptions": {
    "outDir": "./lib",
    "rootDirs": ["./src"]
  },
  "include": ["./src/**/*"]
}
````

## File: test/config/config.flexible.test.ts
````typescript
import {expect} from 'chai'
import sinon from 'sinon'

import {Flags} from '../../src'
import {Command} from '../../src/command'
import {Config} from '../../src/config/config'
import {getCommandIdPermutations} from '../../src/config/util'
import {Plugin as IPlugin} from '../../src/interfaces'
import * as os from '../../src/util/os'

interface Options {
  commandIds?: string[]
  types?: string[]
}

class MyCommandClass extends Command {
  aliases: string[] = []

  flags = {}

  hidden = false

  id = 'foo:bar'

  _base = ''

  run(): Promise<any> {
    return Promise.resolve()
  }
}

describe('Config with flexible taxonomy', () => {
  const originalEnv = {...process.env}

  beforeEach(() => {
    process.env = {}
  })

  afterEach(() => {
    process.env = originalEnv
    sinon.restore()
  })

  async function loadConfig({commandIds = ['foo:bar', 'foo:baz'], types = []}: Options = {}) {
    sinon.stub(os, 'getHomeDir').returns('/my/home')
    sinon.stub(os, 'getPlatform').returns('darwin')

    const load = async (): Promise<void> => {}
    const findCommand = async (): Promise<Command.Class> => MyCommandClass

    const commandPluginA: Command.Loadable = {
      strict: false,
      aliases: [],
      args: {},
      flags: {
        flagA: Flags.boolean({char: 'a'}),
      },
      hidden: false,
      hiddenAliases: [],
      id: commandIds[0],
      async load(): Promise<Command.Class> {
        return MyCommandClass
      },
      pluginType: types[0] ?? 'core',
      pluginAlias: '@My/plugina',
      permutations: getCommandIdPermutations(commandIds[0]),
    }
    const commandPluginB: Command.Loadable = {
      strict: false,
      aliases: [],
      args: {},
      flags: {
        flagB: Flags.boolean({}),
      },
      hidden: false,
      hiddenAliases: [],
      id: commandIds[1],
      async load(): Promise<Command.Class> {
        return MyCommandClass
      },
      pluginType: types[1] ?? 'core',
      pluginAlias: '@My/pluginb',
      permutations: getCommandIdPermutations(commandIds[1]),
    }
    const hooks = {}
    const pluginA: IPlugin = {
      load,
      findCommand,
      name: '@My/plugina',
      alias: '@My/plugina',
      commands: [commandPluginA],
      _base: '',
      pjson: {} as any,
      commandIDs: [commandIds[0]] as string[],
      root: '',
      version: '0.0.0',
      type: types[0] ?? 'core',
      hooks,
      topics: [],
      valid: true,
      tag: 'tag',
      moduleType: 'commonjs',
      hasManifest: false,
      isRoot: false,
      options: {root: ''},
      commandsDir: './lib/commands',
    }

    const pluginB: IPlugin = {
      load,
      findCommand,
      name: '@My/pluginb',
      alias: '@My/pluginb',
      commands: [commandPluginB],
      _base: '',
      pjson: {} as any,
      commandIDs: [commandIds[1]] as string[],
      root: '',
      version: '0.0.0',
      type: types[1] ?? 'core',
      hooks,
      topics: [],
      valid: true,
      tag: 'tag',
      moduleType: 'commonjs',
      hasManifest: false,
      isRoot: false,
      options: {root: ''},
      commandsDir: './lib/commands',
    }
    const plugins = new Map().set(pluginA.name, pluginA).set(pluginB.name, pluginB)

    const config = await Config.load()
    config.flexibleTaxonomy = true
    config.plugins = plugins
    config.pjson.oclif.plugins = ['@My/pluginb', '@My/plugina']
    config.pjson.dependencies = {'@My/pluginb': '0.0.0', '@My/plugina': '0.0.0'}
    for (const plugin of config.plugins.values()) {
      // @ts-expect-error private method
      config.loadCommands(plugin)
      // @ts-expect-error private method
      config.loadTopics(plugin)
    }

    return config
  }

  it('has populated topic index', async () => {
    const config = await loadConfig()
    // @ts-expect-error because private member
    const topics = config._topics
    expect(topics.has('foo')).to.be.true
    expect(topics.has('foo:bar')).to.be.true
    expect(topics.has('foo:baz')).to.be.true
  })

  it('has populated command permutation index', async () => {
    const config = await loadConfig()
    // @ts-expect-error because private member
    const {commandPermutations} = config
    expect(commandPermutations.get('foo')).to.deep.equal(new Set(['foo:bar', 'foo:baz']))
    expect(commandPermutations.get('foo:bar')).to.deep.equal(new Set(['foo:bar']))
    expect(commandPermutations.get('bar')).to.deep.equal(new Set(['foo:bar']))
    expect(commandPermutations.get('bar:foo')).to.deep.equal(new Set(['foo:bar']))
    expect(commandPermutations.get('foo:baz')).to.deep.equal(new Set(['foo:baz']))
    expect(commandPermutations.get('baz')).to.deep.equal(new Set(['foo:baz']))
    expect(commandPermutations.get('baz:foo')).to.deep.equal(new Set(['foo:baz']))
  })

  it('has populated command index', async () => {
    const config = await loadConfig()
    // @ts-expect-error because private member
    const commands = config._commands
    expect(commands.has('foo:bar')).to.be.true
    expect(commands.has('foo:baz')).to.be.true
  })

  it('has all command id permutations', async () => {
    const config = await loadConfig()
    expect(config.getAllCommandIDs()).to.deep.equal(['foo:bar', 'foo:baz', 'bar:foo', 'baz:foo'])
  })

  describe('findMatches', () => {
    it('finds command that contains a partial id', async () => {
      const config = await loadConfig()
      const matches = config.findMatches('foo', [])
      expect(matches.length).to.equal(2)
    })

    it('finds command that contains a partial id and matching full flag', async () => {
      const config = await loadConfig()
      const matches = config.findMatches('foo', ['--flagB'])
      expect(matches.length).to.equal(1)
      expect(matches[0].id).to.equal('foo:baz')
    })

    it('finds command that contains a partial id and matching short flag', async () => {
      const config = await loadConfig()
      const matches = config.findMatches('foo', ['-a'])
      expect(matches.length).to.equal(1)
      expect(matches[0].id).to.equal('foo:bar')
    })
  })

  describe('findCommand', () => {
    it('find command with no duplicates', async () => {
      const config = await loadConfig()
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with duplicates and choose the one that appears first in oclif.plugins', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('pluginAlias', '@My/pluginb')
    })

    it('find command with no duplicates core/user', async () => {
      const config = await loadConfig({types: ['core', 'user']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'core')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with no duplicates user/core', async () => {
      const config = await loadConfig({types: ['user', 'core']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'user')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with duplicates core/user', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar'], types: ['core', 'user']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'core')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with duplicates user/core', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar'], types: ['user', 'core']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'core')
      expect(command).to.have.property('pluginAlias', '@My/pluginb')
    })

    it('find command with duplicates user/user', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar'], types: ['user', 'user']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'user')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })
  })
})
````

## File: test/config/config.shell.test.ts
````typescript
import {expect} from 'chai'
import {userInfo as osUserInfo} from 'node:os'
import {sep} from 'node:path'

import {Config} from '../../src'

const getShell = () =>
  osUserInfo().shell?.split(sep)?.pop() || (process.platform === 'win32' ? 'powershell' : 'unknown')

describe('config shell', () => {
  it('has a default shell', async () => {
    const config = new Config({
      root: '/tmp',
      pjson: {
        name: 'test-cli',
        version: '0.0.1',
        oclif: {
          bin: 'test-cli',
        },
      },
    })
    await config.load()
    // @ts-expect-error because _shell is private
    expect(config._shell()).to.equal(getShell(), `SHELL: ${process.env.SHELL} COMSPEC: ${process.env.COMSPEC}`)
  })
})
````

## File: test/config/config.test.ts
````typescript
import {expect} from 'chai'
import {join, resolve} from 'node:path'
import sinon from 'sinon'

import {Config, Interfaces} from '../../src'
import {Command} from '../../src/command'
import {Plugin as IPlugin} from '../../src/interfaces'
import * as fs from '../../src/util/fs'
import * as os from '../../src/util/os'

interface Options {
  commandIds?: string[]
  types?: string[]
}

const pjson = {
  name: 'foo',
  version: '1.0.0',
  files: [],
  commands: {},
  oclif: {
    binAliases: ['bar', 'baz'],
    topics: {
      t1: {
        description: 'desc for t1',
        subtopics: {
          't1-1': {
            description: 'desc for t1-1',
            subtopics: {
              't1-1-1': {
                description: 'desc for t1-1-1',
              },
              't1-1-2': {
                description: 'desc for t1-1-2',
              },
            },
          },
        },
      },
    },
  },
}

describe('Config', () => {
  const originalEnv = {...process.env}
  const root = resolve(__dirname, '..')

  beforeEach(() => {
    process.env = {}
  })

  afterEach(() => {
    sinon.restore()
    process.env = originalEnv
  })

  describe('binAliases', () => {
    it('will have binAliases set', async () => {
      const config = await Config.load({pjson, root})

      expect(config.binAliases).to.deep.equal(['bar', 'baz'])
    })

    it('will get scoped env vars with bin aliases', async () => {
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVarKeys('abc')).to.deep.equal(['FOO_ABC', 'BAR_ABC', 'BAZ_ABC'])
    })

    it('will get scoped env vars', async () => {
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVarKey('abc')).to.equal('FOO_ABC')
    })

    it('will get scopedEnvVar', async () => {
      process.env.FOO_ABC = 'find me'
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVar('abc')).to.deep.equal('find me')
    })

    it('will get scopedEnvVar via alias', async () => {
      process.env.BAZ_ABC = 'find me'
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVar('abc')).to.deep.equal('find me')
    })

    it('will get scoped env vars', async () => {
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVarKey('abc')).to.equal('FOO_ABC')
    })

    it('will get scopedEnvVarTrue', async () => {
      process.env.FOO_ABC = 'true'
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVarTrue('abc')).to.equal(true)
    })

    it('will get scopedEnvVarTrue via alias', async () => {
      process.env.BAR_ABC = 'true'
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVarTrue('abc')).to.equal(true)
    })

    it('will get scopedEnvVarTrue=1', async () => {
      process.env.FOO_ABC = '1'
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVarTrue('abc')).to.equal(true)
    })

    it('will get scopedEnvVarTrue=1 via alias', async () => {
      process.env.BAR_ABC = '1'
      const config = await Config.load({pjson, root})
      expect(config.scopedEnvVarTrue('abc')).to.equal(true)
    })
  })

  describe('darwin', () => {
    it('should have darwin specific paths', async () => {
      sinon.stub(os, 'getHomeDir').returns(join('/my/home'))
      sinon.stub(os, 'getPlatform').returns('darwin')
      const config = await Config.load()

      expect(config).to.have.property('cacheDir', join('/my/home/Library/Caches/@oclif/core'))
      expect(config).to.have.property('configDir', join('/my/home/.config/@oclif/core'))
      expect(config).to.have.property('dataDir', join('/my/home/.local/share/@oclif/core'))
      expect(config).to.have.property('home', join('/my/home'))
    })
  })

  describe('linux', () => {
    it('should have linux specific paths', async () => {
      sinon.stub(os, 'getHomeDir').returns(join('/my/home'))
      sinon.stub(os, 'getPlatform').returns('linux')
      const config = await Config.load()

      expect(config).to.have.property('cacheDir', join('/my/home/.cache/@oclif/core'))
      expect(config).to.have.property('configDir', join('/my/home/.config/@oclif/core'))
      expect(config).to.have.property('dataDir', join('/my/home/.local/share/@oclif/core'))
      expect(config).to.have.property('home', join('/my/home'))
    })
  })

  describe('win32', () => {
    it('should have win32 specific paths', async () => {
      sinon.stub(os, 'getHomeDir').returns(join('/my/home'))
      sinon.stub(os, 'getPlatform').returns('win32')
      process.env.LOCALAPPDATA = '/my/home/localappdata'
      const config = await Config.load()

      // eslint-disable-next-line unicorn/prefer-string-raw
      expect(config).to.have.property('cacheDir', join('/my/home/localappdata/@oclif\\core'))
      // eslint-disable-next-line unicorn/prefer-string-raw
      expect(config).to.have.property('configDir', join('/my/home/localappdata/@oclif\\core'))
      // eslint-disable-next-line unicorn/prefer-string-raw
      expect(config).to.have.property('dataDir', join('/my/home/localappdata/@oclif\\core'))
      expect(config).to.have.property('home', join('/my/home'))
    })
  })

  describe('s3Key', async () => {
    const target = {platform: 'darwin', arch: 'x64'}
    const beta = {version: '2.0.0-beta', channel: 'beta'}
    let config: Config

    before(async () => {
      config = await Config.load()
      // Config.load reads the package.json to determine the version and channel
      // In order to allow prerelease branches to pass, we need to strip the prerelease
      // tag from the version and switch the channel to stable.
      config.version = config.version.replaceAll(/-beta\.\d/g, '')
      config.channel = 'stable'
    })

    const tests: Array<{
      key: keyof Interfaces.S3Templates
      expected: string
      extra?: Record<string, string> & {ext?: '.tar.gz' | '.tar.xz' | Interfaces.Config.s3Key.Options}
    }> = [
      {key: 'baseDir', expected: 'oclif-cli'},
      {key: 'manifest', expected: 'version'},
      {key: 'manifest', expected: 'channels/beta/version', extra: beta},
      {key: 'manifest', expected: 'darwin-x64', extra: target},
      {key: 'manifest', expected: 'channels/beta/darwin-x64', extra: {...beta, ...target}},
      {key: 'unversioned', expected: 'oclif-cli.tar.gz'},
      {key: 'unversioned', expected: 'oclif-cli.tar.gz'},
      {key: 'unversioned', expected: 'channels/beta/oclif-cli.tar.gz', extra: beta},
      {key: 'unversioned', expected: 'channels/beta/oclif-cli.tar.gz', extra: beta},
      {key: 'unversioned', expected: 'oclif-cli-darwin-x64.tar.gz', extra: target},
      {key: 'unversioned', expected: 'oclif-cli-darwin-x64.tar.gz', extra: target},
      {key: 'unversioned', expected: 'channels/beta/oclif-cli-darwin-x64.tar.gz', extra: {...beta, ...target}},
      {key: 'unversioned', expected: 'channels/beta/oclif-cli-darwin-x64.tar.gz', extra: {...beta, ...target}},
      {key: 'versioned', expected: 'oclif-cli-v1.0.0/oclif-cli-v1.0.0.tar.gz'},
      {key: 'versioned', expected: 'oclif-cli-v1.0.0/oclif-cli-v1.0.0-darwin-x64.tar.gz', extra: target},
      {key: 'versioned', expected: 'channels/beta/oclif-cli-v2.0.0-beta/oclif-cli-v2.0.0-beta.tar.gz', extra: beta},
      {
        key: 'versioned',
        expected: 'channels/beta/oclif-cli-v2.0.0-beta/oclif-cli-v2.0.0-beta-darwin-x64.tar.gz',
        extra: {...beta, ...target},
      },
    ]

    for (const testCase of tests) {
      const {key, expected, extra} = testCase
      let {ext, ...options} = extra ?? {}
      options = {
        bin: 'oclif-cli',
        version: '1.0.0',
        ext: '.tar.gz',
        ...options,
      }
      it(`renders ${key} template as ${expected}`, () => {
        const o = ext ? config.s3Key(key, ext, options) : config.s3Key(key, options)
        expect(o).to.equal(expected)
      })
    }
  })

  describe('options', () => {
    it('should set the channel and version', async () => {
      const config = await Config.load({root, channel: 'test-channel', version: '0.1.2-test'})
      expect(config).to.have.property('channel', 'test-channel')
      expect(config).to.have.property('version', '0.1.2-test')
    })
  })

  it('has s3Url', async () => {
    const config = await Config.load({
      root,
      pjson: {
        ...pjson,
        oclif: {
          ...pjson.oclif,
          update: {
            s3: {
              host: 'https://bar.com/a/',
            },
          },
        },
      },
    })
    expect(config.s3Url('/b/c')).to.equal('https://bar.com/a/b/c')
  })

  it('has subtopics', async () => {
    const config = await Config.load({root, pjson})
    expect(config.topics.map((t) => t.name)).to.have.members(['t1', 't1:t1-1', 't1:t1-1:t1-1-1', 't1:t1-1:t1-1-2'])
  })

  describe('findCommand', () => {
    async function loadConfig({commandIds = ['foo:bar', 'foo:baz'], types = []}: Options = {}) {
      sinon.stub(os, 'getHomeDir').returns('/my/home')
      sinon.stub(os, 'getPlatform').returns('darwin')

      class MyCommandClass extends Command {
        aliases: string[] = []

        hidden = false

        id = 'foo:bar'

        _base = ''

        run(): Promise<any> {
          return Promise.resolve()
        }
      }

      const load = async (): Promise<void> => {}
      const findCommand = async (): Promise<Command.Class> => MyCommandClass

      const commandPluginA: Command.Loadable = {
        strict: false,
        aliases: [],
        args: {},
        flags: {},
        hidden: false,
        hiddenAliases: [],
        id: commandIds[0],
        async load(): Promise<Command.Class> {
          return MyCommandClass
        },
        pluginType: types[0] ?? 'core',
        pluginAlias: '@My/plugina',
      }
      const commandPluginB: Command.Loadable = {
        strict: false,
        aliases: [],
        args: {},
        flags: {},
        hidden: false,
        hiddenAliases: [],
        id: commandIds[1],
        async load(): Promise<Command.Class> {
          return MyCommandClass
        },
        pluginType: types[1] ?? 'core',
        pluginAlias: '@My/pluginb',
      }
      const hooks = {}
      const pluginA: IPlugin = {
        load,
        findCommand,
        name: '@My/plugina',
        alias: '@My/plugina',
        commands: [commandPluginA],
        _base: '',
        pjson,
        commandIDs: [commandIds[0]] as string[],
        root: '',
        version: '0.0.0',
        type: types[0] ?? 'core',
        hooks,
        topics: [],
        valid: true,
        tag: 'tag',
        moduleType: 'commonjs',
        hasManifest: false,
        isRoot: false,
        options: {root: ''},
        commandsDir: './lib/commands',
      }

      const pluginB: IPlugin = {
        load,
        findCommand,
        name: '@My/pluginb',
        alias: '@My/pluginb',
        commands: [commandPluginB],
        _base: '',
        pjson,
        commandIDs: [commandIds[1]] as string[],
        root: '',
        version: '0.0.0',
        type: types[1] ?? 'core',
        hooks,
        topics: [],
        valid: true,
        tag: 'tag',
        moduleType: 'commonjs',
        hasManifest: false,
        isRoot: false,
        options: {root: ''},
        commandsDir: './lib/commands',
      }
      const plugins = new Map().set(pluginA.name, pluginA).set(pluginB.name, pluginB)

      const config = await Config.load({
        root,
        pjson,
      })
      config.plugins = plugins
      config.pjson = {
        ...pjson,
        dependencies: {
          '@My/pluginb': '0.0.0',
          '@My/plugina': '0.0.0',
        },
        oclif: {
          ...pjson.oclif,
          plugins: ['@My/pluginb', '@My/plugina'],
        },
      }
      for (const plugin of config.plugins.values()) {
        // @ts-expect-error private method
        config.loadCommands(plugin)
        // @ts-expect-error private method
        config.loadTopics(plugin)
      }

      return config
    }

    it('find command with no duplicates', async () => {
      const config = await loadConfig()
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with duplicates and choose the one that appears first in oclif.plugins', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('pluginAlias', '@My/pluginb')
    })

    it('find command with no duplicates core/user', async () => {
      const config = await loadConfig({types: ['core', 'user']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'core')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with no duplicates user/core', async () => {
      const config = await loadConfig({types: ['user', 'core']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'user')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with duplicates core/user', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar'], types: ['core', 'user']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'core')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })

    it('find command with duplicates user/core', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar'], types: ['user', 'core']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'core')
      expect(command).to.have.property('pluginAlias', '@My/pluginb')
    })

    it('find command with duplicates user/user', async () => {
      const config = await loadConfig({commandIds: ['foo:bar', 'foo:bar'], types: ['user', 'user']})
      const command = config.findCommand('foo:bar', {must: true})
      expect(command).to.have.property('id', 'foo:bar')
      expect(command).to.have.property('pluginType', 'user')
      expect(command).to.have.property('pluginAlias', '@My/plugina')
    })
  })

  describe('theme', () => {
    it('should not be set when DISABLE_THEME is true and theme.json exists', async () => {
      process.env.FOO_DISABLE_THEME = 'true'
      sinon.stub(fs, 'safeReadJson').resolves({bin: '#FF0000'})
      const config = await Config.load({root, pjson})
      expect(config).to.have.property('theme', undefined)
    })

    it('should be set when DISABLE_THEME is false and theme.json exists', async () => {
      process.env.FOO_DISABLE_THEME = 'false'
      sinon.stub(fs, 'safeReadJson').resolves({bin: '#FF0000'})
      const config = await Config.load({root, pjson})
      expect(config.theme).to.have.property('bin', '#FF0000')
    })

    it('should be set when DISABLE_THEME is unset and theme.json exists', async () => {
      sinon.stub(fs, 'safeReadJson').resolves({bin: '#FF0000'})
      const config = await Config.load({root, pjson})
      expect(config.theme).to.have.property('bin', '#FF0000')
    })

    it('should not be set when DISABLE_THEME is true and theme.json does not exist', async () => {
      process.env.FOO_DISABLE_THEME = 'true'
      sinon.stub(fs, 'safeReadJson').resolves()
      const config = await Config.load({root, pjson})
      expect(config).to.have.property('theme', undefined)
    })

    it('should not be set when DISABLE_THEME is false and theme.json does not exist', async () => {
      process.env.FOO_DISABLE_THEME = 'false'
      sinon.stub(fs, 'safeReadJson').resolves()
      const config = await Config.load({root, pjson})
      expect(config).to.have.property('theme', undefined)
    })

    it('should not be set when DISABLE_THEME is unset and theme.json does not exist', async () => {
      sinon.stub(fs, 'safeReadJson').resolves()
      const config = await Config.load({root, pjson})
      expect(config).to.have.property('theme', undefined)
    })
  })
})
````

## File: test/config/esm.test.ts
````typescript
import {runCommand, runHook} from '@oclif/test'
import {expect} from 'chai'
import {join, resolve} from 'node:path'
import url from 'node:url'

import {Config} from '../../src/config'

const root = resolve(__dirname, 'fixtures/esm')

// This tests file URL / import.meta.url simulation.
const rootAsFileURL = url.pathToFileURL(root).toString()

describe('esm', () => {
  it('has commandsDir', async () => {
    const config = await Config.load(rootAsFileURL)
    expect([...config.plugins.values()][0]).to.deep.include({
      commandsDir: join(root, 'src/commands'),
    })
  })

  it('runs esm command and prerun & postrun hooks', async () => {
    const {stdout} = await runCommand(['foo:bar:baz'], root)
    expect(stdout).to.equal('running esm init hook\nrunning esm prerun hook\nit works!\nrunning esm postrun hook\n')
  })

  it('runs faulty command, only prerun hook triggers', async () => {
    const {stdout} = await runCommand(['foo:bar:fail'], root)
    expect(stdout).to.equal('running esm init hook\nrunning esm prerun hook\nit fails!\n')
  })

  it('runs esm command, postrun hook captures command result', async () => {
    const {stdout} = await runCommand(['foo:bar:test-result'], root)
    expect(stdout).to.equal(
      'running esm init hook\nrunning esm prerun hook\nit works!\nrunning esm postrun hook\nreturned success!\n',
    )
  })

  it('runs init hook', async () => {
    const {stdout} = await runHook('init', {id: 'myid', argv: ['foo']}, {root})
    expect(stdout).to.equal('running esm init hook\n')
  })
})
````

## File: test/config/help.config.test.ts
````typescript
import {expect} from 'chai'
import {resolve} from 'node:path'
import {pathToFileURL} from 'node:url'

import {Config} from '../../src/config'
import {getHelpFlagAdditions} from '../../src/help'
import {helpAddition, versionAddition} from '../../src/main'

const root = resolve(__dirname, 'fixtures/help')

// This tests file URL / import.meta.url simulation.
const rootAsFileURL = pathToFileURL(root).toString()

describe('help and version flag additions', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load(rootAsFileURL)
  })

  it('has help and version additions', () => {
    expect(config.pjson.oclif.additionalHelpFlags).to.have.lengthOf(2)
    expect(config.pjson.oclif.additionalVersionFlags).to.have.lengthOf(3)
    const mergedHelpFlags = getHelpFlagAdditions(config)
    expect(mergedHelpFlags).to.deep.equal([...(config.pjson.oclif.additionalHelpFlags as string[]), '--help'])
    expect(helpAddition(['-h'], config)).to.be.true
    expect(helpAddition(['help'], config)).to.be.false
    expect(helpAddition(['--mycommandhelp'], config)).to.be.true
    expect(helpAddition(['foobar'], config)).to.be.false
    expect(versionAddition(['-v'], config)).to.be.true
    expect(versionAddition(['version'], config)).to.be.true
    expect(versionAddition(['myversion'], config)).to.be.true
    expect(versionAddition(['notmyversion'], config)).to.be.false
  })

  it('has version additions', () => {
    delete config.pjson.oclif.additionalHelpFlags
    expect(config.pjson.oclif.additionalHelpFlags).to.not.be.ok
    expect(config.pjson.oclif.additionalVersionFlags).to.have.lengthOf(3)
    const mergedHelpFlags = getHelpFlagAdditions(config)
    expect(mergedHelpFlags).to.deep.equal(['--help'])
    expect(helpAddition(['-h'], config)).to.be.false
    expect(helpAddition(['help'], config)).to.be.false
    expect(helpAddition(['mycommandhelp'], config)).to.be.false
    expect(versionAddition(['-v'], config)).to.be.true
    expect(versionAddition(['version'], config)).to.be.true
    expect(versionAddition(['myversion'], config)).to.be.true
    expect(versionAddition(['notmyversion'], config)).to.be.false
  })
})
````

## File: test/config/mixed-cjs-esm.test.ts
````typescript
import {runCommand, runHook} from '@oclif/test'
import {expect} from 'chai'
import {join, resolve} from 'node:path'

import {Config} from '../../src/config'

const root = resolve(__dirname, 'fixtures/mixed-cjs-esm')

describe('mixed-cjs-esm', () => {
  it('has commandsDir', async () => {
    const config = await Config.load(root)
    expect([...config.plugins.values()][0]).to.deep.include({
      commandsDir: join(root, 'src/commands'),
    })
  })

  it('runs mixed-cjs-esm command and prerun & postrun hooks', async () => {
    const {stdout} = await runCommand(['foo:bar:baz'], root)
    expect(stdout).to.equal(
      'running mixed-cjs-esm init hook\nrunning mixed-cjs-esm prerun hook\nit works!\nrunning mixed-cjs-esm postrun hook\n',
    )
  })

  it('runs faulty command, only prerun hook triggers', async () => {
    const {stdout} = await runCommand(['foo:bar:fail'], root)
    expect(stdout).to.equal('running mixed-cjs-esm init hook\nrunning mixed-cjs-esm prerun hook\nit fails!\n')
  })

  it('runs mixed-cjs-esm command, postrun hook captures command result', async () => {
    const {stdout} = await runCommand(['foo:bar:test-result'], root)
    expect(stdout).to.equal(
      'running mixed-cjs-esm init hook\nrunning mixed-cjs-esm prerun hook\nit works!\nrunning mixed-cjs-esm postrun hook\nreturned success!\n',
    )
  })

  it('runs init hook', async () => {
    const {stdout} = await runHook('init', {id: 'myid', argv: ['foo']}, {root})
    expect(stdout).to.equal('running mixed-cjs-esm init hook\n')
  })
})
````

## File: test/config/mixed-esm-cjs.test.ts
````typescript
import {runCommand, runHook} from '@oclif/test'
import {expect} from 'chai'
import {join, resolve} from 'node:path'

import {Config} from '../../src/config'

const root = resolve(__dirname, 'fixtures/mixed-esm-cjs')

describe('mixed-esm-cjs', () => {
  it('has commandsDir', async () => {
    const config = await Config.load(root)
    expect([...config.plugins.values()][0]).to.deep.include({
      commandsDir: join(root, 'src/commands'),
    })
  })

  it('runs mixed-esm-cjs command and prerun & postrun hooks', async () => {
    const {stdout} = await runCommand(['foo:bar:baz'], root)
    expect(stdout).to.equal(
      'running mixed-esm-cjs init hook\nrunning mixed-esm-cjs prerun hook\nit works!\nrunning mixed-esm-cjs postrun hook\n',
    )
  })

  it('runs faulty command, only prerun hook triggers', async () => {
    const {stdout} = await runCommand(['foo:bar:fail'], root)
    expect(stdout).to.equal('running mixed-esm-cjs init hook\nrunning mixed-esm-cjs prerun hook\nit fails!\n')
  })

  it('runs mixed-esm-cjs command, postrun hook captures command result', async () => {
    const {stdout} = await runCommand(['foo:bar:test-result'], root)
    expect(stdout).to.equal(
      'running mixed-esm-cjs init hook\nrunning mixed-esm-cjs prerun hook\nit works!\nrunning mixed-esm-cjs postrun hook\nreturned success!\n',
    )
  })

  it('runs init hook', async () => {
    const {stdout} = await runHook('init', {id: 'myid', argv: ['foo']}, {root})
    expect(stdout).to.equal('running mixed-esm-cjs init hook\n')
  })
})
````

## File: test/config/ts-path.test.ts
````typescript
import {expect} from 'chai'
import {join, resolve} from 'node:path'
import sinon from 'sinon'
import * as tsNode from 'ts-node'

import * as configTsNode from '../../src/config/ts-path'
import {Interfaces, settings} from '../../src/index'
import * as util from '../../src/util/read-tsconfig'

const root = resolve(__dirname, 'fixtures/typescript')
const tsSource = 'src/hooks/init.ts'
// ts-node can load the file as a module (without ts)
const tsModule = 'src/hooks/init'
const jsCompiledModule = 'lib/hooks/init'
const jsCompiled = 'lib/hooks/init.js'

// Typical root and out options of a typescript project
const DEFAULT_TS_CONFIG: Interfaces.TSConfig = {
  compilerOptions: {
    rootDir: 'src',
    outDir: 'lib',
  },
}

describe('tsPath', () => {
  beforeEach(() => {
    sinon.stub(tsNode, 'register')
  })

  afterEach(() => {
    sinon.restore()
    // Clear caches so that unit tests don't affect each other
    // @ts-expect-error because TS_CONFIGS is not exported
    // eslint-disable-next-line import/namespace
    configTsNode.TS_CONFIGS = {}
    // @ts-expect-error because REGISTERED is not exported
    // eslint-disable-next-line import/namespace
    configTsNode.REGISTERED = new Set()
  })

  it('should resolve a .js file to ts src', async () => {
    sinon.stub(util, 'readTSConfig').resolves(DEFAULT_TS_CONFIG)
    const result = await configTsNode.tsPath(root, jsCompiled)
    expect(result).to.equal(join(root, tsModule))
  })

  it('should resolve a module file to ts src', async () => {
    sinon.stub(util, 'readTSConfig').resolves(DEFAULT_TS_CONFIG)
    const result = await configTsNode.tsPath(root, jsCompiledModule)
    expect(result).to.equal(join(root, tsModule))
  })

  it('should resolve a .ts file', async () => {
    sinon.stub(util, 'readTSConfig').resolves(DEFAULT_TS_CONFIG)
    const result = await configTsNode.tsPath(root, tsSource)
    expect(result).to.equal(join(root, tsSource))
  })

  it('should resolve a .ts file using baseUrl', async () => {
    sinon.stub(util, 'readTSConfig').resolves({
      compilerOptions: {
        baseUrl: '.src/',
        outDir: 'lib',
      },
    })
    const result = await configTsNode.tsPath(root, tsSource)
    expect(result).to.equal(join(root, tsSource))
  })

  it('should resolve .ts with no outDir', async () => {
    sinon.stub(util, 'readTSConfig').resolves({compilerOptions: {rootDir: 'src'}})
    const result = await configTsNode.tsPath(root, tsSource)
    expect(result).to.equal(join(root, tsSource))
  })

  it('should resolve .js with no rootDir and outDir', async () => {
    sinon.stub(util, 'readTSConfig').resolves({compilerOptions: {sourceMap: true}})
    const result = await configTsNode.tsPath(root, jsCompiled)
    expect(result).to.equal(join(root, jsCompiled))
  })

  it('should resolve to .ts file if enabled and prod', async () => {
    sinon.stub(util, 'readTSConfig').resolves(DEFAULT_TS_CONFIG)
    settings.enableAutoTranspile = true
    const originalNodeEnv = process.env.NODE_ENV
    delete process.env.NODE_ENV

    const result = await configTsNode.tsPath(root, jsCompiled)
    expect(result).to.equal(join(root, tsModule))

    process.env.NODE_ENV = originalNodeEnv
    delete settings.enableAutoTranspile
  })

  it('should resolve to js if disabled', async () => {
    sinon.stub(util, 'readTSConfig').resolves(DEFAULT_TS_CONFIG)
    settings.enableAutoTranspile = false
    const result = await configTsNode.tsPath(root, jsCompiled)
    expect(result).to.equal(join(root, jsCompiled))

    delete settings.enableAutoTranspile
  })
})
````

## File: test/config/typescript.test.ts
````typescript
import {runCommand, runHook} from '@oclif/test'
import {expect} from 'chai'
import {join, resolve} from 'node:path'

import {Config} from '../../src/config'

const root = resolve(__dirname, 'fixtures/typescript')

describe('typescript', () => {
  it('has commandsDir', async () => {
    const config = await Config.load(root)
    expect([...config.plugins.values()][0]).to.deep.include({
      commandsDir: join(root, 'src/commands'),
    })
  })

  it('runs ts command and prerun & postrun hooks', async () => {
    const {stdout} = await runCommand(['foo:bar:baz'], root)
    expect(stdout).to.equal('running ts init hook\nrunning ts prerun hook\nit works!\nrunning ts postrun hook\n')
  })

  it('runs faulty command, only prerun hook triggers', async () => {
    const {stdout} = await runCommand(['foo:bar:fail'], root)
    expect(stdout).to.equal('running ts init hook\nrunning ts prerun hook\nit fails!\n')
  })

  it('runs ts command, postrun hook captures command result', async () => {
    const {stdout} = await runCommand(['foo:bar:test-result'], root)
    expect(stdout).to.equal(
      'running ts init hook\nrunning ts prerun hook\nit works!\nrunning ts postrun hook\nreturned success!\n',
    )
  })

  it('runs init hook', async () => {
    const {stdout} = await runHook('init', {id: 'myid', argv: ['foo']}, {root})
    expect(stdout).to.equal('running ts init hook\n')
  })
})
````

## File: test/config/util.test.ts
````typescript
import {expect} from 'chai'

import {collectUsableIds, getCommandIdPermutations} from '../../src/config/util'

describe('util', () => {
  describe('collectUsableIds', () => {
    it('returns all usable command ids', async () => {
      const ids = collectUsableIds(['foo:bar:baz', 'one:two:three'])
      expect(ids).to.deep.equal(new Set(['foo', 'foo:bar', 'foo:bar:baz', 'one', 'one:two', 'one:two:three']))
    })
  })

  describe('getCommandIdPermutations', () => {
    it('returns all usable command ids', async () => {
      const permutations = getCommandIdPermutations('foo:bar:baz')
      expect(permutations).to.deep.equal([
        'foo:bar:baz',
        'bar:foo:baz',
        'bar:baz:foo',
        'foo:baz:bar',
        'baz:foo:bar',
        'baz:bar:foo',
      ])
    })

    // This is just calculating the factorial (n!) of the number of elements passed in.
    const numberOfPermutations = (commandID: string): number => {
      const num = commandID.split(':').length
      let result = 1
      for (let i = 2; i <= num; i++) result *= i
      return result
    }

    it('returns the correct number of permutations', async () => {
      expect(getCommandIdPermutations('one').length).to.equal(numberOfPermutations('one'))
      expect(getCommandIdPermutations('one:two').length).to.equal(numberOfPermutations('one:two'))
      expect(getCommandIdPermutations('one:two:three').length).to.equal(numberOfPermutations('one:two:three'))
      expect(getCommandIdPermutations('one:two:three:four').length).to.equal(numberOfPermutations('one:two:three:four'))
      expect(getCommandIdPermutations('one:two:three:four:five').length).to.equal(
        numberOfPermutations('one:two:three:four:five'),
      )
      expect(getCommandIdPermutations('one:two:three:four:five:six').length).to.equal(
        numberOfPermutations('one:two:three:four:five:six'),
      )
      expect(getCommandIdPermutations('one:two:three:four:five:six:seven').length).to.equal(
        numberOfPermutations('one:two:three:four:five:six:seven'),
      )
      expect(getCommandIdPermutations('one:two:three:four:five:six:seven:eight').length).to.equal(
        numberOfPermutations('one:two:three:four:five:six:seven:eight'),
      )
      expect(getCommandIdPermutations('one:two:three:four:five:six:seven:eight:nine').length).to.equal(
        numberOfPermutations('one:two:three:four:five:six:seven:eight:nine'),
      )
    })
  })
})
````

## File: test/config/wildcard-plugins.test.ts
````typescript
import {runCommand} from '@oclif/test'
import {expect} from 'chai'
import {resolve} from 'node:path'

describe('plugins defined as patterns in package.json', () => {
  it('should load all core plugins in dependencies that match pattern', async () => {
    const {result} = await runCommand<Array<{name: string; type: string}>>(['plugins', '--core'], {
      root: resolve(__dirname, 'fixtures/wildcard/package.json'),
      pluginAdditions: {
        core: ['@oclif/plugin-*'],
        path: resolve(__dirname, '..', '..'),
      },
    })

    expect(result?.length).to.equal(3)
    const rootPlugin = result?.find((r) => r.name === 'wildcard-plugins-fixture')
    const pluginHelp = result?.find((r) => r.name === '@oclif/plugin-help')
    const pluginPlugins = result?.find((r) => r.name === '@oclif/plugin-plugins')

    expect(rootPlugin).to.exist
    expect(pluginHelp).to.exist
    expect(pluginPlugins).to.exist
  })

  it('should load all dev plugins in dependencies and devDependencies that match pattern', async () => {
    const {result} = await runCommand<Array<{name: string; type: string}>>(['plugins', '--core'], {
      root: resolve(__dirname, 'fixtures/wildcard/package.json'),
      pluginAdditions: {
        dev: ['@oclif/plugin-*'],
        path: resolve(__dirname, '..', '..'),
      },
    })

    expect(result?.length).to.equal(3)
    const rootPlugin = result?.find((r) => r.name === 'wildcard-plugins-fixture')
    const pluginHelp = result?.find((r) => r.name === '@oclif/plugin-help')
    const pluginPlugins = result?.find((r) => r.name === '@oclif/plugin-plugins')

    expect(rootPlugin).to.exist
    expect(pluginHelp).to.exist
    expect(pluginPlugins).to.exist
  })
})
````

## File: test/errors/error.test.ts
````typescript
import {captureOutput} from '@oclif/test'
import {expect} from 'chai'

import {error} from '../../src/errors'
import {PrettyPrintableError} from '../../src/interfaces/errors'

function isPrettyPrintableError(error: any): error is PrettyPrintableError {
  return error.code !== undefined && error.ref !== undefined && error.suggestions !== undefined
}

describe('error', () => {
  it('throws an error using a string argument', () => {
    expect(() => {
      error('An error happened!')
    }).to.throw('An error happened!')
  })

  it('attaches pretty print properties to a new error from options', () => {
    try {
      error('An error happened!', {code: 'ERR', ref: 'https://oclif.com/error', suggestions: ['rm -rf node_modules']})
    } catch (error) {
      if (isPrettyPrintableError(error)) {
        expect(error.message).to.equal('An error happened!')
        expect(error.code).to.equal('ERR')
        expect(error.ref).to.equal('https://oclif.com/error')
        expect(error.suggestions).to.deep.equal(['rm -rf node_modules'])
      } else {
        throw new Error('error is not a PrettyPrintableError')
      }
    }
  })

  it('attached pretty print properties from options to an existing error object', () => {
    try {
      error(new Error('An existing error object error!'), {
        code: 'ERR',
        ref: 'https://oclif.com/error',
        suggestions: ['rm -rf node_modules'],
      })
    } catch (error) {
      if (isPrettyPrintableError(error)) {
        expect(error.message).to.equal('An existing error object error!')
        expect(error.code).to.equal('ERR')
        expect(error.ref).to.equal('https://oclif.com/error')
        expect(error.suggestions).to.deep.equal(['rm -rf node_modules'])
      } else {
        throw new Error('error is not a PrettyPrintableError')
      }
    }
  })

  it('preserves original pretty printable properties and is not overwritten by options', () => {
    const e: any = new Error('An existing error object error!')
    e.code = 'ORIG_ERR'
    e.ref = 'ORIG_REF'
    e.suggestions = ['ORIG_SUGGESTION']

    try {
      error(e, {code: 'ERR', ref: 'https://oclif.com/error', suggestions: ['rm -rf node_modules']})
    } catch (error) {
      if (isPrettyPrintableError(error)) {
        expect(error.code).to.equal('ORIG_ERR')
        expect(error.ref).to.equal('ORIG_REF')
        expect(error.suggestions).to.deep.equal(['ORIG_SUGGESTION'])
      } else {
        throw new Error('error is not a PrettyPrintableError')
      }
    }
  })

  it('does not rethrow error when exit: false option is set', async () => {
    const {stdout, stderr} = await captureOutput(async () =>
      error('an error is reported but is not rethrown', {exit: false}),
    )
    expect(stderr).to.contain('Error: an error is reported but is not rethrown')
    expect(stdout).to.be.empty
  })

  describe('applying oclif errors', () => {
    it('adds oclif exit code to errors by default', async () => {
      const {error: err} = await captureOutput(async () => error(new Error('An existing error object error!')))
      expect(err?.oclif?.exit).to.equal(2)
    })

    it('applies the exit property on options to the error object', async () => {
      const {error: err} = await captureOutput(async () =>
        error(new Error('An existing error object error!'), {exit: 9001}),
      )
      expect(err?.oclif?.exit).to.equal(9001)
    })

    it('preserves original oclif exitable error properties and is not overwritten by options', async () => {
      const {error: err} = await captureOutput(async () => {
        const e: any = new Error('An existing error object error!')
        e.oclif = {
          code: 'ORIG_EXIT_CODE',
        }

        error(e)
      })

      // @ts-expect-error because we intentionally added a property that doesn't exist on Error
      expect(err?.oclif?.code).to.equal('ORIG_EXIT_CODE')
    })
  })
})
````

## File: test/errors/handle.test.ts
````typescript
import {captureOutput} from '@oclif/test'
import {expect} from 'chai'
import process from 'node:process'
import sinon from 'sinon'

import {Command, Flags} from '../../src'
import {CLIError, ExitError, exit as exitErrorThrower} from '../../src/errors'
import {Exit, handle} from '../../src/errors/handle'
import * as Help from '../../src/help'

const x = process.platform === 'win32' ? 'Â»' : 'â€º'

describe('handle', () => {
  let exitStub: sinon.SinonStub

  beforeEach(() => {
    exitStub = sinon.stub(Exit, 'exit')
  })

  afterEach(() => {
    sinon.restore()
  })

  it('hides an exit error', async () => {
    const {stdout, stderr} = await captureOutput(() => handle(new ExitError(0)))
    expect(stdout).to.be.empty
    expect(stderr).to.be.empty
    expect(exitStub.firstCall.firstArg).to.equal(0)
  })

  it('prints error', async () => {
    const error = new Error('foo bar baz') as Error & {skipOclifErrorHandling: boolean}
    error.skipOclifErrorHandling = false

    const {stdout, stderr} = await captureOutput(() => handle(error))

    expect(stdout).to.be.empty
    expect(stderr).to.include('foo bar baz')
  })

  it('should not print error when skipOclifErrorHandling is true', async () => {
    const error = new Error('foo bar baz') as Error & {skipOclifErrorHandling: boolean}
    error.skipOclifErrorHandling = true
    const {stdout, stderr} = await captureOutput(() => handle(error))
    expect(stdout).to.be.empty
    expect(stderr).to.be.empty
  })

  it('logs error with symbol', async () => {
    const {stderr} = await captureOutput(() => handle(new CLIError('uh oh!')))
    expect(stderr).to.equal(` ${x}   Error: uh oh!\n`)
  })

  it('should use default exit code for Error (1)', async () => {
    const error = new Error('foo bar baz')
    const {stdout, stderr} = await captureOutput(() => handle(error))
    expect(stdout).to.be.empty
    expect(stderr).to.include('foo bar baz')
    expect(exitStub.firstCall.firstArg).to.equal(1)
  })

  it('should use default exit code for CLIError (2)', async () => {
    const error = new CLIError('foo bar baz')
    const {stdout, stderr} = await captureOutput(() => handle(error))
    expect(stdout).to.be.empty
    expect(stderr).to.include('foo bar baz')
    expect(exitStub.firstCall.firstArg).to.equal(2)
  })

  it('should use exit code provided by CLIError (0)', async () => {
    const error = new CLIError('foo bar baz', {exit: 0})
    const {stdout, stderr} = await captureOutput(() => handle(error))
    expect(stdout).to.be.empty
    expect(stderr).to.include('foo bar baz')
    expect(exitStub.firstCall.firstArg).to.equal(0)
  })

  it('should use exit code provided by CLIError (9999)', async () => {
    const error = new CLIError('foo bar baz', {exit: 9999})
    const {stdout, stderr} = await captureOutput(() => handle(error))
    expect(stdout).to.be.empty
    expect(stderr).to.include('foo bar baz')
    expect(exitStub.firstCall.firstArg).to.equal(9999)
  })

  it('should print help', async () => {
    class MyCommand extends Command {
      static flags = {
        foo: Flags.string(),
        bar: Flags.string(),
      }

      async run() {
        await this.parse(MyCommand)
      }
    }

    const classStubbedInstance = sinon.createStubInstance(Help.Help)
    const constructorStub = sinon.stub(Help, 'Help').returns(classStubbedInstance)
    await captureOutput(async () => {
      try {
        await MyCommand.run(['--DOES_NOT_EXIST'])
      } catch (error: any) {
        await handle(error)
      }
    })

    expect(constructorStub.calledOnce).to.be.true
    const [, options] = constructorStub.firstCall.args
    expect(options).to.deep.equal({
      sections: ['flags', 'usage', 'arguments'],
      sendToStderr: true,
    })
  })

  describe('exit', () => {
    it('exits without displaying anything', async () => {
      const {stdout, stderr} = await captureOutput(async () => {
        try {
          exitErrorThrower(9000)
        } catch (error: any) {
          await handle(error)
        }
      })

      expect(stdout).to.be.empty
      expect(stderr).to.be.empty
      expect(exitStub.firstCall.firstArg).to.equal(9000)
    })
  })
})
````

## File: test/errors/pretty-print.test.ts
````typescript
import ansis from 'ansis'
import {expect} from 'chai'

import {settings} from '../../src'
import {CLIError} from '../../src/errors'
import prettyPrint from '../../src/errors/errors/pretty-print'
import {PrettyPrintableError} from '../../src/interfaces/errors'

describe('pretty-print', () => {
  it('pretty prints an error', async () => {
    const sampleError: Error & PrettyPrintableError = new Error('Something very serious has gone wrong with the flags!')
    sampleError.ref = 'https://oclif.io/docs/flags'
    sampleError.code = 'OCLIF_BAD_FLAG'
    sampleError.suggestions = ['Try using using a good flag']

    expect(ansis.strip(prettyPrint(sampleError) ?? '')).to
      .equal(`    Error: Something very serious has gone wrong with the flags!
    Code: OCLIF_BAD_FLAG
    Try this: Try using using a good flag
    Reference: https://oclif.io/docs/flags`)
  })

  it('pretty prints multiple suggestions', async () => {
    const sampleError: Error & PrettyPrintableError = new Error('Something very serious has gone wrong with the flags!')
    sampleError.suggestions = ['Use a good flag', 'Use no flags']
    expect(ansis.strip(prettyPrint(sampleError) ?? '')).to
      .equal(`    Error: Something very serious has gone wrong with the flags!
    Try this:
      * Use a good flag
      * Use no flags`)
  })

  it('pretty prints with omitted fields', async () => {
    const sampleError = new Error('Something very serious has gone wrong with the flags!')

    expect(ansis.strip(prettyPrint(sampleError) ?? '')).to.equal(
      '    Error: Something very serious has gone wrong with the flags!',
    )
  })

  describe('CLI Error properties', () => {
    it('supports the bang property', async () => {
      class SampleCLIError extends CLIError {
        get bang() {
          return '>>>'
        }
      }

      const sampleError = new SampleCLIError('This is a CLI error')
      expect(ansis.strip(prettyPrint(sampleError) ?? '')).to.equal(' >>>   Error: This is a CLI error')
    })

    it("supports the 'name' message prefix property", async () => {
      const defaultBang = process.platform === 'win32' ? 'Â»' : 'â€º'
      const sampleError = new CLIError('This is a CLI error')
      sampleError.name = 'Errorz'
      expect(ansis.strip(prettyPrint(sampleError) ?? '')).to.equal(` ${defaultBang}   Errorz: This is a CLI error`)
    })
  })

  describe('settings.debug set to true', () => {
    let initialSettingsDebug: boolean | undefined

    beforeEach(() => {
      initialSettingsDebug = settings.debug
      settings.debug = true
    })

    afterEach(() => {
      settings.debug = initialSettingsDebug
    })

    it('shows the stack for an error', async () => {
      const error = new Error('oh no!')
      error.stack = 'this is the error stack property'
      expect(prettyPrint(error)).to.equal('this is the error stack property')
    })
  })
})
````

## File: test/errors/warn.test.ts
````typescript
import {captureOutput} from '@oclif/test'
import {expect} from 'chai'

import {warn} from '../../src/errors'

describe('warn', () => {
  it('warns', async () => {
    const {stderr} = await captureOutput(async () => warn('foo!'))
    expect(stderr).to.contain('Warning: foo!')
  })
})
````

## File: test/help/fixtures/fixtures.ts
````typescript
import {Command} from '../../../src'
import {Topic} from '../../../src/interfaces'

// apps

export class AppsCreate extends Command {
  static args = {}

  static description = 'this only shows up in command help under DESCRIPTION'

  static flags = {}

  static id = 'apps:create'

  static summary = 'Create an app'

  async run(): Promise<void> {
    'run'
  }
}

export class AppsDestroy extends Command {
  static args = {}

  static description = `Destroy an app
  this only shows up in command help under DESCRIPTION`

  static flags: Record<string, never> = {}

  static id = 'apps:destroy'

  async run(): Promise<void> {
    'run'
  }
}

export class AppsIndex extends Command {
  static args = {}

  static flags: Record<string, never> = {}

  static id = 'apps'

  static summary = 'List all apps (app index command)'

  async run(): Promise<void> {
    'run'
  }
}

export class AppsIndexWithDesc extends Command {
  static args = {}

  static description = `List all apps (app index command)
this only shows up in command help under DESCRIPTION`

  static flags: Record<string, never> = {}

  static id = 'apps'

  async run(): Promise<void> {
    'run'
  }
}

export const AppsTopic: Topic = {
  name: 'apps',
  description: 'This topic is for the apps topic',
}

// apps:admin

export const AppsAdminTopic: Topic = {
  name: 'apps:admin',
  description: 'This topic is for the apps topic',
}

export class AppsAdminIndex extends Command {
  static args = {}

  static description = `List of admins for an app
  this only shows up in command help under DESCRIPTION`

  static flags: Record<string, never> = {}

  static id = 'apps:admin'

  async run(): Promise<void> {
    'run'
  }
}

export class AppsAdminAdd extends Command {
  static args = {}

  static description = `Add user to an app
  this only shows up in command help under DESCRIPTION`

  static flags: Record<string, never> = {}

  static id = 'apps:admin:add'

  async run(): Promise<void> {
    'run'
  }
}

// db

export class DbCreate extends Command {
  static args = {}

  static description = `Create a db
  this only shows up in command help under DESCRIPTION`

  static flags = {}

  static id = 'db:create'

  async run(): Promise<void> {
    'run'
  }
}

export const DbTopic: Topic = {
  name: 'db',
  description: 'This topic is for the db topic',
}

// deprecateAliases
export class DeprecateAliases extends Command {
  static aliases = ['foo:bar:alias']

  static args = {}

  static deprecateAliases = true

  static flags = {}

  static id = 'foo:bar'

  async run(): Promise<void> {
    'run'
  }
}

export class LongDescription extends Command {
  static description =
    'This is a very long command description that should wrap after too many characters have been entered'

  static id = 'hello:world'

  async run(): Promise<void> {
    'run'
  }
}

export class CommandWithAliases extends Command {
  static aliases = ['bar', 'baz', 'qux']
  static description = 'This is a command with aliases'
  static id = 'foo'
  async run(): Promise<void> {
    'run'
  }
}
````

## File: test/help/_test-help-class-identifier.ts
````typescript
// `loadHelpClass` tests require an oclif project for testing so
// it is re-using the setup here to be able to do a lookup for
// this sample help class file in tests, although it is not needed
// for ../help itself.

import {HelpBase} from '../../src'

export class MyHelp extends HelpBase {
  getCommandHelpForReadme(): string {
    return 'help for readme'
  }

  async showCommandHelp(): Promise<void> {
    console.log('command help')
  }

  async showHelp(): Promise<void> {
    console.log('help')
  }
}
````

## File: test/help/_test-help-class.ts
````typescript
// `loadHelpClass` tests require an oclif project for testing so
// it is re-using the setup here to be able to do a lookup for
// this sample help class file in tests, although it is not needed
// for ../help itself.

import {HelpBase} from '../../src'

export default class CustomHelp extends HelpBase {
  getCommandHelpForReadme(): string {
    return 'help for readme'
  }

  async showCommandHelp(): Promise<void> {
    console.log('command help')
  }

  async showHelp(): Promise<void> {
    console.log('help')
  }
}
````

## File: test/help/docopts.test.ts
````typescript
import {expect} from 'chai'

import {Args, Flags} from '../../src'
import {DocOpts} from '../../src/help/docopts'

describe('doc opts', () => {
  it('shows required string field', async () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.string({
          name: 'testFlag',
          description: 'test',
          required: true,
          char: 'f',
        }),
      },
    } as any)
    expect(usage).to.contain(' -f <value>')
  })

  it('shows optional boolean field', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.boolean({
          name: 'testFlag',
          description: 'test',
          char: 'f',
        }),
      },
    } as any)
    // boolean fields don't have a value
    expect(usage).to.contain(' [-f]')
  })

  it('shows no short char', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.string({
          name: 'testFlag',
          description: 'test',
          options: ['a', 'b'],
        }),
      },
    } as any)
    expect(usage).to.contain(' [--testFlag a|b]')
  })

  it('shows url type', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
        }),
      },
    } as any)
    expect(usage).to.contain(' [-s <value>]')
  })

  it('does not show hidden args', () => {
    const usage = DocOpts.generate({
      args: {
        hiddenarg: Args.string({
          name: 'hiddenarg',
          hidden: true,
        }),
      },
    } as any)
    expect(usage.toLowerCase()).to.not.contain('hiddenarg')
  })

  it('does not show hidden type', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
          hidden: true,
        }),
      },
    } as any)
    expect(usage).to.not.contain(' [-s <value>]')
  })

  it('shows optional one-way depended fields', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          dependsOn: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' [-f <value> -s <value>]')
  })

  it('shows one-way depended field on required field', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
          required: true,
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          dependsOn: ['testFlag'],
        }),
      },
    } as any)
    // If a flag depends on a required flag, then it is optional.
    // So this should technically be "(-f <value> [-s <value>])" but
    // does that even make sense anymore since -f will always be there?
    // Maybe it should be just "-f <value> [-s <value>]""
    expect(usage).to.contain(' (-f <value> -s <value>)')
  })

  it('shows required one-way depended field on optional field', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          required: true,
          dependsOn: ['testFlag'],
        }),
      },
    } as any)
    // If the required flag depends on an optional, it isn't really optional.
    expect(usage).to.contain(' (-f <value> -s <value>)')
  })

  it('shows optional one-way exclusive fields', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          exclusive: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' [-f <value> | -s <value>]')
  })

  it('shows one-way exclusive field on required field', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
          required: true,
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          exclusive: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' (-f <value> | -s <value>)')
  })

  it('shows required one-way exclusive field on optional field', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          required: true,
          exclusive: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' (-f <value> | -s <value>)')
  })

  it('shows option one-way exclusive field on optional field', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          required: true,
          exclusive: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' (-f <value> | -s <value>)')
  })

  it('shows optional exclusive fields defined twice', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
          exclusive: ['testFlag2'],
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          exclusive: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' [-s <value> | -f <value>]')
  })

  it('shows optional two-way depended fields', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
          dependsOn: ['testFlag2'],
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          dependsOn: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' [-s <value> -f <value>]')
  })

  it('shows required two-way depended fields', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
          required: true,
          dependsOn: ['testFlag2'],
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          required: true,
          dependsOn: ['testFlag'],
        }),
      },
    } as any)
    expect(usage).to.contain(' (-s <value> -f <value>)')
  })

  it('is uses helpValues as expected', () => {
    const usage = DocOpts.generate({
      flags: {
        testFlag: Flags.url({
          name: 'testFlag',
          description: 'test',
          char: 's',
          required: true,
          helpValue: ['<test1>', '<test2>'],
          multiple: true,
        }),
        testFlag2: Flags.string({
          name: 'testFlag2',
          description: 'test',
          char: 'f',
          required: true,
          helpValue: '<test3>',
        }),
        testFlag3: Flags.string({
          name: 'testFlag3',
          description: 'test',
          char: 'g',
          required: true,
          multiple: true,
        }),
        testFlag4: Flags.string({
          name: 'testFlag4',
          description: 'test',
          char: 'p',
          required: true,
          options: ['option1', 'option2'],
        }),
      },
    } as any)
    expect(usage).to.contain('-s <test1>... <test2>... -f <test3> -g <value>... -p option1|option2')
  })
})
````

## File: test/help/format-command-with-options.test.ts
````typescript
import {expect} from 'chai'

import {Args, Config, Flags as flags} from '../../src'
import {makeCommandClass, makeLoadable, TestHelpWithOptions as TestHelp} from './help-test-utils'

const g: any = globalThis
g.oclif.columns = 80

describe('formatCommand', () => {
  let config: Config
  let help: TestHelp

  before(async () => {
    config = await Config.load(process.cwd())
  })

  beforeEach(() => {
    help = new TestHelp(config)
  })

  it('should handle multi-line help output', async () => {
    const cmd = await makeLoadable(
      makeCommandClass({
        aliases: ['app:init', 'create'],
        args: {
          // eslint-disable-next-line camelcase
          app_name: Args.string({description: 'app to use'}),
        },
        deprecateAliases: true,
        description: `first line
multiline help`,
        flags: {
          app: flags.string({char: 'a', hidden: true}),
          foo: flags.string({char: 'f', description: 'foobar'.repeat(18)}),
          force: flags.boolean({description: 'force  it '.repeat(15)}),
          ss: flags.boolean({description: 'newliney\n'.repeat(4)}),
          remote: flags.string({char: 'r'}),
          label: flags.string({char: 'l', helpLabel: '-l'}),
        },
        id: 'apps:create',
      }),
    )
    const output = help.formatCommand(cmd)
    expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [-f <value>] [--force] [--ss] [-r
    <value>] [-l <value>]

ARGUMENTS
  APP_NAME  app to use

OPTIONS
  -f, --foo=foo        foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoo
                       barfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobar
  -l=label
  -r, --remote=remote
      --force          force  it force  it force  it force  it force  it force
                       it force  it force  it force  it force  it force  it
                       force  it force  it force  it force  it
      --ss             newliney
                       newliney
                       newliney
                       newliney

DESCRIPTION
  multiline help

ALIASES
  $ oclif app:init
  $ oclif create`)
  })

  describe('arg and flag multiline handling', () => {
    it('should show args and flags side by side when their output do not exceed 4 lines ', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          aliases: ['app:init', 'create'],
          args: {
            // eslint-disable-next-line camelcase
            app_name: Args.string({description: 'app to use'.repeat(35)}),
          },
          description: 'description of apps:create',
          flags: {
            app: flags.string({char: 'a', hidden: true}),
            foo: flags.string({char: 'f', description: 'foobar'.repeat(15)}),
            force: flags.boolean({description: 'force  it '.repeat(15)}),
            ss: flags.boolean({description: 'newliney\n'.repeat(4)}),
            remote: flags.string({char: 'r'}),
          },
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [-f <value>] [--force] [--ss] [-r
    <value>]

ARGUMENTS
  APP_NAME
      app to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to use

OPTIONS
  -f, --foo=foo        foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoo
                       barfoobarfoobarfoobarfoobarfoobar
  -r, --remote=remote
      --force          force  it force  it force  it force  it force  it force
                       it force  it force  it force  it force  it force  it
                       force  it force  it force  it force  it
      --ss             newliney
                       newliney
                       newliney
                       newliney

ALIASES
  $ oclif app:init
  $ oclif create`)
    })

    it('should show stacked args and flags when the lines exceed 4', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          aliases: ['app:init', 'create'],
          args: {
            // eslint-disable-next-line camelcase
            app_name: Args.string({description: 'app to use'.repeat(35)}),
          },
          description: 'description of apps:create',
          flags: {
            app: flags.string({char: 'a', hidden: true}),
            foo: flags.string({char: 'f', description: 'foobar'.repeat(20)}),
            force: flags.boolean({description: 'force  it '.repeat(29)}),
            ss: flags.boolean({description: 'newliney\n'.repeat(5)}),
            remote: flags.string({char: 'r'}),
          },
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [-f <value>] [--force] [--ss] [-r
    <value>]

ARGUMENTS
  APP_NAME
      app to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to use

OPTIONS
  -f, --foo=foo
      foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
      arfoobarfoobarfoobarfoobarfoobarfoobarfoobar

  -r, --remote=remote

  --force
      force  it force  it force  it force  it force  it force  it force  it force
      it force  it force  it force  it force  it force  it force  it force  it
      force  it force  it force  it force  it force  it force  it force  it force
      it force  it force  it force  it force  it force  it force  it

  --ss
      newliney
      newliney
      newliney
      newliney
      newliney

ALIASES
  $ oclif app:init
  $ oclif create`)
    })
  })

  describe('description', () => {
    it(`should output command description with values after a \n newline character`, async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          aliases: ['app:init', 'create'],
          args: {
            // eslint-disable-next-line camelcase
            app_name: Args.string({description: 'app to use'}),
          },
          description: 'description of apps:create\nthese values are after and will show up in the command description',
          flags: {
            force: flags.boolean({description: 'forces'}),
          },
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [--force]

ARGUMENTS
  APP_NAME  app to use

OPTIONS
  --force  forces

DESCRIPTION
  these values are after and will show up in the command description

ALIASES
  $ oclif app:init
  $ oclif create`)
    })

    it('should render template string from description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          description: 'root part of the description\nThe <%= config.bin %> CLI has <%= command.id %>',
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create

DESCRIPTION
  The oclif CLI has apps:create`)
    })
  })

  describe('flags', () => {
    it('should output flag options', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          flags: {
            myenum: flags.string({
              options: ['a', 'b', 'c'],
            }),
          },
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--myenum a|b|c]

OPTIONS
  --myenum=a|b|c`)
    })

    it('should output default flag options', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          args: {
            arg1: Args.string({default: '.'}),
            arg2: Args.string({default: '.', description: 'arg2 desc'}),
            arg3: Args.string({description: 'arg3 desc'}),
          },
          flags: {
            flag1: flags.string({default: '.'}),
            flag2: flags.string({default: '.', description: 'flag2 desc'}),
            flag3: flags.string({description: 'flag3 desc'}),
          },
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [ARG1] [ARG2] [ARG3] [--flag1 <value>] [--flag2
    <value>] [--flag3 <value>]

ARGUMENTS
  ARG1  [default: .]
  ARG2  [default: .] arg2 desc
  ARG3  arg3 desc

OPTIONS
  --flag1=flag1  [default: .]
  --flag2=flag2  [default: .] flag2 desc
  --flag3=flag3  flag3 desc`)
    })

    it('should output with no options', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          flags: {
            opt: flags.boolean({allowNo: true}),
          },
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--opt]

OPTIONS
  --[no-]opt`)
    })
  })

  describe('args', () => {
    it('should output arg options', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          args: {
            arg1: Args.string({description: 'Show the options', options: ['option1', 'option2']}),
          },
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [ARG1]

ARGUMENTS
  ARG1  (option1|option2) Show the options`)
    })
  })

  describe('usage', () => {
    it('should output usage with templates', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          usage: '<%= command.id %> usage',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create usage`)
    })

    it('should output usage arrays with templates', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          usage: ['<%= config.id %>', '<%= command.id %> usage'],
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create
  $ oclif apps:create usage`)
    })

    it('should output default usage when not specified', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create`)
    })
  })

  describe('examples', () => {
    it('should output multiple examples', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['it handles a list of examples', 'more example text'],
          id: 'command',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif command

EXAMPLES
  it handles a list of examples

  more example text`)
    })

    it('should output a single example', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['it handles a single example'],
          id: 'command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif command

EXAMPLES
  it handles a single example`)
    })

    it('should output example using templates', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['the bin is <%= config.bin %>', 'the command id is <%= command.id %>'],
          id: 'oclif:command',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  the bin is oclif

  the command id is oclif:command`)
    })

    it('should format if command', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['<%= config.bin %> <%= command.id %> --help'],
          id: 'oclif:command',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  $ oclif oclif:command --help`)
    })

    it('should format if command with description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['Prints out help.\n<%= config.bin %> <%= command.id %> --help'],
          id: 'oclif:command',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  Prints out help.

    $ oclif oclif:command --help`)
    })

    it('should format example object', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: [{description: 'Prints out help.', command: '<%= config.bin %> <%= command.id %> --help'}],
          id: 'oclif:command',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  Prints out help.

    $ oclif oclif:command --help`)
    })
  })
})
````

## File: test/help/format-command.test.ts
````typescript
import {expect} from 'chai'

import {Args, Config, Flags as flags} from '../../src'
import {makeCommandClass, makeLoadable, TestHelp} from './help-test-utils'

const g: any = globalThis
g.oclif.columns = 80

describe('formatCommand', () => {
  let config: Config
  let help: TestHelp

  before(async () => {
    config = await Config.load(process.cwd())
  })

  beforeEach(() => {
    help = new TestHelp(config)
  })

  it('should handle multi-line help output', async () => {
    const cmd = await makeLoadable(
      makeCommandClass({
        id: 'apps:create',
        aliases: ['app:init', 'create'],
        description: `first line

multiline help`,
        enableJsonFlag: true,
        args: {
          // eslint-disable-next-line camelcase
          app_name: Args.string({description: 'app to use'}),
        },
        flags: {
          app: flags.string({char: 'a', hidden: true}),
          foo: flags.string({char: 'f', description: 'foobar'.repeat(18)}),
          force: flags.boolean({description: 'force  it '.repeat(15)}),
          ss: flags.boolean({description: 'newliney\n'.repeat(4)}),
          remote: flags.string({char: 'r'}),
          label: flags.string({char: 'l', helpLabel: '-l'}),
        },
      }),
    )

    const output = help.formatCommand(cmd)
    expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [--json] [-f <value>] [--force] [--ss]
    [-r <value>] [-l <value>]

ARGUMENTS
  APP_NAME  app to use

FLAGS
  -f, --foo=<value>     foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfo
                        obarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobar
  -l=<value>
  -r, --remote=<value>
      --force           force  it force  it force  it force  it force  it force
                        it force  it force  it force  it force  it force  it
                        force  it force  it force  it force  it
      --ss              newliney
                        newliney
                        newliney
                        newliney

GLOBAL FLAGS
  --json  Format output as json.

DESCRIPTION
  first line

  multiline help

ALIASES
  $ oclif app:init
  $ oclif create`)
  })

  it('should not list hidden arguments and flags', async () => {
    const cmd = await makeLoadable(
      makeCommandClass({
        id: 'apps:create',
        description: 'creates an app',
        args: {
          // eslint-disable-next-line camelcase
          app_name: Args.string({description: 'app to use', hidden: true}),
        },
        flags: {
          app: flags.string({char: 'a', hidden: true}),
          foo: flags.string({required: true}),
        },
      }),
    )

    const output = help.formatCommand(cmd)
    expect(output).to.equal(`USAGE
  $ oclif apps:create --foo <value>

FLAGS
  --foo=<value>  (required)

DESCRIPTION
  creates an app`)
  })

  describe('arg and flag multiline handling', () => {
    it('should show args and flags side by side when their output do not exceed 4 lines ', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          aliases: ['app:init', 'create'],
          description: 'description of apps:create',
          enableJsonFlag: true,
          args: {
            // eslint-disable-next-line camelcase
            app_name: Args.string({description: 'app to use'.repeat(35)}),
          },
          flags: {
            app: flags.string({char: 'a', hidden: true}),
            foo: flags.string({char: 'f', description: 'foobar'.repeat(15)}),
            force: flags.boolean({description: 'force  it '.repeat(15)}),
            ss: flags.boolean({description: 'newliney\n'.repeat(4)}),
            remote: flags.string({char: 'r'}),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [--json] [-f <value>] [--force] [--ss]
    [-r <value>]

ARGUMENTS
  APP_NAME
      app to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to use

FLAGS
  -f, --foo=<value>     foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfo
                        obarfoobarfoobarfoobarfoobarfoobar
  -r, --remote=<value>
      --force           force  it force  it force  it force  it force  it force
                        it force  it force  it force  it force  it force  it
                        force  it force  it force  it force  it
      --ss              newliney
                        newliney
                        newliney
                        newliney

GLOBAL FLAGS
  --json  Format output as json.

DESCRIPTION
  description of apps:create

ALIASES
  $ oclif app:init
  $ oclif create`)
    })

    it('should show stacked args and flags when the lines exceed 4', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          description: 'description of apps:create',
          aliases: ['app:init', 'create'],
          enableJsonFlag: true,
          args: {
            // eslint-disable-next-line camelcase
            app_name: Args.string({description: 'app to use'.repeat(35)}),
          },
          flags: {
            app: flags.string({char: 'a', hidden: true}),
            foo: flags.string({char: 'f', description: 'foobar'.repeat(20)}),
            force: flags.boolean({description: 'force  it '.repeat(29)}),
            ss: flags.boolean({description: 'newliney\n'.repeat(5)}),
            remote: flags.string({char: 'r'}),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [--json] [-f <value>] [--force] [--ss]
    [-r <value>]

ARGUMENTS
  APP_NAME
      app to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to useapp to useapp to useapp to
      useapp to useapp to useapp to useapp to useapp to useapp to useapp to useapp
      to useapp to useapp to useapp to useapp to use

FLAGS
  -f, --foo=<value>
      foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
      arfoobarfoobarfoobarfoobarfoobarfoobarfoobar

  -r, --remote=<value>

  --force
      force  it force  it force  it force  it force  it force  it force  it force
      it force  it force  it force  it force  it force  it force  it force  it
      force  it force  it force  it force  it force  it force  it force  it force
      it force  it force  it force  it force  it force  it force  it

  --ss
      newliney
      newliney
      newliney
      newliney
      newliney

GLOBAL FLAGS
  --json  Format output as json.

DESCRIPTION
  description of apps:create

ALIASES
  $ oclif app:init
  $ oclif create`)
    })
  })

  describe('summary', () => {
    it('should not show description header if only a summary', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'test:summary',
          summary: 'one line summary',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif test:summary`)
    })

    it('should output the summary at the top of the help and description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'test:summary',
          summary: 'one line summary',
          description: 'description that is much longer than the summary',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif test:summary

DESCRIPTION
  one line summary

  description that is much longer than the summary`)
    })
  })

  describe('description', () => {
    it(`should output the command description with the values after a \n newline character`, async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          description:
            'description of apps:create\n\nthese values are after and will show up in the command description',
          aliases: ['app:init', 'create'],
          enableJsonFlag: true,
          args: {
            // eslint-disable-next-line camelcase
            app_name: Args.string({description: 'app to use'}),
          },
          flags: {
            force: flags.boolean({description: 'forces'}),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [APP_NAME] [--json] [--force]

ARGUMENTS
  APP_NAME  app to use

FLAGS
  --force  forces

GLOBAL FLAGS
  --json  Format output as json.

DESCRIPTION
  description of apps:create

  these values are after and will show up in the command description

ALIASES
  $ oclif app:init
  $ oclif create`)
    })

    it('should render the template string from description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          description: 'root part of the description\n\nThe <%= config.bin %> CLI has <%= command.id %>',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create

DESCRIPTION
  root part of the description

  The oclif CLI has apps:create`)
    })

    it('should split on carriage return and new lines', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          description: 'root part of the description\r\n\nusing both carriage \n\nreturn and new line',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create

DESCRIPTION
  root part of the description

  using both carriage

  return and new line`)
    })
  })

  const myEnumValues = ['a', 'b', 'c']

  describe('flags', () => {
    it('should output flag enum', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            myenum: flags.string({
              description: 'the description',
              options: myEnumValues,
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--myenum a|b|c]

FLAGS
  --myenum=<option>  the description
                     <options: a|b|c>`)
    })

    it('should output flag enum with string helpValue', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            myenum: flags.string({
              options: myEnumValues,
              helpValue: myEnumValues.join('|'),
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--myenum a|b|c]

FLAGS
  --myenum=a|b|c`)
    })

    it('should output flag enum with array helpValue', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            myenum: flags.string({
              options: myEnumValues,
              helpValue: myEnumValues,
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--myenum a b c]

FLAGS
  --myenum=a b c`)
    })

    it('should output string helpValue in usage string', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            files: flags.string({
              helpValue: '<input-json>|<input-xml>',
              multiple: true,
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--files <input-json>|<input-xml>...]

FLAGS
  --files=<input-json>|<input-xml>...`)
    })

    it('should output array helpValue in usage string', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            files: flags.string({
              helpValue: ['<input-json>', '<input-xml>'],
              multiple: true,
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--files <input-json>... <input-xml>...]

FLAGS
  --files=<input-json>... <input-xml>...`)
    })

    it('should output with default flag options', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          args: {
            arg1: Args.string({default: '.'}),
            arg2: Args.string({default: '.', description: 'arg2 desc'}),
            arg3: Args.string({description: 'arg3 desc'}),
          },
          flags: {
            flag1: flags.string({default: '.'}),
            flag2: flags.string({default: '.', description: 'flag2 desc'}),
            flag3: flags.string({description: 'flag3 desc'}),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [ARG1] [ARG2] [ARG3] [--flag1 <value>] [--flag2
    <value>] [--flag3 <value>]

ARGUMENTS
  ARG1  [default: .]
  ARG2  [default: .] arg2 desc
  ARG3  arg3 desc

FLAGS
  --flag1=<value>  [default: .]
  --flag2=<value>  [default: .] flag2 desc
  --flag3=<value>  flag3 desc`)
    })

    it('should output flags with no options', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            opt: flags.boolean({allowNo: true}),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--opt]

FLAGS
  --[no-]opt`)
    })

    it('should output flag summary and description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            opt: flags.string({
              summary: 'one line summary',
              description: 'multiline\ndescription',
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--opt <value>]

FLAGS
  --opt=<value>  one line summary

FLAG DESCRIPTIONS
  --opt=<value>  one line summary

    multiline
    description`)
    })

    it('should output flag summary and single line description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            opt: flags.string({
              summary: 'one line summary',
              description: 'single line description',
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--opt <value>]

FLAGS
  --opt=<value>  one line summary

FLAG DESCRIPTIONS
  --opt=<value>  one line summary

    single line description`)
    })

    it('should output long flag summary and single line description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          flags: {
            opt: flags.string({
              summary: 'one line summary'.repeat(15),
              description: 'single line description',
            }),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [--opt <value>]

FLAGS
  --opt=<value>  one line summaryone line summaryone line summaryone line
                 summaryone line summaryone line summaryone line summaryone line
                 summaryone line summaryone line summaryone line summaryone line
                 summaryone line summaryone line summaryone line summary

FLAG DESCRIPTIONS
  --opt=<value>

    one line summaryone line summaryone line summaryone line summaryone line
    summaryone line summaryone line summaryone line summaryone line summaryone
    line summaryone line summaryone line summaryone line summaryone line
    summaryone line summary

    single line description`)
    })
  })

  describe('args', () => {
    it('should output with arg options', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          args: {
            arg1: Args.string({description: 'Show the options', options: ['option1', 'option2']}),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [ARG1]

ARGUMENTS
  ARG1  (option1|option2) Show the options`)
    })

    it('should output arg with ... if static is false', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          strict: false,
          args: {
            arg1: Args.string({description: 'Show the options'}),
          },
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create [ARG1...]

ARGUMENTS
  ARG1...  Show the options`)
    })
  })

  describe('usage', () => {
    it('should output usage with templates', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          usage: '<%= command.id %> usage',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create usage`)
    })

    it('should output usage arrays with templates', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          usage: ['<%= command.id %>', '<%= command.id %> usage'],
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create
  $ oclif apps:create usage`)
    })

    it('should output default usage when not specified', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create`)
    })

    it('should output usage with hardcoded command', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'apps:create',
          usage: ['apps:create'],
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif apps:create`)
    })

    it('should output default usage for single letter command', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'a',
          flags: {
            'a-flag': flags.string({char: 'a', options: ['a', 'aa', 'aaa']}),
          },
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif a [-a a|aa|aaa]

FLAGS
  -a, --a-flag=<option>  <options: a|aa|aaa>`)
    })

    it('should output usage for single letter command', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          id: 'a',
          flags: {
            'a-flag': flags.string({char: 'a', options: ['a', 'aa', 'aaa']}),
          },
          usage: 'a [-a a|aa|aaa]',
        }),
      )
      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif a [-a a|aa|aaa]

FLAGS
  -a, --a-flag=<option>  <options: a|aa|aaa>`)
    })
  })

  describe('examples', () => {
    it('should output multiple examples', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['it handles a list of examples', 'more example text'],
          id: 'command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif command

EXAMPLES
  it handles a list of examples

  more example text`)
    })

    it('should output a single example', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['it handles a single example'],
          id: 'command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif command

EXAMPLES
  it handles a single example`)
    })

    it('should output examples using templates', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['the bin is <%= config.bin %>', 'the command id is <%= command.id %>'],
          id: 'oclif:command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  the bin is oclif

  the command id is oclif:command`)
    })

    it('should format command', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['<%= config.bin %> <%= command.id %> --help'],
          id: 'oclif:command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  $ oclif oclif:command --help`)
    })

    it('should format command with description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: ['Prints out help.\n<%= config.bin %> <%= command.id %> --help'],
          id: 'oclif:command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  Prints out help.

    $ oclif oclif:command --help`)
    })

    it('should format command with description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: [
            'Prints out help.\n<%= config.bin %> <%= command.id %> --help\n<%= config.bin %> <%= command.id %> --help',
          ],
          id: 'oclif:command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  Prints out help.

    $ oclif oclif:command --help
    $ oclif oclif:command --help`)
    })

    it('should format example object', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: [{description: 'Prints out help.', command: '<%= config.bin %> <%= command.id %> --help'}],
          id: 'oclif:command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  Prints out help.

    $ oclif oclif:command --help`)
    })

    it('should format example object with long description', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: [{description: 'force  it '.repeat(15), command: '<%= config.bin %> <%= command.id %> --help'}],
          id: 'oclif:command',
        }),
      )

      const output = help.formatCommand(cmd)
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  force  it force  it force  it force  it force  it force  it force  it force
  it force  it force  it force  it force  it force  it force  it force  it

    $ oclif oclif:command --help`)
    })

    it('should format example object with long command', async () => {
      const cmd = await makeLoadable(
        makeCommandClass({
          examples: [
            {
              description: 'Prints out help.',
              command: '<%= config.bin %> <%= command.id %> ' + 'force  it '.repeat(15),
            },
          ],
          id: 'oclif:command',
        }),
      )

      const output = help.formatCommand(cmd)
      const multilineSeparator = config.platform === 'win32' ? (config.shell.includes('powershell') ? '`' : '^') : '\\'
      expect(output).to.equal(`USAGE
  $ oclif oclif:command

EXAMPLES
  Prints out help.

    $ oclif oclif:command force  it force  it force  it force  it force  it ${multilineSeparator}
      force  it force  it force  it force  it force  it force  it force  it ${multilineSeparator}
      force  it force  it force  it`)
    })
  })
})

describe('formatCommand with flagSortOrder', () => {
  let config: Config

  before(async () => {
    config = await Config.load(process.cwd())
  })

  it('should not sort flags when set to "none"', async () => {
    const help = new TestHelp(config, {flagSortOrder: 'none'})
    const cmd = await makeLoadable(
      makeCommandClass({
        id: 'apps:create',
        flags: {
          cFlag: flags.string({char: 'c'}),
          aFlag: flags.string({char: 'a'}),
          bFlag: flags.string({char: 'b'}),
        },
      }),
    )

    const output = help.formatCommand(cmd)
    expect(output).to.equal(`USAGE
  $ oclif apps:create [-c <value>] [-a <value>] [-b <value>]

FLAGS
  -c, --cFlag=<value>
  -a, --aFlag=<value>
  -b, --bFlag=<value>`)
  })

  it('should sort flags alphabetically when flagSortOrder is not set', async () => {
    const help = new TestHelp(config)
    const cmd = await makeLoadable(
      makeCommandClass({
        id: 'apps:create',
        flags: {
          cFlag: flags.string({char: 'c'}),
          aFlag: flags.string({char: 'a'}),
          bFlag: flags.string({char: 'b'}),
        },
      }),
    )

    const output = help.formatCommand(cmd)
    expect(output).to.equal(`USAGE
  $ oclif apps:create [-c <value>] [-a <value>] [-b <value>]

FLAGS
  -a, --aFlag=<value>
  -b, --bFlag=<value>
  -c, --cFlag=<value>`)
  })

  it('should sort flags alphabetically when flagSortOrder is invalid', async () => {
    // @ts-expect-error because we're testing an invalid flagSortOrder
    const help = new TestHelp(config, {flagSortOrder: 'INVALID'})
    const cmd = await makeLoadable(
      makeCommandClass({
        id: 'apps:create',
        flags: {
          cFlag: flags.string({char: 'c'}),
          aFlag: flags.string({char: 'a'}),
          bFlag: flags.string({char: 'b'}),
        },
      }),
    )

    const output = help.formatCommand(cmd)
    expect(output).to.equal(`USAGE
  $ oclif apps:create [-c <value>] [-a <value>] [-b <value>]

FLAGS
  -a, --aFlag=<value>
  -b, --bFlag=<value>
  -c, --cFlag=<value>`)
  })
})
````

## File: test/help/format-commands.test.ts
````typescript
import {expect} from 'chai'

import {Command} from '../../src/command'

const g: any = globalThis
g.oclif.columns = 80
import {Config} from '../../src'
import {Help} from '../../src/help'
import {AppsCreate, AppsDestroy, LongDescription} from './fixtures/fixtures'
import {makeLoadable} from './help-test-utils'

// extensions to expose method as public for testing
class TestHelp extends Help {
  constructor(public config: Config) {
    super(config, {stripAnsi: true})
  }

  public formatCommands(commands: Command.Loadable[]) {
    return super.formatCommands(commands)
  }
}

describe('formatCommand', () => {
  let config: Config
  let help: TestHelp

  before(async () => {
    config = await Config.load(process.cwd())
  })

  beforeEach(() => {
    help = new TestHelp(config)
  })

  it('should output an empty string when no commands are given', async () => {
    const output = help.formatCommands([])
    expect(output).to.equal('')
  })

  it('should show a list of the provided commands', async () => {
    const output = help.formatCommands([await makeLoadable(AppsDestroy), await makeLoadable(AppsCreate)])

    expect(output).to.equal(`COMMANDS
  apps:destroy  Destroy an app
  apps:create   Create an app`)
  })

  it('should handle wraps on long descriptions', async () => {
    const output = help.formatCommands([await makeLoadable(LongDescription)])

    expect(output).to.equal(`COMMANDS
  hello:world  This is a very long command description that should wrap after
               too many characters have been entered`)
  })
})
````

## File: test/help/format-root.test.ts
````typescript
import ansis from 'ansis'
import {expect} from 'chai'
import sinon from 'sinon'

import {Config} from '../../src'
import {Help} from '../../src/help'

const VERSION = require('../../package.json').version
const USER_AGENT = `@oclif/core/${VERSION} ${process.platform}-${process.arch} node-${process.version}`

describe('formatRoot', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  afterEach(() => {
    sinon.restore()
  })

  function getRootHelp(): string {
    // @ts-expect-error private member
    const root = new Help(config).formatRoot()
    return ansis
      .strip(root)
      .split('\n')
      .map((s) => s.trimEnd())
      .join('\n')
  }

  it('renders the root help', async () => {
    expect(getRootHelp()).to.equal(`base library for oclif CLIs

VERSION
  ${USER_AGENT}

USAGE
  $ oclif [COMMAND]`)
  })

  describe('description', () => {
    it(`splits on \n for the description into the top-level and description sections`, () => {
      sinon
        .stub(config.pjson, 'description')
        .value(
          'This is the top-level description that appears in the root\nThis appears in the description section after usage',
        )

      const output = getRootHelp()

      expect(output).to.equal(`This is the top-level description that appears in the root

VERSION
  ${USER_AGENT}

USAGE
  $ oclif [COMMAND]

DESCRIPTION
  This appears in the description section after usage`)
    })

    it('shows description from a template', () => {
      sinon
        .stub(config.pjson, 'description')
        .value(
          'This is the top-level description for <%= config.bin %>\nThis <%= config.bin %> appears in the description section after usage',
        )
      const output = getRootHelp()

      expect(output).to.equal(`This is the top-level description for oclif

VERSION
  ${USER_AGENT}

USAGE
  $ oclif [COMMAND]

DESCRIPTION
  This oclif appears in the description section after usage`)
    })

    it('prefers the oclif description over the package.json description', () => {
      sinon.stub(config.pjson, 'description').value('THIS IS THE PJSON DESCRIPTION')
      sinon.stub(config.pjson, 'oclif').value({
        ...config.pjson.oclif,
        description: 'THIS IS THE OCLIF DESCRIPTION IN PJSON',
      })
      const output = getRootHelp()

      expect(output).to.equal(`THIS IS THE OCLIF DESCRIPTION IN PJSON

VERSION
  ${USER_AGENT}

USAGE
  $ oclif [COMMAND]`)
    })

    it('uses package.json description when the oclif description is not set', () => {
      sinon.stub(config.pjson, 'description').value('THIS IS THE PJSON DESCRIPTION')
      sinon.stub(config.pjson, 'oclif').value({
        ...config.pjson.oclif,
        description: undefined,
      })
      const output = getRootHelp()

      expect(output).to.equal(`THIS IS THE PJSON DESCRIPTION

VERSION
  ${USER_AGENT}

USAGE
  $ oclif [COMMAND]`)
    })
  })
})
````

## File: test/help/format-topic.test.ts
````typescript
import ansis from 'ansis'
import {expect} from 'chai'

import {Config, Interfaces} from '../../src'
import {TestHelp} from './help-test-utils'

describe('formatHelp', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  function getTopicHelp(topic: Interfaces.Topic): string {
    const help = new TestHelp(config)
    const root = help.formatTopic(topic)
    return ansis
      .strip(root)
      .split('\n')
      .map((s) => s.trimEnd())
      .join('\n')
  }

  it('shows topic output', () => {
    const topic = {
      name: 'topic',
      description: 'this is a description of my topic',
      hidden: false,
    }
    const output = getTopicHelp(topic)
    expect(output).to.equal(`this is a description of my topic

USAGE
  $ oclif topic:COMMAND
`)
  })

  it('shows topic without a description', () => {
    const topic = {
      name: 'topic',
      hidden: false,
    }
    const output = getTopicHelp(topic)
    expect(output).to.equal(`USAGE
  $ oclif topic:COMMAND
`)
  })

  it(`shows topic descriptions split from \n for top-level and description section descriptions`, () => {
    const topic = {
      name: 'topic',
      hidden: false,
      description: 'This is the top level description\nDescription that shows up in the DESCRIPTION section',
    }
    const output = getTopicHelp(topic)
    expect(output).to.equal(`This is the top level description

USAGE
  $ oclif topic:COMMAND

DESCRIPTION
  Description that shows up in the DESCRIPTION section
`)
  })

  it(`shows templated topic descriptions split from \n for top-level and description section descriptions`, () => {
    const topic = {
      name: 'topic',
      hidden: false,
      description:
        '<%= config.bin %>: This is the top level description\n<%= config.bin %>: Description that shows up in the DESCRIPTION section',
    }
    const output = getTopicHelp(topic)
    expect(output).to.equal(`oclif: This is the top level description

USAGE
  $ oclif topic:COMMAND

DESCRIPTION
  oclif: Description that shows up in the DESCRIPTION section
`)
  })
})
````

## File: test/help/format-topics.test.ts
````typescript
import ansis from 'ansis'
import {expect} from 'chai'

import {Config, Interfaces} from '../../src'
import {TestHelp} from './help-test-utils'

describe('formatTopics', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  function getTopicsHelp(topic: Interfaces.Topic[]): string {
    const help = new TestHelp(config)
    const root = help.formatTopics(topic) ?? ''
    return ansis
      .strip(root)
      .split('\n')
      .map((s) => s.trimEnd())
      .join('\n')
  }

  it('shows a single topic in the list', () => {
    const topic = [
      {
        name: 'topic',
        description: 'this is a description of my topic',
      },
    ]
    const output = getTopicsHelp(topic)
    expect(output).to.equal(`TOPICS
  topic  this is a description of my topic`)
  })

  it('shows multiple topics in list', () => {
    const topic = [
      {
        name: 'topic',
        description: 'this is a description of my topic',
      },
      {
        name: 'othertopic',
        description: 'here we have a description for othertopic',
      },
      {
        name: 'thirdtopic',
        description: 'description for thirdtopic',
      },
    ]
    const output = getTopicsHelp(topic)
    expect(output).to.equal(`TOPICS
  topic       this is a description of my topic
  othertopic  here we have a description for othertopic
  thirdtopic  description for thirdtopic`)
  })
})
````

## File: test/help/help-test-utils.ts
````typescript
import ansis from 'ansis'

import {Interfaces} from '../../src'
import {Command} from '../../src/command'
import {CommandHelp, Help} from '../../src/help'
import {cacheCommand} from '../../src/util/cache-command'

export class TestCommandHelp extends CommandHelp {
  protected sections() {
    const sections = super.sections()
    const flagSection = sections.find((section) => section.header === 'FLAGS')
    if (flagSection) flagSection.header = 'OPTIONS'
    return sections
  }
}

// extensions to expose method as public for testing
export class TestHelpWithOptions extends Help {
  CommandHelpClass = TestCommandHelp

  constructor(config: Interfaces.Config, opts: Partial<Interfaces.HelpOptions> = {}) {
    super(config, opts)
    this.opts.showFlagNameInTitle = true
    this.opts.showFlagOptionsInTitle = true
    this.opts.hideCommandSummaryInDescription = true
  }

  public formatCommand(command: Command.Loadable) {
    return cleanOutput(super.formatCommand(command))
  }
}

// extensions to expose method as public for testing
export class TestHelp extends Help {
  public formatCommand(command: Command.Loadable) {
    return cleanOutput(super.formatCommand(command))
  }

  public formatTopic(topic: Interfaces.Topic) {
    return super.formatTopic(topic)
  }

  public formatTopics(topics: Interfaces.Topic[]) {
    return super.formatTopics(topics)
  }
}

function cleanOutput(output: string) {
  return ansis
    .strip(output)
    .split('\n')
    .map((s) => s.trimEnd())
    .join('\n')
}

export async function makeLoadable(command: Command.Class, plugin?: Interfaces.Plugin): Promise<Command.Loadable> {
  return {
    ...(await cacheCommand(command, plugin)),
    load: async () => command,
  }
}

export function makeCommandClass(cmdProps: Partial<Command.Class & Command.Loadable>): Command.Class {
  return class extends Command {
    async run(): Promise<void> {
      // do nothing
    }

    static {
      Object.assign(this, cmdProps)
    }
  }
}

export function monkeyPatchCommands(
  config: any,
  plugins: Array<{name: string; commands: Command.Class[]; topics: Interfaces.Topic[]}>,
  override: boolean = true,
) {
  const pluginsMap = new Map()
  for (const plugin of plugins) {
    pluginsMap.set(plugin.name, plugin)
  }

  config.plugins = pluginsMap
  if (override) {
    // // @ts-expect-error private member
    config._commands = new Map()
    // // @ts-expect-error private member
    config._topics = new Map()
  }

  for (const plugin of config.plugins.values()) {
    // // @ts-expect-error private method
    config.loadCommands(plugin)
    // // @ts-expect-error private method
    config.loadTopics(plugin)
  }
}
````

## File: test/help/show-customized-help.test.ts
````typescript
import {expect} from 'chai'

import {Config, Interfaces} from '../../src'
import {Command} from '../../src/command'
import {CommandHelp, Help} from '../../src/help'
import {AppsAdminAdd, AppsAdminTopic, AppsCreate, AppsDestroy, AppsIndexWithDesc, AppsTopic} from './fixtures/fixtures'
import {monkeyPatchCommands} from './help-test-utils'

// Allow overriding section headers
class TestCommandHelp extends CommandHelp {
  protected sections() {
    const sectionsToRemove = new Set(['DESCRIPTION'])
    let sections = super.sections()

    sections = sections.filter((section) => !sectionsToRemove.has(section.header))

    sections.push({
      header: 'CUSTOM',
      generate: () => `my custom section

${this.indent(this.wrap('force  it '.repeat(29)))}`,
    })
    return sections
  }
}

class TestHelp extends Help {
  CommandHelpClass = TestCommandHelp

  public declare config: Config
  public output: string[] = []
  constructor(config: Interfaces.Config, opts: Partial<Interfaces.HelpOptions> = {}) {
    opts.stripAnsi = true
    super(config, opts)
    this.opts.usageHeader = 'SYNOPSIS'
  }

  public getOutput() {
    return this.output.join('\n').trimEnd()
  }

  // push logs to this.output instead of logging to the console
  // this makes it easier to test the output
  protected log(...args: any[]) {
    this.output.push(...args)
  }

  public async showRootHelp() {
    return super.showRootHelp()
  }

  public async showTopicHelp(topic: Interfaces.Topic) {
    return super.showTopicHelp(topic)
  }

  summary(c: Command.Loadable): string {
    // This will essentially ignore the summary
    return this.wrap(c.description || '')
  }
}

describe('showHelp for root', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  it('shows a command and topic when the index has siblings', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsIndexWithDesc, AppsCreate, AppsDestroy],
        topics: [],
      },
    ])
    const help = new TestHelp(config)
    await help.showHelp([])
    const output = help.getOutput()
    expect(output).to.equal(`base library for oclif CLIs

VERSION
  ${config.userAgent}

SYNOPSIS
  $ oclif [COMMAND]

TOPICS
  apps  List all apps (app index command)

COMMANDS
  apps  List all apps (app index command)
        this only shows up in command help under DESCRIPTION`)
  })

  it('shows a command only when the topic only contains an index', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsIndexWithDesc],
        topics: [],
      },
    ])
    const help = new TestHelp(config)
    await help.showHelp([])
    const output = help.getOutput()
    expect(output).to.equal(`base library for oclif CLIs

VERSION
  ${config.userAgent}

SYNOPSIS
  $ oclif [COMMAND]

COMMANDS
  apps  List all apps (app index command)
        this only shows up in command help under DESCRIPTION`)
  })
})

describe('showHelp for a command', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  it('shows help for a leaf (or childless) command', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsCreate],
        topics: [AppsTopic],
      },
    ])

    const help = new TestHelp(config)
    await help.showHelp(['apps:create'])
    const output = help.getOutput()
    expect(output).to.equal(`this only shows up in command help under DESCRIPTION

SYNOPSIS
  $ oclif apps:create

CUSTOM
  my custom section

    force  it force  it force  it force  it force  it force  it force  it force
    it force  it force  it force  it force  it force  it force  it force  it force
    it force  it force  it force  it force  it force  it force  it force  it force
    it force  it force  it force  it force  it force  it`)
  })

  it('shows help for a command that has children topics and commands', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsIndexWithDesc, AppsCreate, AppsAdminAdd],
        topics: [AppsTopic, AppsAdminTopic],
      },
    ])

    const help = new TestHelp(config)
    await help.showHelp(['apps'])
    const output = help.getOutput()
    expect(output).to.equal(`List all apps (app index command)
this only shows up in command help under DESCRIPTION

SYNOPSIS
  $ oclif apps

CUSTOM
  my custom section

    force  it force  it force  it force  it force  it force  it force  it force
    it force  it force  it force  it force  it force  it force  it force  it force
    it force  it force  it force  it force  it force  it force  it force  it force
    it force  it force  it force  it force  it force  it

TOPICS
  apps:admin  This topic is for the apps topic

COMMANDS
  apps:create  this only shows up in command help under DESCRIPTION`)
  })
})
````

## File: test/help/show-help.test.ts
````typescript
import {expect} from 'chai'
import sinon from 'sinon'

import {Config, Interfaces} from '../../src'
import {Help} from '../../src/help'
import {
  AppsAdminAdd,
  AppsAdminIndex,
  AppsAdminTopic,
  AppsCreate,
  AppsDestroy,
  AppsIndex,
  AppsTopic,
  CommandWithAliases,
  DbCreate,
  DbTopic,
  DeprecateAliases,
} from './fixtures/fixtures'
import {monkeyPatchCommands} from './help-test-utils'

// extension makes previously protected methods public
class TestHelp extends Help {
  declare public config: Config
  public output: string[] = []

  constructor(config: Interfaces.Config, opts: Partial<Interfaces.HelpOptions> = {}) {
    opts.stripAnsi = true
    super(config, opts)
  }

  public getOutput() {
    return this.output.join('\n').trimEnd()
  }

  // push logs to this.output instead of logging to the console
  // this makes it easier to test the output
  protected log(...args: any[]) {
    this.output.push(...args)
  }

  public async showRootHelp() {
    return super.showRootHelp()
  }

  public async showTopicHelp(topic: Interfaces.Topic) {
    return super.showTopicHelp(topic)
  }
}

describe('showHelp for root', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  it('shows a command and topic when the index has siblings', async () => {
    monkeyPatchCommands(
      config,
      [
        {
          name: 'plugin-1',
          commands: [AppsIndex, AppsCreate, AppsDestroy],
          topics: [],
        },
      ],
      false,
    )
    const help = new TestHelp(config)
    await help.showHelp([])
    const output = help.getOutput()
    expect(output).to.equal(`base library for oclif CLIs

VERSION
  ${config.userAgent}

USAGE
  $ oclif [COMMAND]

TOPICS
  apps     List all apps (app index command)
  plugins  List installed plugins.

COMMANDS
  apps     List all apps (app index command)
  help     Display help for oclif.
  plugins  List installed plugins.`)
  })

  it('shows a command only when the topic only contains an index', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsIndex],
        topics: [],
      },
    ])
    const help = new TestHelp(config)
    await help.showHelp([])
    const output = help.getOutput()
    expect(output).to.equal(`base library for oclif CLIs

VERSION
  ${config.userAgent}

USAGE
  $ oclif [COMMAND]

COMMANDS
  apps  List all apps (app index command)`)
  })

  it('shows root help without aliases if hideAliasesFromRoot=true', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [CommandWithAliases],
        topics: [],
      },
    ])

    const help = new TestHelp(config as any, {hideAliasesFromRoot: true})
    await help.showHelp([])
    const output = help.getOutput()
    expect(output).to.equal(`base library for oclif CLIs

VERSION
  ${config.userAgent}

USAGE
  $ oclif [COMMAND]

COMMANDS
  foo  This is a command with aliases`)
  })

  it('shows root help with aliases commands by default', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [CommandWithAliases],
        topics: [],
      },
    ])

    const help = new TestHelp(config as any)
    await help.showHelp([])
    const output = help.getOutput()
    expect(output).to.equal(`base library for oclif CLIs

VERSION
  ${config.userAgent}

USAGE
  $ oclif [COMMAND]

COMMANDS
  bar  This is a command with aliases
  baz  This is a command with aliases
  foo  This is a command with aliases
  qux  This is a command with aliases`)
  })
})

describe('showHelp for a topic', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  it('shows topic help with commands', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsCreate, AppsDestroy],
        topics: [AppsTopic],
      },
    ])

    const help = new TestHelp(config as any)
    await help.showHelp(['apps'])
    const output = help.getOutput()
    expect(output).to.equal(`This topic is for the apps topic

USAGE
  $ oclif apps:COMMAND

COMMANDS
  apps:create   Create an app
  apps:destroy  Destroy an app`)
  })

  it('shows topic help with topic and commands', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsCreate, AppsDestroy, AppsAdminAdd],
        topics: [AppsTopic, AppsAdminTopic],
      },
    ])

    const help = new TestHelp(config as any)
    await help.showHelp(['apps'])
    const output = help.getOutput()
    expect(output).to.equal(`This topic is for the apps topic

USAGE
  $ oclif apps:COMMAND

TOPICS
  apps:admin  This topic is for the apps topic

COMMANDS
  apps:create   Create an app
  apps:destroy  Destroy an app`)
  })

  it('shows topic help with topic and commands and topic command', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsCreate, AppsDestroy, AppsAdminIndex, AppsAdminAdd],
        topics: [AppsTopic, AppsAdminTopic],
      },
    ])

    const help = new TestHelp(config as any)
    await help.showHelp(['apps'])
    const output = help.getOutput()
    expect(output).to.equal(`This topic is for the apps topic

USAGE
  $ oclif apps:COMMAND

TOPICS
  apps:admin  This topic is for the apps topic

COMMANDS
  apps:admin    List of admins for an app
  apps:create   Create an app
  apps:destroy  Destroy an app`)
  })

  it('ignores other topics and commands', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsCreate, AppsDestroy, AppsAdminAdd, DbCreate],
        topics: [AppsTopic, AppsAdminTopic, DbTopic],
      },
    ])

    const help = new TestHelp(config as any)
    await help.showHelp(['apps'])
    const output = help.getOutput()
    expect(output).to.equal(`This topic is for the apps topic

USAGE
  $ oclif apps:COMMAND

TOPICS
  apps:admin  This topic is for the apps topic

COMMANDS
  apps:create   Create an app
  apps:destroy  Destroy an app`)
  })

  it('show deprecation warning when using alias', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [DeprecateAliases],
        topics: [],
      },
    ])

    const help = new TestHelp(config as any)
    await help.showHelp(['foo:bar:alias'])
    const output = help.getOutput()
    expect(output).to.equal(`The "foo:bar:alias" command has been deprecated. Use "foo:bar" instead.

USAGE
  $ oclif foo:bar:alias

ALIASES
  $ oclif foo:bar:alias`)
  })
})

describe('showHelp for a command', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
  })

  it('shows help for a leaf (or childless) command', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsCreate],
        topics: [AppsTopic],
      },
    ])

    const help = new TestHelp(config)
    await help.showHelp(['apps:create'])
    const output = help.getOutput()
    expect(output).to.equal(`Create an app

USAGE
  $ oclif apps:create

DESCRIPTION
  Create an app

  this only shows up in command help under DESCRIPTION`)
  })

  it('shows help for a command that has children topics and commands', async () => {
    monkeyPatchCommands(config, [
      {
        name: 'plugin-1',
        commands: [AppsIndex, AppsCreate, AppsAdminAdd],
        topics: [AppsTopic, AppsAdminTopic],
      },
    ])

    const help = new TestHelp(config as any)
    await help.showHelp(['apps'])
    const output = help.getOutput()
    expect(output).to.equal(`List all apps (app index command)

USAGE
  $ oclif apps

TOPICS
  apps:admin  This topic is for the apps topic

COMMANDS
  apps:create  Create an app`)
  })
})

describe('showHelp routing', () => {
  let config: Config
  let help: TestHelp
  const stubs = {
    showRootHelp: sinon.stub(),
    showTopicHelp: sinon.stub(),
    showCommandHelp: sinon.stub(),
  }

  beforeEach(async () => {
    config = await Config.load()
    stubs.showCommandHelp = sinon.stub(TestHelp.prototype, 'showCommandHelp').resolves()
    stubs.showRootHelp = sinon.stub(TestHelp.prototype, 'showRootHelp').resolves()
    stubs.showTopicHelp = sinon.stub(TestHelp.prototype, 'showTopicHelp').resolves()
    help = new TestHelp(config)
  })

  afterEach(() => {
    sinon.restore()
  })

  describe('shows root help', () => {
    it('shows root help when no subject is provided', async () => {
      await help.showHelp([])
      expect(stubs.showRootHelp.called).to.be.true

      expect(stubs.showCommandHelp.called).to.be.false
      expect(stubs.showTopicHelp.called).to.be.false
    })

    it('shows root help when help is the only arg', async () => {
      await help.showHelp(['help'])
      expect(stubs.showRootHelp.called).to.be.true

      expect(stubs.showCommandHelp.called).to.be.false
      expect(stubs.showTopicHelp.called).to.be.false
    })
  })

  describe('shows topic help', () => {
    beforeEach(() => {
      sinon.stub(config, 'findCommand').returns(undefined)
    })

    it('shows the topic help when a topic has no matching command', async () => {
      await help.showHelp(['plugins'])
      expect(stubs.showTopicHelp.called).to.be.true

      expect(stubs.showRootHelp.called).to.be.false
      expect(stubs.showCommandHelp.called).to.be.false
    })

    it('shows the topic help when a topic has no matching command and is preceded by help', async () => {
      await help.showHelp(['help', 'plugins'])
      expect(stubs.showTopicHelp.called).to.be.true

      expect(stubs.showRootHelp.called).to.be.false
      expect(stubs.showCommandHelp.called).to.be.false
    })
  })

  describe('shows command help', () => {
    it('calls showCommandHelp when a topic that is also a command is called', async () => {
      await help.showHelp(['plugins'])
      expect(stubs.showCommandHelp.called).to.be.true

      expect(stubs.showRootHelp.called).to.be.false
      expect(stubs.showTopicHelp.called).to.be.false
    })

    it('calls showCommandHelp when a command is called', async () => {
      await help.showHelp(['plugins:install'])
      expect(stubs.showCommandHelp.called).to.be.true

      expect(stubs.showRootHelp.called).to.be.false
      expect(stubs.showTopicHelp.called).to.be.false
    })

    it('calls showCommandHelp when a command is preceded by the help arg', async () => {
      await help.showHelp(['help', 'plugins:install'])
      expect(stubs.showCommandHelp.called).to.be.true

      expect(stubs.showRootHelp.called).to.be.false
      expect(stubs.showTopicHelp.called).to.be.false
    })
  })

  describe('errors', () => {
    it('shows an error when there is a subject but it does not match a topic or command', async () => {
      await expect(help.showHelp(['meow'])).to.be.rejectedWith('Command meow not found')
    })
  })
})
````

## File: test/help/util.test.ts
````typescript
import {expect} from 'chai'
import {resolve} from 'node:path'
import sinon from 'sinon'

import {Args, Command, Config} from '../../src'
import * as util from '../../src/config/util'
import {loadHelpClass, standardizeIDFromArgv} from '../../src/help'
import configuredHelpClass from './_test-help-class'
import {MyHelp} from './_test-help-class-identifier'

describe('util', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load()
    config.topicSeparator = ' '
  })

  afterEach(() => {
    sinon.restore()
  })

  function stubCommands(...commands: Array<Partial<Command.Cached>>) {
    // @ts-expect-error private member
    sinon.stub(config, '_commands').value(new Map(commands.map((cmd) => [cmd.id, cmd])))
  }

  describe('#loadHelpClass', () => {
    it('defaults to the native help class', async () => {
      delete config.pjson.oclif.helpClass

      const helpClass = await loadHelpClass(config)
      expect(helpClass).not.be.undefined
      expect(helpClass.prototype.showHelp)
      expect(helpClass.prototype.showCommandHelp)
      expect(helpClass.prototype.formatRoot)
    })

    it('loads help class defined in pjson.oclif.helpClass', async () => {
      config.pjson.oclif.helpClass = '../test/help/_test-help-class'
      config.root = resolve(__dirname, '..')

      expect(configuredHelpClass).to.not.be.undefined
      expect(await loadHelpClass(config)).to.deep.equal(configuredHelpClass)
    })

    it('loads help class defined using target but no identifier', async () => {
      config.pjson.oclif.helpClass = {
        target: '../test/help/_test-help-class',
        // @ts-expect-error for testing purposes
        identifier: undefined,
      }
      config.root = resolve(__dirname, '..')

      expect(configuredHelpClass).to.not.be.undefined
      expect(await loadHelpClass(config)).to.deep.equal(configuredHelpClass)
    })

    it('loads help class defined using target and identifier', async () => {
      config.pjson.oclif.helpClass = {
        target: '../test/help/_test-help-class-identifier',
        identifier: 'MyHelp',
      }
      config.root = resolve(__dirname, '..')

      expect(MyHelp).to.not.be.undefined
      expect(await loadHelpClass(config)).to.deep.equal(MyHelp)
    })

    describe('error cases', () => {
      it('throws an error when failing to load the help class defined in pjson.oclif.helpClass', async () => {
        config.pjson.oclif.helpClass = './lib/does-not-exist-help-class'
        await expect(loadHelpClass(config)).to.be.rejectedWith(
          'Unable to load configured help class "./lib/does-not-exist-help-class", failed with message:',
        )
      })
    })
  })

  describe('#standardizeIDFromArgv', () => {
    it('should return standardized id when topic separator is a colon', () => {
      config.topicSeparator = ':'
      const actual = standardizeIDFromArgv(['foo:bar', '--baz'], config)
      expect(actual).to.deep.equal(['foo:bar', '--baz'])
    })

    it('should return standardized id when topic separator is a space', () => {
      const actual = standardizeIDFromArgv(['foo', '', '--baz'], config)
      expect(actual).to.deep.equal(['foo', '', '--baz'])
    })

    it('should return standardized id when topic separator is a space', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      const actual = standardizeIDFromArgv(['foo', 'bar', '--baz'], config)
      expect(actual).to.deep.equal(['foo:bar', '--baz'])
    })

    it('should return standardized id when topic separator is a space and command is misspelled', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      const actual = standardizeIDFromArgv(['foo', 'ba', '--baz'], config)
      expect(actual).to.deep.equal(['foo:ba', '--baz'])
    })

    it('should return standardized id when topic separator is a space and has args and command is misspelled', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        args: {
          name: Args.string(),
        },
      })
      const actual = standardizeIDFromArgv(['foo', 'ba', 'baz'], config)
      expect(actual).to.deep.equal(['foo:ba:baz'])
    })

    it('should return standardized id when topic separator is a space and has args', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        args: {
          name: Args.string(),
        },
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', 'baz'], config)
      expect(actual).to.deep.equal(['foo:bar', 'baz'])
    })

    it('should return standardized id when topic separator is a space and has variable arguments', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        strict: false,
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', 'baz'], config)
      expect(actual).to.deep.equal(['foo:bar', 'baz'])
    })

    it('should return standardized id when topic separator is a space and has variable arguments and flags', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        strict: false,
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', 'baz', '--hello'], config)
      expect(actual).to.deep.equal(['foo:bar', 'baz', '--hello'])
    })

    it('should return full id when topic separator is a space and does not have arguments', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        args: {},
        strict: true,
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', 'baz'], config)
      expect(actual).to.deep.equal(['foo:bar:baz'])
    })

    it('should return standardized id when topic separator is a space and has arg with value', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', 'hello=world'], config)
      expect(actual).to.deep.equal(['foo:bar', 'hello=world'])
    })

    it('should return standardized id when topic separator is a space and has variable args with value', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        strict: false,
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', 'hello=world', 'my-arg=value'], config)
      expect(actual).to.deep.equal(['foo:bar', 'hello=world', 'my-arg=value'])
    })

    it('should return standardized id when topic separator is a space and has flags', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        strict: false,
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', '--baz'], config)
      expect(actual).to.deep.equal(['foo:bar', '--baz'])
    })

    it('should return standardized id when topic separator is a space and has flags, arg, and arg with value', () => {
      sinon.stub(util, 'collectUsableIds').returns(new Set(['foo', 'foo:bar']))
      stubCommands({
        id: 'foo:bar',
        args: {
          'my-arg': Args.string(),
        },
        strict: true,
      })
      const actual = standardizeIDFromArgv(['foo', 'bar', 'my-arg', 'hello=world', '--baz'], config)
      expect(actual).to.deep.equal(['foo:bar', 'my-arg', 'hello=world', '--baz'])
    })
  })
})
````

## File: test/helpers/init.js
````javascript
const path = require('node:path')
process.env.TS_NODE_PROJECT = path.resolve('test/tsconfig.json')
process.env.NODE_ENV = 'test'

const chai = require('chai')
const chaiAsPromised = require('chai-as-promised')

chai.use(chaiAsPromised)

globalThis.oclif = globalThis.oclif || {}
globalThis.oclif.columns = 80
globalThis.columns = '80'
````

## File: test/integration/fixtures/tsconfig-tests/package.json
````json
{
  "name": "tsconfig-tests",
  "dependencies": {
    "@salesforce/dev-config": "4.1.0",
    "@tsconfig/strictest": "2.0.2"
  }
}
````

## File: test/integration/fixtures/tsconfig-tests/tsconfig-local-extends-local-extends-node-modules.json
````json
{
  "extends": "./tsconfig-local-extends-node-modules.json",
  "compilerOptions": {
    "tsconfig-local-extends-local-extends-node-modules": true
  },
  "ts-node": {
    "tsconfig-local-extends-local-extends-node-modules": true
  }
}
````

## File: test/integration/fixtures/tsconfig-tests/tsconfig-local-extends-local.json
````json
{
  "extends": "./tsconfig-local-no-extends.json",
  "compilerOptions": {
    "tsconfig-local-extends-local": true
  },
  "ts-node": {
    "tsconfig-local-extends-local": true
  }
}
````

## File: test/integration/fixtures/tsconfig-tests/tsconfig-local-extends-node-modules-extends-node-modules.json
````json
{
  "extends": "@salesforce/dev-config/tsconfig-strict.json",
  "compilerOptions": {
    "tsconfig-local-extends-local-extends-node-modules": true
  },
  "ts-node": {
    "tsconfig-local-extends-local-extends-node-modules": true
  }
}
````

## File: test/integration/fixtures/tsconfig-tests/tsconfig-local-extends-node-modules.json
````json
{
  "extends": "@tsconfig/strictest/tsconfig.json",
  "compilerOptions": {
    "tsconfig-local-extends-node-modules": true
  },
  "ts-node": {
    "tsconfig-local-extends-node-modules": true
  }
}
````

## File: test/integration/fixtures/tsconfig-tests/tsconfig-local-extends-non-existent.json
````json
{
  "extends": "DOES_NOT_EXIST.json",
  "compilerOptions": {
    "tsconfig-local-extends-non-existent": true
  },
  "ts-node": {
    "tsconfig-local-extends-non-existent": true
  }
}
````

## File: test/integration/fixtures/tsconfig-tests/tsconfig-local-no-extends.json
````json
{
  "compilerOptions": {
    "tsconfig-local-no-extends": true
  },
  "ts-node": {
    "tsconfig-local-no-extends": true
  }
}
````

## File: test/integration/interop-plugins-matrix.ts
````typescript
export type PluginConfig = {
  name: string
  command: string
  package: string
  repo: string
  commandText: string
  hookText: string
  expectJson: {
    whenProvided: {
      args: Record<string, string | boolean>
      flags: Record<string, string | boolean>
    }
    whenNotProvided: {
      args: Record<string, string | null | boolean>
      flags: Record<string, string | null | boolean>
    }
  }
}

const commonProps = {
  expectJson: {
    whenProvided: {
      args: {
        optionalArg: 'arg1',
        defaultArg: 'arg2',
        defaultFnArg: 'arg3',
      },
      flags: {
        optionalString: 'flag1',
        defaultString: 'flag2',
        defaultFnString: 'flag3',
        json: true,
      },
    },
    whenNotProvided: {
      args: {
        defaultArg: 'simple string default',
        defaultFnArg: 'async fn default',
      },
      flags: {
        defaultString: 'simple string default',
        defaultFnString: 'async fn default',
        json: true,
      },
    },
  },
}

export const plugins: Record<string, PluginConfig> = {
  esbuild: {
    name: 'plugin-test-esbuild',
    command: 'esbuild',
    package: '@oclif/plugin-test-esbuild',
    repo: 'https://github.com/oclif/plugin-test-esbuild',
    commandText: 'hello I am a bundled (esbuild) plugin',
    hookText: 'Greetings! from plugin-test-esbuild init hook',
    ...commonProps,
  },
  esm1: {
    name: 'plugin-test-esm-1',
    command: 'esm1',
    package: '@oclif/plugin-test-esm-1',
    repo: 'https://github.com/oclif/plugin-test-esm-1',
    commandText: 'hello I am an ESM plugin',
    hookText: 'Greetings! from plugin-test-esm-1 init hook',
    ...commonProps,
  },
  esm2: {
    name: 'plugin-test-esm-2',
    command: 'esm2',
    package: '@oclif/plugin-test-esm-2',
    repo: 'https://github.com/oclif/plugin-test-esm-2',
    commandText: 'hello I am an ESM plugin',
    hookText: 'Greetings! from plugin-test-esm-2 init hook',
    ...commonProps,
  },
  cjs1: {
    name: 'plugin-test-cjs-1',
    command: 'cjs1',
    package: '@oclif/plugin-test-cjs-1',
    repo: 'https://github.com/oclif/plugin-test-cjs-1',
    commandText: 'hello I am a CJS plugin',
    hookText: 'Greetings! from plugin-test-cjs-1 init hook',
    ...commonProps,
  },
  cjs2: {
    name: 'plugin-test-cjs-2',
    command: 'cjs2',
    package: '@oclif/plugin-test-cjs-2',
    repo: 'https://github.com/oclif/plugin-test-cjs-2',
    commandText: 'hello I am a CJS plugin',
    hookText: 'Greetings! from plugin-test-cjs-2 init hook',
    ...commonProps,
  },
  precore: {
    name: 'plugin-test-pre-core',
    command: 'pre-core',
    package: '@oclif/plugin-test-pre-core',
    repo: 'https://github.com/oclif/plugin-test-pre-core',
    commandText: 'hello I am a pre-core plugin',
    hookText: 'Greetings! from plugin-test-pre-core init hook',
    expectJson: {
      whenProvided: commonProps.expectJson.whenProvided,
      whenNotProvided: {
        args: {
          defaultArg: 'simple string default',
          defaultFnArg: 'fn default',
        },
        flags: {
          defaultString: 'simple string default',
          defaultFnString: 'fn default',
          json: true,
        },
      },
    },
  },
  coreV1: {
    name: 'plugin-test-core-v1',
    command: 'core-v1',
    package: '@oclif/plugin-test-core-v1',
    repo: 'https://github.com/oclif/plugin-test-core-v1',
    commandText: 'hello I am an @oclif/core@v1 plugin',
    hookText: 'Greetings! from plugin-test-core-v1 init hook',
    ...commonProps,
  },
  coreV2: {
    name: 'plugin-test-core-v2',
    command: 'core-v2',
    package: '@oclif/plugin-test-core-v2',
    repo: 'https://github.com/oclif/plugin-test-core-v2',
    commandText: 'hello I am an @oclif/core@v2 plugin',
    hookText: 'Greetings! from plugin-test-core-v2 init hook',
    ...commonProps,
  },
  coreV3: {
    name: 'plugin-test-core-v3',
    command: 'core-v3',
    package: '@oclif/plugin-test-core-v3',
    repo: 'https://github.com/oclif/plugin-test-core-v3',
    commandText: 'hello I am an @oclif/core@v3 plugin',
    hookText: 'Greetings! from plugin-test-core-v3 init hook',
    ...commonProps,
  },
}
````

## File: test/integration/interop.ts
````typescript
/**
 * These integration tests do not use mocha because we encountered an issue with
 * spawning child processes for testing root ESM plugins with linked ESM plugins.
 * This scenario works as expected when running outside of mocha.
 *
 * Instead of spending more time diagnosing the root cause, we are just going to
 * run these integration tests using ts-node and a lightweight homemade test runner.
 */
import ansis from 'ansis'
import {expect} from 'chai'
import fs from 'node:fs/promises'
import path from 'node:path'

import {Command, Flags, flush, handle} from '../../src'
import {PluginConfig, plugins} from './interop-plugins-matrix'
import {Executor, Script, setup} from './util'

const TESTS = ['cjs', 'esm', 'precore', 'coreV1', 'coreV2', 'coreV3', 'esbuild'] as const
const DEV_RUN_TIMES = ['default', 'bun', 'tsx'] as const

type Plugin = {
  name: string
  command: string
  package: string
  repo: string
}

type InstallPluginOptions = {
  executor: Executor
  plugin: Plugin
  script: Script
}

type LinkPluginOptions = {
  executor: Executor
  plugin: Plugin
  script: Script
  noLinkCore?: boolean
  useTsx?: boolean
}

type RunCommandOptions = {
  executor: Executor
  command: string
  script: Script
  expectStrings?: string[]
  expectJson?: Record<string, any>
  env?: Record<string, string>
  args?: Array<string | boolean>
}

type ModifyCommandOptions = {
  executor: Executor
  plugin: Plugin
  from: string
  to: string
}

type CleanUpOptions = {
  executor: Executor
  script: Script
  plugin: Plugin
}

async function installPlugin(options: InstallPluginOptions): Promise<void> {
  const result = await options.executor.executeCommand(`plugins:install ${options.plugin.package}`, options.script)
  expect(result.code).to.equal(0)

  const pluginsResult = await options.executor.executeCommand('plugins', options.script)
  expect(pluginsResult.stdout).to.include(options.plugin.name)
}

async function linkPlugin(options: LinkPluginOptions): Promise<Executor> {
  const pluginExecutor = await setup(__filename, {
    repo: options.plugin.repo,
    subDir: options.executor.parentDir,
    noLinkCore: options.noLinkCore ?? false,
    useTsx: options.useTsx,
  })

  const result = await options.executor.executeCommand(
    `plugins:link ${pluginExecutor.pluginDir} --no-install`,
    options.script,
  )
  expect(result.code).to.equal(0)

  const pluginsResult = await options.executor.executeCommand('plugins', options.script)
  expect(pluginsResult.stdout).to.include(options.plugin.name)

  return pluginExecutor
}

async function modifyCommand(options: ModifyCommandOptions): Promise<void> {
  const filePath = path.join(options.executor.pluginDir, 'src', 'commands', `${options.plugin.command}.ts`)
  const content = await fs.readFile(filePath, 'utf8')
  const modifiedContent = content.replace(options.from, options.to)
  await fs.writeFile(filePath, modifiedContent)
}

async function runCommand(options: RunCommandOptions): Promise<void> {
  const env = {...process.env, ...options.env}
  const result = await options.executor.executeCommand(
    `${options.command} ${options.args?.join(' ') ?? ''}`,
    options.script,
    {env},
  )
  expect(result.code).to.equal(0)

  if (options.expectStrings) {
    for (const expectString of options.expectStrings) {
      expect(result.stdout).to.include(expectString)
    }
  }

  if (options.expectJson && options.args?.includes('--json')) {
    // clear any non-json output from hooks
    const split = result.stdout?.split('\n') ?? []
    const idx = split.findIndex((i) => i.startsWith('{'))
    const json = JSON.parse(split.slice(idx).join('\n'))
    expect(json).to.deep.equal(options.expectJson)
  }
}

async function cleanUp(options: CleanUpOptions): Promise<void> {
  await options.executor.executeCommand(`plugins:uninstall ${options.plugin.package}`)
  const {stdout} = await options.executor.executeCommand('plugins')
  expect(stdout).to.not.include(options.plugin.package)
}

async function testRunner({
  tests,
  devRunTime,
}: {
  tests: Array<(typeof TESTS)[number]>
  devRunTime: (typeof DEV_RUN_TIMES)[number]
}): Promise<{failed: string[]; passed: string[]}> {
  const failed: string[] = []
  const passed: string[] = []

  async function test(name: string, fn: () => Promise<void>) {
    try {
      await fn()
      passed.push(name)
      console.log(ansis.green('âœ“'), name)
    } catch (error) {
      failed.push(name)
      console.log(ansis.red('ð„‚'), name)
      console.log(error)
    }
  }

  const devExecutable = (devRunTime === 'default' ? 'dev' : `${devRunTime} dev`) as 'dev' | 'bun dev' | 'tsx dev'

  let cjsExecutor: Executor
  let esmExecutor: Executor
  let esbuildExecutor: Executor

  const cjsBefore = async () => {
    cjsExecutor = await setup(__filename, {repo: plugins.cjs1.repo, subDir: 'cjs'})
  }

  const esmBefore = async () => {
    esmExecutor = await setup(__filename, {repo: plugins.esm1.repo, subDir: 'esm'})
  }

  const esbuildBefore = async () => {
    if (!cjsExecutor) await cjsBefore()
    if (!esmExecutor) await esmBefore()
    esbuildExecutor = await setup(__filename, {repo: plugins.esbuild.repo, subDir: 'esbuild'})
  }

  const precoreBefore = async () => {
    if (!cjsExecutor) await cjsBefore()
    if (!esmExecutor) await esmBefore()
  }

  const coreV1Before = async () => {
    if (!cjsExecutor) await cjsBefore()
    if (!esmExecutor) await esmBefore()
  }

  const coreV2Before = async () => {
    if (!cjsExecutor) await cjsBefore()
    if (!esmExecutor) await esmBefore()
  }

  const coreV3Before = async () => {
    if (!cjsExecutor) await cjsBefore()
    if (!esmExecutor) await esmBefore()
  }

  const installTest = async (plugin: PluginConfig, executor: Executor) => {
    await installPlugin({executor, plugin, script: 'run'})

    // test that the root plugin's bin/run can execute the installed plugin
    await runCommand({
      executor,
      command: plugin.command,
      script: 'run',
      expectStrings: [plugin.commandText],
    })

    // test that the root plugin's bin/run can execute the installed plugin
    // and that args and flags work as expected when no values are provided
    await runCommand({
      executor,
      command: plugin.command,
      script: 'run',
      args: ['--json'],
      expectJson: plugin.expectJson.whenNotProvided,
    })

    // test that the root plugin's bin/run can execute the installed plugin
    // and that args and flags work as expected when values are provided
    await runCommand({
      executor,
      command: plugin.command,
      script: 'run',
      args: [
        ...Object.values(plugin.expectJson.whenProvided.args),
        ...Object.entries(plugin.expectJson.whenProvided.flags).map(([flag, value]) => {
          if (flag === 'json') return '--json'
          return `--${flag} ${value}`
        }),
      ],
      expectJson: plugin.expectJson.whenProvided,
    })

    // test that the root plugin's bin/dev can execute the installed plugin
    await runCommand({
      executor,
      command: plugin.command,
      script: devExecutable,
      expectStrings: [plugin.commandText],
    })

    await cleanUp({executor, plugin, script: 'run'})
  }

  const linkTest = async (plugin: PluginConfig, executor: Executor, noLinkCore = false) => {
    const linkedPlugin = await linkPlugin({executor, plugin, script: 'run', noLinkCore, useTsx: devRunTime === 'tsx'})

    // test bin/run
    await runCommand({
      executor,
      command: plugin.command,
      script: 'run',
      expectStrings: [plugin.commandText, plugin.hookText],
    })
    // test un-compiled changes with bin/run
    await modifyCommand({executor: linkedPlugin, plugin, from: 'hello', to: 'howdy'})
    await runCommand({
      executor,
      command: plugin.command,
      script: 'run',
      expectStrings: ['howdy', plugin.hookText],
    })

    // test un-compiled changes with bin/dev
    await modifyCommand({executor: linkedPlugin, plugin, from: 'howdy', to: 'cheers'})
    await runCommand({
      executor,
      command: plugin.command,
      script: devExecutable,
      expectStrings: ['cheers', plugin.hookText],
    })

    await cleanUp({executor, plugin, script: 'run'})
  }

  const cjsTests = async () => {
    await test('Install CJS plugin to CJS root plugin', async () => {
      await installTest(plugins.cjs2, cjsExecutor)
    })

    await test('Install ESM plugin to CJS root plugin', async () => {
      await installTest(plugins.esm1, cjsExecutor)
    })

    await test('Link CJS plugin to CJS root plugin', async () => {
      await linkTest(plugins.cjs2, cjsExecutor)
    })

    await test('Link ESM plugin to CJS root plugin', async () => {
      // We don't use linkTest here because that would test that the
      // ESM plugin is auto-transpiled which we're not supporting at the moment.
      const plugin = plugins.esm2

      await linkPlugin({executor: cjsExecutor, plugin, script: 'run'})

      // test bin/run
      await runCommand({
        executor: cjsExecutor,
        command: plugin.command,
        script: 'run',
        expectStrings: [plugin.commandText, plugin.hookText],
      })

      // test bin/dev
      await runCommand({
        executor: cjsExecutor,
        command: plugin.command,
        script: devExecutable,
        expectStrings: [plugin.commandText, plugin.hookText],
      })

      await cleanUp({executor: cjsExecutor, plugin, script: 'run'})
    })
  }

  const esmTests = async () => {
    await test('Install CJS plugin to ESM root plugin', async () => {
      await installTest(plugins.cjs1, esmExecutor)
    })

    await test('Install ESM plugin to ESM root plugin', async () => {
      await installTest(plugins.esm2, esmExecutor)
    })

    await test('Link CJS plugin to ESM root plugin', async () => {
      await linkTest(plugins.cjs1, esmExecutor)
    })

    await test('Link ESM plugin to ESM root plugin', async () => {
      const plugin = plugins.esm2

      await linkPlugin({executor: esmExecutor, plugin, script: 'run'})
      // test bin/run
      await runCommand({
        executor: esmExecutor,
        command: plugin.command,
        script: 'run',
        expectStrings: [plugin.commandText, plugin.hookText],
      })

      // Skipping these because we decided to not support auto-transpiling ESM plugins at this time.
      // // test un-compiled changes with bin/run
      // await modifyCommand({executor: linkedPlugin, plugin, from: 'hello', to: 'howdy'})
      // await runCommand({
      //   executor: esmExecutor,
      //   command: plugin.command,
      //   script: 'run',
      //   expectStrings: ['howdy', plugin.hookText],
      //   env: {NODE_OPTIONS: '--loader=ts-node/esm'},
      // })
      // // test un-compiled changes with bin/dev
      // await modifyCommand({executor: linkedPlugin, plugin, from: 'howdy', to: 'cheers'})
      // await runCommand({
      //   executor: esmExecutor,
      //   command: plugin.command,
      //   script: 'dev',
      //   expectStrings: ['cheers', plugin.hookText],
      //   env: {NODE_OPTIONS: '--loader=ts-node/esm'},
      // })

      await cleanUp({executor: esmExecutor, plugin, script: 'run'})
    })
  }

  const preCoreTests = async () => {
    await test('Install pre-core plugin to ESM root plugin', async () => {
      await installTest(plugins.precore, esmExecutor)
    })

    await test('Install pre-core plugin to CJS root plugin', async () => {
      await installTest(plugins.precore, cjsExecutor)
    })

    await test('Link pre-core plugin to CJS root plugin', async () => {
      // Pass in true to skip linking the local version of @oclif/core
      // to the test pre-core plugin since it doesn't use core.
      await linkTest(plugins.precore, cjsExecutor, true)
    })

    await test('Link pre-core plugin to ESM root plugin', async () => {
      // Pass in true to skip linking the local version of @oclif/core
      // to the test pre-core plugin since it doesn't use core.
      await linkTest(plugins.precore, esmExecutor, true)
    })
  }

  const coreV1Tests = async () => {
    await test('Install core v1 plugin to ESM root plugin', async () => {
      await installTest(plugins.coreV1, esmExecutor)
    })

    await test('Install core v1 plugin to CJS root plugin', async () => {
      await installTest(plugins.coreV1, cjsExecutor)
    })

    await test('Link core v1 plugin to CJS root plugin', async () => {
      // Pass in true to skip linking the local version of @oclif/core
      // to plugin-test-core-v1. There are breaking changes to how
      // args are defined in a command so the plugin won't compile if
      // we link the local version of core.
      await linkTest(plugins.coreV1, cjsExecutor, true)
    })

    await test('Link core v1 plugin to ESM root plugin', async () => {
      // Pass in true to skip linking the local version of @oclif/core
      // to plugin-test-core-v1. There are breaking changes to how
      // args are defined in a command so the plugin won't compile if
      // we link the local version of core.
      await linkTest(plugins.coreV1, esmExecutor, true)
    })
  }

  const coreV2Tests = async () => {
    await test('Install core v2 plugin to ESM root plugin', async () => {
      await installTest(plugins.coreV2, esmExecutor)
    })

    await test('Install core v2 plugin to CJS root plugin', async () => {
      await installTest(plugins.coreV2, cjsExecutor)
    })

    await test('Link core v2 plugin to CJS root plugin', async () => {
      await linkTest(plugins.coreV2, cjsExecutor)
    })

    await test('Link core v2 plugin to ESM root plugin', async () => {
      await linkTest(plugins.coreV2, esmExecutor)
    })
  }

  const coreV3Tests = async () => {
    await test('Install core v3 plugin to ESM root plugin', async () => {
      await installTest(plugins.coreV3, esmExecutor)
    })

    await test('Install core v3 plugin to CJS root plugin', async () => {
      await installTest(plugins.coreV3, cjsExecutor)
    })

    await test('Link core v3 plugin to CJS root plugin', async () => {
      await linkTest(plugins.coreV3, cjsExecutor)
    })

    await test('Link core v3 plugin to ESM root plugin', async () => {
      await linkTest(plugins.coreV3, esmExecutor)
    })
  }

  const esbuildTests = async () => {
    await test('Run bundled commands and hooks from esbuild plugin', async () => {
      await runCommand({
        executor: esbuildExecutor,
        command: plugins.esm1.command,
        script: 'run',
        expectStrings: [plugins.esm1.commandText, plugins.esm1.hookText],
      })
    })

    await test('Install esbuild plugin to ESM root plugin', async () => {
      await installTest(plugins.esbuild, esmExecutor)
    })

    await test('Install esbuild plugin to CJS root plugin', async () => {
      await installTest(plugins.esbuild, cjsExecutor)
    })

    await test('Install ESM plugin to esbuild root plugin', async () => {
      await installTest(plugins.esm2, esbuildExecutor)
    })

    await test('Install CJS plugin to esbuild root plugin', async () => {
      await installTest(plugins.cjs1, esbuildExecutor)
    })
  }

  if (tests.includes('cjs')) await cjsBefore()
  if (tests.includes('esm')) await esmBefore()
  if (tests.includes('precore')) await precoreBefore()
  if (tests.includes('coreV1')) await coreV1Before()
  if (tests.includes('coreV2')) await coreV2Before()
  if (tests.includes('coreV3')) await coreV3Before()
  if (tests.includes('esbuild')) await esbuildBefore()

  if (tests.includes('cjs')) await cjsTests()
  if (tests.includes('esm')) await esmTests()
  if (tests.includes('precore')) await preCoreTests()
  if (tests.includes('coreV1')) await coreV1Tests()
  if (tests.includes('coreV2')) await coreV2Tests()
  if (tests.includes('coreV3')) await coreV3Tests()
  if (tests.includes('esbuild')) await esbuildTests()

  return {passed, failed}
}

class InteropTest extends Command {
  static description = 'Execute interoperability tests'
  static flags = {
    test: Flags.option({
      description: 'Run a specific test',
      options: TESTS,
      required: true,
      multiple: true,
    })(),
    'dev-run-time': Flags.option({
      description: 'Set the dev runtime to use when executing bin/dev.js',
      options: DEV_RUN_TIMES,
      default: 'default',
    })(),
  }

  public async run(): Promise<void> {
    const {flags} = await this.parse(InteropTest)

    this.log('Node version:', process.version)
    this.log('Running tests:', flags.test.join(', '))
    this.log('Dev runtime:', flags['dev-run-time'])

    const results = await testRunner({tests: flags.test, devRunTime: flags['dev-run-time']})

    this.processResults(results)
  }

  private processResults({failed, passed}: {failed: string[]; passed: string[]}): never {
    this.log()
    this.log(ansis.bold('#### Summary ####'))

    for (const name of passed) this.log(ansis.green('âœ“'), name)

    for (const name of failed) this.log(ansis.red('ð„‚'), name)

    this.log(`${ansis.green('Passed:')} ${passed.length}`)
    this.log(`${ansis.red('Failed:')} ${failed.length}`)

    this.exit(failed.length)
  }
}

;(async () => {
  InteropTest.run().then(
    async () => flush(),
    async (error) => handle(error),
  )
})()
````

## File: test/integration/sf.integration.ts
````typescript
import ansis from 'ansis'
import {expect} from 'chai'
import {arch} from 'node:os'

import {Executor, setup} from './util'

function parseJson(json: string) {
  return JSON.parse(ansis.strip(json))
}

describe('Salesforce CLI (sf)', () => {
  let executor: Executor

  before(async () => {
    process.env.SF_TELEMETRY_DISABLE_ACKNOWLEDGEMENT = 'true'
    executor = await setup(__filename, {
      repo: 'https://github.com/salesforcecli/cli',
    })
  })

  it('should show custom help', async () => {
    const help = await executor.executeCommand('deploy metadata --help')
    /**
     * Regex matches that the help output matches this form:
     *
     * @example
     * <summary>
     *
     * USAGE
     *   <usage>
     *
     * FLAGS
     *   <flags>
     *
     * GLOBAL FLAGS
     *   <global flags>
     *
     * DESCRIPTION
     *   <description>
     *
     * EXAMPLES
     *   <examples>
     *
     * FLAG DESCRIPTIONS
     *   <flag descriptions>
     *
     * CONFIGURATION VARIABLES
     *   <configuration variables>
     *
     * ENVIRONMENT VARIABLES
     *   <environment variables>
     */
    const regex =
      /^.*?USAGE.*?FLAGS.*?GLOBAL FLAGS.*?DESCRIPTION.*?EXAMPLES.*?FLAG DESCRIPTIONS.*?CONFIGURATION VARIABLES.*?ENVIRONMENT VARIABLES.*$/gs
    expect(regex.test(help.stdout!)).to.be.true
  })

  it('should show custom short help', async () => {
    const help = await executor.executeCommand('deploy metadata -h')
    /**
     * Regex matches that the short help output matches this form:
     *
     * @example
     * <summary>
     *
     * USAGE
     *   <usage>
     *
     * FLAGS
     *   <flags>
     *
     * GLOBAL FLAGS
     *   <global flags>
     */
    const regex =
      /^.*?USAGE.*?FLAGS.*?GLOBAL FLAGS.*?(?!DESCRIPTION).*?(?!EXAMPLES).*?(?!FLAG DESCRIPTIONS).*?(?!CONFIGURATION VARIABLES).*?(?!ENVIRONMENT VARIABLES).*$/gs
    expect(regex.test(help.stdout!)).to.be.true
  })

  it('should show version using -v', async () => {
    const version = await executor.executeCommand('-v')
    expect(version.stdout).to.include('@salesforce/cli')
    expect(version.stdout).to.include(process.platform)
    expect(version.stdout).to.include(arch())
    expect(version.stdout).to.include(process.version)
  })

  it('should have formatted json success output', async () => {
    const config = await executor.executeCommand('config list --json')
    const result = parseJson(config.stdout!)
    expect(result).to.have.property('status')
    expect(result).to.have.property('result')
    expect(result).to.have.property('warnings')
  })

  it('should have formatted json error output', async () => {
    const config = await executor.executeCommand('config set DOES_NOT_EXIST --json')
    const result = parseJson(config.stdout!)
    expect(result).to.have.property('status')
    expect(result).to.have.property('stack')
    expect(result).to.have.property('name')
    expect(result).to.have.property('message')
    expect(result).to.have.property('warnings')
  })

  it('should handle varargs', async () => {
    const config = await executor.executeCommand(
      'config set disable-telemetry=true org-api-version=54.0 --global --json',
    )
    const parsed = parseJson(config.stdout!)
    expect(parsed.status).to.equal(0)
    const results = parsed.result as {successes: Array<{success: boolean}>; failures: Array<{failed: boolean}>}
    for (const result of results.successes) {
      expect(result.success).to.be.true
    }

    expect(results.failures).to.be.empty

    const unset = await executor.executeCommand('config unset disable-telemetry org-api-version --global --json')
    const unsetParsed = parseJson(unset.stdout!)
    expect(unsetParsed.status).to.equal(0)
  })
})
````

## File: test/integration/tsconfig.integration.ts
````typescript
import {expect} from 'chai'
import {basename} from 'node:path'

import {readTSConfig} from '../../src/util/read-tsconfig'
import {Executor} from './util'

describe('tsconfig integration', () => {
  const executor = new Executor({
    pluginDir: 'test/integration/fixtures/tsconfig-tests',
    testFileName: basename(__filename),
  })

  before(async () => {
    await executor.executeInTestDir('yarn')
  })

  it('should read local', async () => {
    const tsconfig = await readTSConfig(executor.pluginDir, 'tsconfig-local-no-extends.json')
    expect(tsconfig).to.deep.equal({
      compilerOptions: {
        'tsconfig-local-no-extends': true,
      },
      'ts-node': {
        'tsconfig-local-no-extends': true,
      },
    })
  })

  it('should read local -> local', async () => {
    const tsconfig = await readTSConfig(executor.pluginDir, 'tsconfig-local-extends-local.json')
    expect(tsconfig).to.deep.equal({
      compilerOptions: {
        'tsconfig-local-extends-local': true,
        'tsconfig-local-no-extends': true,
      },
      'ts-node': {
        'tsconfig-local-extends-local': true,
        'tsconfig-local-no-extends': true,
      },
    })
  })

  it('should read local -> node_modules', async () => {
    const tsconfig = await readTSConfig(executor.pluginDir, 'tsconfig-local-extends-node-modules.json')
    expect(tsconfig).to.deep.equal({
      compilerOptions: {
        forceConsistentCasingInFileNames: true,
        skipLibCheck: true,
        esModuleInterop: true,
        checkJs: true,
        isolatedModules: true,
        noUnusedParameters: true,
        noUnusedLocals: true,
        noUncheckedIndexedAccess: true,
        noPropertyAccessFromIndexSignature: true,
        noImplicitReturns: true,
        noImplicitOverride: true,
        noFallthroughCasesInSwitch: true,
        exactOptionalPropertyTypes: true,
        allowUnreachableCode: false,
        allowUnusedLabels: false,
        strict: true,
        'tsconfig-local-extends-node-modules': true,
      },
      'ts-node': {'tsconfig-local-extends-node-modules': true},
    })
  })

  it('should read local -> local -> node_modules', async () => {
    const tsconfig = await readTSConfig(executor.pluginDir, 'tsconfig-local-extends-local-extends-node-modules.json')
    expect(tsconfig).to.deep.equal({
      compilerOptions: {
        forceConsistentCasingInFileNames: true,
        skipLibCheck: true,
        esModuleInterop: true,
        checkJs: true,
        isolatedModules: true,
        noUnusedParameters: true,
        noUnusedLocals: true,
        noUncheckedIndexedAccess: true,
        noPropertyAccessFromIndexSignature: true,
        noImplicitReturns: true,
        noImplicitOverride: true,
        noFallthroughCasesInSwitch: true,
        exactOptionalPropertyTypes: true,
        allowUnreachableCode: false,
        allowUnusedLabels: false,
        strict: true,
        'tsconfig-local-extends-local-extends-node-modules': true,
        'tsconfig-local-extends-node-modules': true,
      },
      'ts-node': {
        'tsconfig-local-extends-local-extends-node-modules': true,
        'tsconfig-local-extends-node-modules': true,
      },
    })
  })

  it('should read local -> node_modules -> local node_modules', async () => {
    const tsconfig = await readTSConfig(executor.pluginDir, 'tsconfig-local-extends-local-extends-node-modules.json')
    expect(tsconfig).to.deep.equal({
      compilerOptions: {
        forceConsistentCasingInFileNames: true,
        skipLibCheck: true,
        esModuleInterop: true,
        checkJs: true,
        isolatedModules: true,
        noUnusedParameters: true,
        noUnusedLocals: true,
        noUncheckedIndexedAccess: true,
        noPropertyAccessFromIndexSignature: true,
        noImplicitReturns: true,
        noImplicitOverride: true,
        noFallthroughCasesInSwitch: true,
        exactOptionalPropertyTypes: true,
        allowUnreachableCode: false,
        allowUnusedLabels: false,
        strict: true,
        'tsconfig-local-extends-node-modules': true,
        'tsconfig-local-extends-local-extends-node-modules': true,
      },
      'ts-node': {
        'tsconfig-local-extends-node-modules': true,
        'tsconfig-local-extends-local-extends-node-modules': true,
      },
    })
  })

  it('should read local -> non-existent', async () => {
    const tsconfig = await readTSConfig(executor.pluginDir, 'tsconfig-local-extends-non-existent.json')
    expect(tsconfig).to.deep.equal({
      compilerOptions: {
        'tsconfig-local-extends-non-existent': true,
      },
      'ts-node': {
        'tsconfig-local-extends-non-existent': true,
      },
    })
  })

  it('should return empty tsconfig for non-existent', async () => {
    const tsconfig = await readTSConfig(executor.pluginDir, 'tsconfig-non-existent.json')
    expect(tsconfig).to.deep.equal({
      compilerOptions: {},
      'ts-node': {},
    })
  })
})
````

## File: test/integration/util.ts
````typescript
import ansis from 'ansis'
import {ExecException, execSync, ExecSyncOptionsWithBufferEncoding} from 'node:child_process'
import {existsSync, readFileSync, writeFileSync} from 'node:fs'
import {mkdir, rm} from 'node:fs/promises'
import {tmpdir} from 'node:os'
import {basename, dirname, join, resolve} from 'node:path'

import {Interfaces} from '../../src'

const debug = require('debug')('integration')

export type ExecError = ExecException & {stderr: string; stdout: string}

export type Result = {
  code: number
  stdout?: string
  stderr?: string
  error?: ExecError
}

export type SetupOptions = {
  repo: string
  branch?: string
  plugins?: string[]
  subDir?: string
  noLinkCore?: boolean
  useTsx?: boolean | undefined
}

export type ExecutorOptions = {
  pluginDir: string
  testFileName: string
}

export type ExecOptions = ExecSyncOptionsWithBufferEncoding & {silent?: boolean}

export type Script = 'run' | 'dev' | 'bun dev' | 'tsx dev'

function updatePkgJson(testDir: string, obj: Record<string, unknown>): Interfaces.PJSON {
  const pkgJsonFile = join(testDir, 'package.json')
  const pkgJson = JSON.parse(readFileSync(pkgJsonFile, 'utf8'))
  obj.dependencies = Object.assign(pkgJson.dependencies || {}, obj.dependencies || {})
  obj.resolutions = Object.assign(pkgJson.resolutions || {}, obj.resolutions || {})
  obj.devDependencies = Object.assign(pkgJson.devDependencies || {}, obj.devDependencies || {})
  const updated = Object.assign(pkgJson, obj)
  writeFileSync(pkgJsonFile, JSON.stringify(updated, null, 2))

  return updated
}

export class Executor {
  public debug: (...args: any[]) => void
  public parentDir: string
  public pluginDir: string
  public pluginName: string
  public testFileName: string

  public usesJsScript = false

  public constructor(options: ExecutorOptions) {
    this.pluginDir = options.pluginDir
    this.testFileName = options.testFileName
    this.parentDir = basename(dirname(this.pluginDir))
    this.pluginName = basename(this.pluginDir)
    this.usesJsScript = existsSync(join(this.pluginDir, 'bin', 'run.js'))
    this.debug = debug.extend(`${this.testFileName}:${this.parentDir}:${this.pluginName}`)
  }

  public clone(repo: string, branch?: string): Promise<Result> {
    const cmd = branch
      ? `git clone --branch ${branch} ${repo} ${this.pluginDir} --depth 1`
      : `git clone ${repo} ${this.pluginDir} --depth 1`
    const result = this.exec(cmd)
    this.usesJsScript = existsSync(join(this.pluginDir, 'bin', 'run.js'))
    return result
  }

  public exec(cmd: string, options?: ExecOptions): Promise<Result> {
    const cwd = options?.cwd ?? process.cwd()
    const silent = options?.silent ?? true
    return new Promise((resolve) => {
      this.debug(cmd, ansis.dim(`(cwd: ${cwd})`))
      if (silent) {
        try {
          const r = execSync(cmd, {...options, stdio: 'pipe', cwd})
          const stdout = r.toString()
          this.debug(stdout)
          resolve({code: 0, stdout})
        } catch (error) {
          const err = error as ExecError
          this.debug('stdout', err.stdout.toString())
          this.debug('stderr', err.stderr.toString())
          resolve({
            code: 1,
            error: err,
            stdout: err.stdout.toString(),
            stderr: err.stderr.toString(),
          })
        }
      } else {
        execSync(cmd, {...options, stdio: 'inherit', cwd})
        resolve({code: 0})
      }
    })
  }

  public executeCommand(cmd: string, script: Script = 'run', options: ExecOptions = {}): Promise<Result> {
    if (script.includes(' ')) {
      const [runtime, theScript] = script.split(' ')
      const executable =
        process.platform === 'win32'
          ? join('bin', `${theScript}.cmd`)
          : join('bin', `${theScript}${this.usesJsScript ? '.js' : ''}`)
      return this.executeInTestDir(`${runtime} ${executable} ${cmd}`, options)
    }

    const executable =
      process.platform === 'win32'
        ? join('bin', `${script}.cmd`)
        : join('bin', `${script}${this.usesJsScript ? '.js' : ''}`)
    return this.executeInTestDir(`${executable} ${cmd}`, options)
  }

  public executeInTestDir(cmd: string, options?: ExecOptions): Promise<Result> {
    return this.exec(cmd, {...options, cwd: this.pluginDir} as ExecOptions)
  }
}

/**
 * Setup for integration tests.
 *
 * Clones the requested repo from github
 * Adds the local version of @oclif/core to the package.json
 * Adds relevant oclif plugins
 * Builds the package
 *
 * Environment Variables
 * - OCLIF_CORE_INTEGRATION_TEST_DIR: the directory that you want the setup to happen in
 * - OCLIF_CORE_INTEGRATION_SKIP_SETUP: skip all the setup steps (useful if iterating on tests)
 */
export async function setup(testFile: string, options: SetupOptions): Promise<Executor> {
  const testFileName = basename(testFile)
  const dir = process.env.OCLIF_CORE_INTEGRATION_TEST_DIR || tmpdir()
  const testDir = options.subDir ? join(dir, testFileName, options.subDir) : join(dir, testFileName)

  const name = options.repo.slice(options.repo.lastIndexOf('/') + 1)
  const pluginDir = join(testDir, name)
  const executor = new Executor({pluginDir, testFileName})

  executor.debug('plugin directory:', pluginDir)

  if (process.env.OCLIF_CORE_INTEGRATION_SKIP_SETUP === 'true') {
    console.log(ansis.yellow.bold('OCLIF_CORE_INTEGRATION_SKIP_SETUP is true. Skipping test setup...'))
    return executor
  }

  await mkdir(testDir, {recursive: true})
  await rm(pluginDir, {recursive: true, force: true})

  await executor.clone(options.repo, options.branch)

  executor.debug('Updating package.json')
  const dependencies = options.noLinkCore ? {} : {'@oclif/core': `file:${resolve('.')}`}
  const devDependencies = options.useTsx ? {tsx: 'latest'} : {}

  let pjson: Interfaces.PJSON
  if (options.plugins) {
    const pluginDeps = options.plugins.reduce((x, y) => ({...x, [y]: 'latest'}), {})
    pjson = updatePkgJson(pluginDir, {
      ...(options.noLinkCore ? {} : {resolutions: {'@oclif/core': resolve('.')}}),
      dependencies: {...dependencies, ...pluginDeps},
      devDependencies,
      oclif: {plugins: options.plugins},
    })
  } else {
    pjson = updatePkgJson(pluginDir, {
      ...(options.noLinkCore ? {} : {resolutions: {'@oclif/core': resolve('.')}}),
      devDependencies,
      dependencies,
    })
  }

  executor.debug('updated dependencies:', JSON.stringify(pjson.dependencies, null, 2))
  executor.debug('updated devDependencies:', JSON.stringify(pjson.devDependencies, null, 2))
  executor.debug('updated resolutions:', JSON.stringify(pjson.resolutions, null, 2))
  executor.debug('updated plugins:', JSON.stringify(pjson.oclif.plugins, null, 2))

  const bin = (pjson.oclif.bin ?? pjson.name.replaceAll('-', '_')).toUpperCase()
  const dataDir = join(testDir, 'data', pjson.oclif.bin ?? pjson.name)
  const cacheDir = join(testDir, 'cache', pjson.oclif.bin ?? pjson.name)
  const configDir = join(testDir, 'config', pjson.oclif.bin ?? pjson.name)

  await mkdir(dataDir, {recursive: true})
  await mkdir(configDir, {recursive: true})
  await mkdir(cacheDir, {recursive: true})

  process.env[`${bin}_DATA_DIR`] = dataDir
  process.env[`${bin}_CONFIG_DIR`] = configDir
  process.env[`${bin}_CACHE_DIR`] = cacheDir

  executor.debug(`${bin}_DATA_DIR:`, process.env[`${bin}_DATA_DIR`])
  executor.debug(`${bin}_CONFIG_DIR:`, process.env[`${bin}_CONFIG_DIR`])
  executor.debug(`${bin}_CACHE_DIR:`, process.env[`${bin}_CACHE_DIR`])

  const yarnInstallRes = await executor.executeInTestDir(
    'yarn install --force --network-timeout 600000 --ignore-scripts',
    {
      silent: false,
    },
  )
  if (yarnInstallRes.code !== 0) {
    console.error(yarnInstallRes?.error)
    throw new Error('Failed to run `yarn install --force`')
  }

  const compileRes = await executor.executeInTestDir('yarn build')
  if (compileRes.code !== 0) {
    console.error(compileRes?.error)
    throw new Error('Failed to run `yarn build`')
  }

  executor.debug('Setup complete')
  return executor
}
````

## File: test/interfaces/args.test-types.ts
````typescript
/**
 * This test file contains no unit tests but we use the tsd package to ensure that the types are valid when the tests are compiled
 */
import {URL} from 'node:url'
import {expectNotType, expectType} from 'tsd'

import {Args, Command, Interfaces} from '../../src'

type MyArgs = Interfaces.InferredArgs<typeof MyCommand.args>

type MyType = {
  foo: boolean
}

export class MyCommand extends Command {
  static args = {
    requiredString: Args.string({required: true}),
    optionalString: Args.string(),
    defaultString: Args.string({default: 'default'}),

    requiredBoolean: Args.boolean({required: true}),
    optionalBoolean: Args.boolean(),
    defaultBoolean: Args.boolean({default: true}),

    optionalInteger: Args.integer(),
    requiredInteger: Args.integer({required: true}),
    defaultInteger: Args.integer({default: 1}),

    optionalDirectory: Args.directory(),
    requiredDirectory: Args.directory({required: true}),
    defaultDirectory: Args.directory({default: 'my-dir'}),

    optionalFile: Args.file(),
    requiredFile: Args.file({required: true}),
    defaultFile: Args.file({default: 'my-file.json'}),

    optionalUrl: Args.url(),
    requiredUrl: Args.url({required: true}),
    defaultUrl: Args.url({default: new URL('http://example.com')}),

    optionalCustom: Args.custom<MyType>({
      parse: async () => ({foo: true}),
    })(),
    requiredCustom: Args.custom<MyType>({
      parse: async () => ({foo: true}),
    })({required: true}),
    defaultCustom: Args.custom<MyType>({
      parse: async () => ({foo: true}),
    })({default: {foo: true}}),
  }

  static description = 'describe the command here'

  static examples = ['<%= config.bin %> <%= command.id %>']

  public args!: MyArgs

  public async run(): Promise<MyArgs> {
    const result = await this.parse(MyCommand)
    this.args = result.args
    expectType<MyArgs>(this.args)

    expectType<string>(this.args.requiredString)
    expectNotType<undefined>(this.args.requiredString)

    expectType<string>(this.args.defaultString)
    expectNotType<undefined>(this.args.defaultString)

    expectType<string | undefined>(this.args.optionalString)

    expectType<boolean>(this.args.requiredBoolean)
    expectNotType<undefined>(this.args.requiredBoolean)
    expectType<boolean>(this.args.defaultBoolean)
    expectNotType<undefined>(this.args.defaultBoolean)
    expectType<boolean | undefined>(this.args.optionalBoolean)

    expectType<number>(this.args.requiredInteger)
    expectNotType<undefined>(this.args.requiredInteger)
    expectType<number>(this.args.defaultInteger)
    expectNotType<undefined>(this.args.defaultInteger)
    expectType<number | undefined>(this.args.optionalInteger)

    expectType<string>(this.args.requiredDirectory)
    expectNotType<undefined>(this.args.requiredDirectory)
    expectType<string>(this.args.defaultDirectory)
    expectNotType<undefined>(this.args.defaultDirectory)
    expectType<string | undefined>(this.args.optionalDirectory)

    expectType<string>(this.args.requiredFile)
    expectNotType<undefined>(this.args.requiredFile)
    expectType<string>(this.args.defaultFile)
    expectNotType<undefined>(this.args.defaultFile)
    expectType<string | undefined>(this.args.optionalFile)

    expectType<URL>(this.args.requiredUrl)
    expectNotType<undefined>(this.args.requiredUrl)
    expectType<URL>(this.args.defaultUrl)
    expectNotType<undefined>(this.args.defaultUrl)
    expectType<URL | undefined>(this.args.optionalUrl)

    expectType<MyType>(this.args.requiredCustom)
    expectNotType<undefined>(this.args.requiredCustom)
    expectType<MyType>(this.args.defaultCustom)
    expectNotType<undefined>(this.args.defaultCustom)
    expectType<MyType | undefined>(this.args.optionalCustom)

    return result.args
  }
}
````

## File: test/interfaces/flags.test-types.ts
````typescript
/**
 * This test file contains no unit tests but we use the tsd package to ensure that the types are valid when the tests are compiled
 */

import {URL} from 'node:url'
import {expectNotType, expectType} from 'tsd'

import {Command, Flags, Interfaces} from '../../src'

abstract class BaseCommand extends Command {
  static enableJsonFlag = true

  static flags = {
    optionalGlobalFlag: Flags.string(),
    requiredGlobalFlag: Flags.string({required: true}),
    defaultGlobalFlag: Flags.string({default: 'default'}),
  }
}

type MyFlags = Interfaces.InferredFlags<typeof MyCommand.flags>

type MyType = {
  foo: boolean
}

export const customFlagWithRequiredProp = Flags.custom<number, {unit: 'minutes' | 'seconds'}>({
  async parse(input, _, opts) {
    const value = opts.unit === 'minutes' ? new Date(input).getMinutes() : new Date(input).getSeconds()
    return value
  },
  default: async (_ctx) => (_ctx.options.unit === 'minutes' ? 1 : 2),
  defaultHelp: async (_ctx) => (_ctx.options.unit === 'minutes' ? '1 minute' : '2 seconds'),
  char: 'c',
})

export const arrayFlag = Flags.custom<string[]>({
  delimiter: ',',
  multiple: true,
})

const options = ['foo', 'bar'] as const

Flags.option({
  options,
  multiple: true,
  // @ts-expect-error because multiple is true, default must be an array
  default: 'foo',
})

Flags.option({options})({
  multiple: true,
  // @ts-expect-error because multiple is true, default must be an array
  default: 'foo',
})

// @ts-expect-error because multiple is false, default must be a single value
Flags.option({
  options,
  default: ['foo'],
})

// @ts-expect-error because multiple is false, default must be a single value
Flags.option({options, multiple: false})({
  default: ['foo'],
})

Flags.custom({
  options,
  multiple: true,
  // @ts-expect-error because multiple is true, default must be an array
  default: 'foo',
})

Flags.custom()({
  multiple: true,
  // @ts-expect-error because multiple is true, default must be an array
  default: 'foo',
})

Flags.custom({multiple: true})({
  // @ts-expect-error because multiple is true, default must be an array
  default: 'foo',
})

// @ts-expect-error because multiple is false, default must be a single value
Flags.custom({
  options,
  default: ['foo'],
})

// @ts-expect-error because multiple is false, default must be a single value
Flags.custom({multiple: false})({
  default: ['foo'],
})

export class MyCommand extends BaseCommand {
  public static '--' = true

  static description = 'describe the command here'

  static examples = ['<%= config.bin %> <%= command.id %>']

  static flags = {
    ...BaseCommand.flags,
    string: Flags.string(),
    'string#opts:required': Flags.string({required: true}),
    'string#opts:default': Flags.string({default: 'default'}),

    'string#opts:multiple,required': Flags.string({required: true, multiple: true}),
    'string#opts:multiple': Flags.string({multiple: true}),
    'string#opts:multiple,default': Flags.string({
      multiple: true,
      default: ['default'],
      defaultHelp: async (_ctx) => 'defaultHelp',
    }),

    boolean: Flags.boolean(),
    'boolean#opts:required': Flags.boolean({required: true}),
    'boolean#opts:default': Flags.boolean({default: true}),

    integer: Flags.integer(),
    'integer#opts:required': Flags.integer({required: true}),
    'integer#opts:default': Flags.integer({default: 1}),

    'integer#opts:multiple': Flags.integer({multiple: true}),
    'integer#opts:multiple,required': Flags.integer({multiple: true, required: true}),
    'integer#opts:multiple,default': Flags.integer({multiple: true, default: [1]}),

    directory: Flags.directory(),
    'directory#opts:required': Flags.directory({required: true}),
    'directory#opts:default': Flags.directory({default: 'my-dir'}),

    'directory#opts:multiple': Flags.directory({multiple: true}),
    'directory#opts:multiple,required': Flags.directory({multiple: true, required: true}),
    'directory#opts:multiple,default': Flags.directory({multiple: true, default: ['my-dir']}),

    file: Flags.file(),
    'file#opts:required': Flags.file({required: true}),
    'file#opts:default': Flags.file({default: 'my-file.json'}),

    'file#opts:multiple': Flags.file({multiple: true}),
    'file#opts:multiple,required': Flags.file({multiple: true, required: true}),
    'file#opts:multiple,default': Flags.file({multiple: true, default: ['my-file.json']}),

    url: Flags.url(),
    'url#opts:required': Flags.url({required: true}),
    'url#opts:default': Flags.url({
      default: new URL('http://example.com'),
      defaultHelp: async (_ctx) => 'Example URL',
    }),

    'url#opts:multiple': Flags.url({multiple: true}),
    'url#opts:multiple,required': Flags.url({multiple: true, required: true}),
    'url#opts:multiple,default': Flags.url({multiple: true, default: [new URL('http://example.com')]}),

    custom: Flags.custom<MyType>({
      parse: async () => ({foo: true}),
    })(),
    'custom#opts:required': Flags.custom<MyType>({
      parse: async () => ({foo: true}),
    })({required: true}),
    'custom#opts:default': Flags.custom<MyType>({
      parse: async () => ({foo: true}),
    })({
      default: async (_ctx) => ({foo: true}),
    }),

    'custom#opts:multiple': Flags.custom<MyType>({
      parse: async () => ({foo: true}),
    })({multiple: true}),
    'custom#opts:multiple,required': Flags.custom<MyType>({
      parse: async () => ({foo: true}),
    })({required: true, multiple: true}),
    'custom#opts:multiple,default': Flags.custom<MyType>({
      parse: async () => ({foo: true}),
    })({default: [{foo: true}], multiple: true}),

    'custom#opts:custom-prop': customFlagWithRequiredProp({unit: 'minutes'}),
    'custom#opts:custom-prop,required': customFlagWithRequiredProp({unit: 'minutes', required: true}),
    'custom#opts:custom-prop,default': customFlagWithRequiredProp({unit: 'minutes', default: 23}),

    'custom#defs:multiple,delimiter': arrayFlag(),
    'custom#defs:multiple,delimiter;opts:required': arrayFlag({required: true}),
    'custom#defs:multiple,delimiter;opts:default': arrayFlag({default: ['foo', 'bar']}),

    option: Flags.option({
      options,
    })(),
    'option#opts:required': Flags.option({
      options,
    })({required: true}),
    'option#opts:default': Flags.option({
      options,
    })({default: 'foo'}),

    'option#opts:multiple': Flags.option({
      options,
    })({multiple: true}),
    'option#opts:multiple,required': Flags.option({
      options,
    })({required: true, multiple: true}),
    'option#opts:multiple,default': Flags.option({
      options,
    })({default: async (_ctx) => ['foo'], multiple: true}),

    'custom#defs:required': Flags.custom({
      required: true,
    })(),
    'custom#defs:default': Flags.custom({
      default: 'foo',
    })(),
    'custom#defs:multiple': Flags.custom({
      multiple: true,
    })(),
    'custom#defs:multiple,required': Flags.custom({
      multiple: true,
      required: true,
    })(),
    'custom#defs:multiple,default': Flags.custom({
      multiple: true,
      default: ['foo'],
    })(),

    'option#defs:required': Flags.option({
      options,
      required: true,
    })(),
    'option#defs:default': Flags.option({
      options,
      default: async (_ctx) => 'foo',
    })(),
    'option#defs:multiple': Flags.option({
      options,
      multiple: true,
    })(),
    'option#defs:multiple,required': Flags.option({
      options,
      multiple: true,
      required: true,
    })(),
    'option#defs,multiple,default': Flags.option({
      options,
      multiple: true,
      default: async (_ctx) => ['foo'],
    })(),

    'option#defs:multiple;opts:default': Flags.option({
      options,
      multiple: true,
    })({
      default: ['foo'],
    }),

    'option#defs:multiple;opts:default-callback': Flags.option({
      options,
      multiple: true,
    })({
      default: async (_ctx) => ['foo'],
    }),

    'custom#defs:multiple;opts:default-callback': Flags.custom({
      options,
      multiple: true,
    })({
      default: async (_ctx) => ['foo'],
    }),

    'custom#defs:multiple,parse': Flags.custom({
      multiple: true,
      parse: async (input, _ctx, _opts) => input,
    })(),

    'option#defs:multiple,prase': Flags.option({
      options,
      multiple: true,
      parse: async (input, _ctx, _opts) => input as (typeof options)[number],
    })(),

    'custom#defs:multiple=true;opts:multiple=false': Flags.custom({
      multiple: true,
    })({
      multiple: false,
    }),
    'custom#defs:multiple=false;opts:multiple=true': Flags.custom({
      multiple: false,
    })({
      multiple: true,
    }),
    'custom#defs:required=true;opts:required=false': Flags.custom({
      required: true,
    })({
      required: false,
    }),
    'custom#defs:required=false;opts:required=true': Flags.custom({
      required: false,
    })({
      required: true,
    }),
    'custom#defs:multiple=true;opts:multiple=false,required=true': Flags.custom({
      multiple: true,
    })({
      multiple: false,
      required: true,
    }),
    'custom#defs:required=true;opts:multiple=true,required=false': Flags.custom({
      required: true,
    })({
      multiple: true,
      required: false,
    }),
    'custom#defs:required=false;opts:multiple=true,required=true': Flags.custom({
      required: false,
    })({
      multiple: true,
      required: true,
    }),

    'custom#defs:multiple=true,required=true;opts:multiple=false,required=false': Flags.custom({
      multiple: true,
      required: true,
    })({
      multiple: false,
      required: false,
    }),

    'custom#defs:multiple=false,required=false;opts:multiple=true,required=true': Flags.custom({
      multiple: false,
      required: false,
    })({
      multiple: true,
      required: true,
    }),

    'custom#defs:multiple=true;opts:multiple=false,default': Flags.custom({
      multiple: true,
    })({
      multiple: false,
      // TODO: THIS IS A BUG. It should enforce a single value instead of allowing a single value or an array
      default: ['foo'],
    }),

    'custom-union#defs:parse': Flags.custom<'a' | 'b' | 'c'>({
      async parse(input, _ctx, _opts) {
        return input as 'a' | 'b' | 'c'
      },
    })(),

    'custom-union#defs:parse,multiple': Flags.custom<'a' | 'b' | 'c'>({
      async parse(input, _ctx, _opts) {
        return input as 'a' | 'b' | 'c'
      },
      multiple: true,
    })(),
  }

  public flags!: MyFlags

  public async run(): Promise<MyFlags> {
    const result = await this.parse(MyCommand)
    this.flags = result.flags
    expectType<MyFlags>(this.flags)

    expectType<string>(this.flags.requiredGlobalFlag)
    expectNotType<undefined>(this.flags.requiredGlobalFlag)
    expectType<string>(this.flags.defaultGlobalFlag)
    expectNotType<undefined>(this.flags.defaultGlobalFlag)
    expectType<string | undefined>(this.flags.optionalGlobalFlag)

    expectType<string>(this.flags['string#opts:required'])
    expectNotType<undefined>(this.flags['string#opts:required'])

    expectType<string>(this.flags['string#opts:default'])
    expectNotType<undefined>(this.flags['string#opts:default'])

    expectType<string | undefined>(this.flags.string)

    expectType<string[]>(this.flags['string#opts:multiple,required'])
    expectNotType<undefined>(this.flags['string#opts:multiple,required'])

    expectType<string[] | undefined>(this.flags['string#opts:multiple'])
    expectType<string[]>(this.flags['string#opts:multiple,default'])
    expectNotType<undefined>(this.flags['string#opts:multiple,default'])

    expectType<boolean>(this.flags['boolean#opts:required'])
    expectNotType<undefined>(this.flags['boolean#opts:required'])
    expectType<boolean>(this.flags['boolean#opts:default'])
    expectNotType<undefined>(this.flags['boolean#opts:default'])
    expectType<boolean | undefined>(this.flags.boolean)

    expectType<number>(this.flags['integer#opts:required'])
    expectNotType<undefined>(this.flags['integer#opts:required'])
    expectType<number>(this.flags['integer#opts:default'])
    expectNotType<undefined>(this.flags['integer#opts:default'])
    expectType<number | undefined>(this.flags.integer)

    expectType<number[]>(this.flags['integer#opts:multiple,required'])
    expectNotType<undefined>(this.flags['integer#opts:multiple,required'])
    expectType<number[]>(this.flags['integer#opts:multiple,default'])
    expectNotType<undefined>(this.flags['integer#opts:multiple,default'])
    expectType<number[] | undefined>(this.flags['integer#opts:multiple'])

    expectType<string>(this.flags['directory#opts:required'])
    expectNotType<undefined>(this.flags['directory#opts:required'])
    expectType<string>(this.flags['directory#opts:default'])
    expectNotType<undefined>(this.flags['directory#opts:default'])
    expectType<string | undefined>(this.flags.directory)

    expectType<string[]>(this.flags['directory#opts:multiple,required'])
    expectNotType<undefined>(this.flags['directory#opts:multiple,required'])
    expectType<string[]>(this.flags['directory#opts:multiple,default'])
    expectNotType<undefined>(this.flags['directory#opts:multiple,default'])
    expectType<string[] | undefined>(this.flags['directory#opts:multiple'])

    expectType<string>(this.flags['file#opts:required'])
    expectNotType<undefined>(this.flags['file#opts:required'])
    expectType<string>(this.flags['file#opts:default'])
    expectNotType<undefined>(this.flags['file#opts:default'])
    expectType<string | undefined>(this.flags.file)

    expectType<string[]>(this.flags['file#opts:multiple,required'])
    expectNotType<undefined>(this.flags['file#opts:multiple,required'])
    expectType<string[]>(this.flags['file#opts:multiple,default'])
    expectNotType<undefined>(this.flags['file#opts:multiple,default'])
    expectType<string[] | undefined>(this.flags['file#opts:multiple'])

    expectType<URL>(this.flags['url#opts:required'])
    expectNotType<undefined>(this.flags['url#opts:required'])
    expectType<URL>(this.flags['url#opts:default'])
    expectNotType<undefined>(this.flags['url#opts:default'])
    expectType<URL | undefined>(this.flags.url)

    expectType<URL[]>(this.flags['url#opts:multiple,required'])
    expectNotType<undefined>(this.flags['url#opts:multiple,required'])
    expectType<URL[]>(this.flags['url#opts:multiple,default'])
    expectNotType<undefined>(this.flags['url#opts:multiple,default'])
    expectType<URL[] | undefined>(this.flags['url#opts:multiple'])

    expectType<MyType>(this.flags['custom#opts:required'])
    expectNotType<undefined>(this.flags['custom#opts:required'])
    expectType<MyType>(this.flags['custom#opts:default'])
    expectNotType<undefined>(this.flags['custom#opts:default'])
    expectType<MyType | undefined>(this.flags.custom)

    expectType<MyType[]>(this.flags['custom#opts:multiple,required'])
    expectNotType<undefined>(this.flags['custom#opts:multiple,required'])
    expectType<MyType[]>(this.flags['custom#opts:multiple,default'])
    expectNotType<undefined>(this.flags['custom#opts:multiple,default'])
    expectType<MyType[] | undefined>(this.flags['custom#opts:multiple'])

    expectType<number | undefined>(this.flags['custom#opts:custom-prop'])
    expectType<number>(this.flags['custom#opts:custom-prop,required'])
    expectNotType<undefined>(this.flags['custom#opts:custom-prop,required'])
    expectType<number>(this.flags['custom#opts:custom-prop,default'])
    expectNotType<undefined>(this.flags['custom#opts:custom-prop,default'])

    expectType<string[]>(this.flags['custom#defs:multiple,delimiter;opts:required'])
    expectNotType<undefined>(this.flags['custom#defs:multiple,delimiter;opts:required'])
    expectType<string[]>(this.flags['custom#defs:multiple,delimiter;opts:default'])
    expectNotType<undefined>(this.flags['custom#defs:multiple,delimiter;opts:default'])
    expectType<string[] | undefined>(this.flags['custom#defs:multiple,delimiter'])

    expectType<(typeof options)[number]>(this.flags['option#opts:required'])
    expectNotType<undefined>(this.flags['option#opts:required'])
    expectType<(typeof options)[number]>(this.flags['option#opts:default'])
    expectNotType<undefined>(this.flags['option#opts:default'])
    expectType<(typeof options)[number] | undefined>(this.flags.option)

    expectType<(typeof options)[number][]>(this.flags['option#opts:multiple,required'])
    expectNotType<undefined>(this.flags['option#opts:multiple,required'])
    expectType<(typeof options)[number][]>(this.flags['option#opts:multiple,default'])
    expectNotType<undefined>(this.flags['option#opts:multiple,default'])
    expectType<(typeof options)[number][] | undefined>(this.flags['option#opts:multiple'])

    expectType<string>(this.flags['custom#defs:required'])
    expectNotType<undefined>(this.flags['custom#defs:required'])
    expectType<string>(this.flags['custom#defs:default'])
    expectNotType<undefined>(this.flags['custom#defs:default'])
    expectType<string[] | undefined>(this.flags['custom#defs:multiple'])
    expectNotType<undefined>(this.flags['custom#defs:multiple'])
    expectType<string[]>(this.flags['custom#defs:multiple,required'])
    expectNotType<undefined>(this.flags['custom#defs:multiple,required'])
    expectType<string[]>(this.flags['custom#defs:multiple,default'])
    expectNotType<undefined>(this.flags['custom#defs:multiple,default'])

    expectType<string>(this.flags['option#defs:required'])
    expectNotType<undefined>(this.flags['option#defs:required'])
    expectType<string>(this.flags['option#defs:default'])
    expectNotType<undefined>(this.flags['option#defs:default'])
    expectType<string[] | undefined>(this.flags['option#defs:multiple'])
    expectNotType<undefined>(this.flags['option#defs:multiple'])
    expectType<string[]>(this.flags['option#defs:multiple,required'])
    expectNotType<undefined>(this.flags['option#defs:multiple,required'])
    expectType<string[]>(this.flags['option#defs,multiple,default'])
    expectNotType<undefined>(this.flags['option#defs,multiple,default'])

    expectType<string[]>(this.flags['option#defs:multiple;opts:default'])
    expectNotType<undefined>(this.flags['option#defs:multiple;opts:default'])

    expectType<string[]>(this.flags['option#defs:multiple;opts:default-callback'])
    expectNotType<undefined>(this.flags['option#defs:multiple;opts:default-callback'])

    expectType<string[]>(this.flags['custom#defs:multiple;opts:default-callback'])

    expectType<string[] | undefined>(this.flags['custom#defs:multiple,parse'])

    expectType<(typeof options)[number][] | undefined>(this.flags['option#defs:multiple,prase'])

    expectType<string | undefined>(this.flags['custom#defs:multiple=true;opts:multiple=false'])
    expectType<string[] | undefined>(this.flags['custom#defs:multiple=false;opts:multiple=true'])
    expectType<string | undefined>(this.flags['custom#defs:required=true;opts:required=false'])
    expectType<string>(this.flags['custom#defs:required=false;opts:required=true'])
    expectNotType<undefined>(this.flags['custom#defs:required=false;opts:required=true'])
    expectType<string>(this.flags['custom#defs:multiple=true;opts:multiple=false,required=true'])
    expectNotType<undefined>(this.flags['custom#defs:multiple=true;opts:multiple=false,required=true'])
    expectType<string[] | undefined>(this.flags['custom#defs:required=true;opts:multiple=true,required=false'])
    expectType<string[]>(this.flags['custom#defs:required=false;opts:multiple=true,required=true'])
    expectNotType<undefined>(this.flags['custom#defs:required=false;opts:multiple=true,required=true'])
    expectType<string | undefined>(
      this.flags['custom#defs:multiple=true,required=true;opts:multiple=false,required=false'],
    )
    expectType<string[]>(this.flags['custom#defs:multiple=false,required=false;opts:multiple=true,required=true'])
    expectNotType<undefined>(this.flags['custom#defs:multiple=false,required=false;opts:multiple=true,required=true'])

    // TODO: Known issue with `default` not enforcing the correct type whenever multiple is defaulted to true but then overridden to false
    // expectType<string>(this.flags['custom#defs:multiple=true;opts:multiple=false,default'])

    expectType<'a' | 'b' | 'c' | undefined>(this.flags['custom-union#defs:parse'])
    expectType<Array<'a' | 'b' | 'c'> | undefined>(this.flags['custom-union#defs:parse,multiple'])

    return result.flags
  }
}
````

## File: test/module-loader/fixtures/cjs/errors/bad_reference.cjs
````
bad_reference
````

## File: test/module-loader/fixtures/cjs/package.json
````json
{}
````

## File: test/module-loader/fixtures/cjs/success-ext.cjs
````
module.exports = ['SUCCESS_CJS'];
module.exports.namedExport = 'SUCCESS_NAMED_CJS';
````

## File: test/module-loader/fixtures/cjs/success.js
````javascript
module.exports = ['SUCCESS']
module.exports.namedExport = 'SUCCESS_NAMED'
````

## File: test/module-loader/fixtures/esm/empty-package/package.json
````json
{}
````

## File: test/module-loader/fixtures/esm/empty-package/success-ext.mjs
````
export default 'SUCCESS_MJS';

export const namedExport = 'SUCCESS_NAMED_MJS';
````

## File: test/module-loader/fixtures/esm/errors/bad_reference.js
````javascript
bad_reference
````

## File: test/module-loader/fixtures/esm/index/js/index.js
````javascript
export default 'SUCCESS'

export const namedExport = 'SUCCESS_NAMED'
````

## File: test/module-loader/fixtures/esm/index/mjs/index.mjs
````
export default 'SUCCESS'

export const namedExport = 'SUCCESS_NAMED'
````

## File: test/module-loader/fixtures/esm/package.json
````json
{
  "type": "module"
}
````

## File: test/module-loader/fixtures/esm/success.js
````javascript
export default 'SUCCESS'

export const namedExport = 'SUCCESS_NAMED'
````

## File: test/module-loader/fixtures/package.json
````json
{}
````

## File: test/module-loader/module-loader.test.ts
````typescript
import {assert, expect} from 'chai'
import {resolve} from 'node:path'

import {Config} from '../../src'
import {ModuleLoadError} from '../../src/errors'
import {isPathModule, load, loadWithData} from '../../src/module-loader'

// The following data object contains an array of module loading data for errors and successful loading conditions and
// the associated data to test for ModuleLoader.

const data = {
  errors: [
    // Non-existent path
    {
      path: './test/module-loader/fixtures/esm/errors/bad_path.js',
      type: ModuleLoadError,
      message: `[MODULE_NOT_FOUND] import() failed to load ${resolve(
        './test/module-loader/fixtures/esm/errors/bad_path.js',
      )}`,
      isESM: true,
    },
    // Non-existent path / no extension
    {
      path: './test/module-loader/fixtures/esm/errors/bad_path',
      type: ModuleLoadError,
      message: `[MODULE_NOT_FOUND] require failed to load ${resolve(
        './test/module-loader/fixtures/esm/errors/bad_path',
      )}`,
      isESM: true,
    },

    // Non-existent path
    {
      path: './test/module-loader/fixtures/cjs/errors/bad_path.cjs',
      type: ModuleLoadError,
      message: `[MODULE_NOT_FOUND] require failed to load ${resolve(
        './test/module-loader/fixtures/cjs/errors/bad_path.cjs',
      )}`,
      isESM: false,
    },
    // Non-existent path / no extension
    {
      path: './test/module-loader/fixtures/cjs/errors/bad_path',
      type: ModuleLoadError,
      message: `[MODULE_NOT_FOUND] require failed to load ${resolve(
        './test/module-loader/fixtures/cjs/errors/bad_path',
      )}`,
      isESM: false,
    },

    // Incomplete source file
    {
      path: './test/module-loader/fixtures/esm/errors/bad_reference.js',
      type: ReferenceError,
      message: 'bad_reference is not defined',
      isESM: true,
    },
    // Incomplete source file
    {
      path: './test/module-loader/fixtures/cjs/errors/bad_reference.cjs',
      type: ReferenceError,
      message: 'bad_reference is not defined',
      isESM: false,
    },
  ],

  modules: [
    // ESM source file. Loads package.json in './test/module-loader/fixtures/esm/' for getPackageType check.
    {
      path: './test/module-loader/fixtures/esm/success.js',
      defaultModule: '{"default":"SUCCESS","namedExport":"SUCCESS_NAMED"}',
      filePath: `${resolve('./test/module-loader/fixtures/esm/success.js')}`,
      isESM: true,
    },
    // ESM source file loaded due to mjs file type.
    {
      path: './test/module-loader/fixtures/esm/empty-package/success-ext.mjs',
      defaultModule: '{"default":"SUCCESS_MJS","namedExport":"SUCCESS_NAMED_MJS"}',
      filePath: `${resolve('./test/module-loader/fixtures/esm/empty-package/success-ext.mjs')}`,
      isESM: true,
    },
    // No extension / ESM source file. Loads package.json in './test/module-loader/fixtures/esm/' for getPackageType check.
    {
      path: './test/module-loader/fixtures/esm/success',
      defaultModule: '{"default":"SUCCESS","namedExport":"SUCCESS_NAMED"}',
      filePath: `${resolve('./test/module-loader/fixtures/esm/success.js')}`,
      isESM: true,
      isESMOverride: false, // With no extension `ModuleLoader.isPathModule` will return CJS
    },
    // No extension / ESM source file loaded due to mjs file type.
    {
      path: './test/module-loader/fixtures/esm/empty-package/success-ext',
      defaultModule: '{"default":"SUCCESS_MJS","namedExport":"SUCCESS_NAMED_MJS"}',
      filePath: `${resolve('./test/module-loader/fixtures/esm/empty-package/success-ext.mjs')}`,
      isESM: true,
      isESMOverride: false, // With no extension `ModuleLoader.isPathModule` will return CJS
    },

    // CJS source loaded from package.json in './test/module-loader/fixtures/cjs/' which doesn't have "type": "module".
    {
      path: './test/module-loader/fixtures/cjs/success.js',
      defaultModule: '["SUCCESS"]',
      filePath: `${resolve('./test/module-loader/fixtures/cjs/success.js')}`,
      isESM: false,
    },
    // CJS source file loaded due to cjs file type.
    {
      path: './test/module-loader/fixtures/cjs/success-ext.cjs',
      defaultModule: '["SUCCESS_CJS"]',
      filePath: `${resolve('./test/module-loader/fixtures/cjs/success-ext.cjs')}`,
      isESM: false,
    },
    // No extension / CJS source loaded from package.json in './test/module-loader/fixtures/cjs/' which doesn't have "type": "module".
    {
      path: './test/module-loader/fixtures/cjs/success',
      defaultModule: '["SUCCESS"]',
      filePath: `${resolve('./test/module-loader/fixtures/cjs/success.js')}`,
      isESM: false,
    },
    // No extension / CJS source file loaded due to cjs file type.
    {
      path: './test/module-loader/fixtures/cjs/success-ext',
      defaultModule: '["SUCCESS_CJS"]',
      filePath: `${resolve('./test/module-loader/fixtures/cjs/success-ext.cjs')}`,
      isESM: false,
    },

    // Directory / ESM source file with .js extension. Loads package.json in './test/module-loader/fixtures/esm/' for getPackageType check.
    {
      path: './test/module-loader/fixtures/esm/index/js',
      defaultModule: '{"default":"SUCCESS","namedExport":"SUCCESS_NAMED"}',
      filePath: `${resolve('./test/module-loader/fixtures/esm/index/js/index.js')}`,
      isESM: true,
      isESMOverride: false, // With no extension `ModuleLoader.isPathModule` will return CJS
    },
    // Directory / ESM source file with .mjs extension. Loads package.json in './test/module-loader/fixtures/esm/' for getPackageType check.
    {
      path: './test/module-loader/fixtures/esm/index/mjs',
      defaultModule: '{"default":"SUCCESS","namedExport":"SUCCESS_NAMED"}',
      filePath: `${resolve('./test/module-loader/fixtures/esm/index/mjs/index.mjs')}`,
      isESM: true,
      isESMOverride: false, // With no extension `ModuleLoader.isPathModule` will return CJS
    },

    // CJS NPM module; just check that it loads as CJS.
    {
      path: 'eslint',
      isESM: false,
    },
  ],
}

// The following tests iterate over `data.module` to validate successful loading conditions for CJS & ESM source files.
describe('ModuleLoader:', () => {
  describe('load:', () => {
    for (const module of data.modules) {
      it(`${module.path}`, async () => {
        const config = new Config({root: process.cwd()})
        await config.load()

        const result = await load(config, module.path)

        // Test that the default module as a string.
        if (module.defaultModule) {
          assert.strictEqual(module.defaultModule, JSON.stringify(result))
        }
      })
    }
  })

  describe('loadWithData:', () => {
    for (const module of data.modules) {
      it(`${module.path}`, async () => {
        const config = new Config({root: process.cwd()})
        await config.load()

        const result = await loadWithData(config, module.path)

        // Test the exported module as a string.
        if (module.defaultModule) {
          assert.strictEqual(module.defaultModule, JSON.stringify(result.module))
        }

        // Test that the loaded filePath matches.
        if (module.filePath) {
          assert.strictEqual(module.filePath, result.filePath)
        }

        // Test source type.
        assert.strictEqual(result.isESM, module.isESM)
      })
    }
  })

  describe('isPathModule:', () => {
    for (const module of data.modules) {
      it(`${module.path}`, () => {
        const result = isPathModule(module.path)

        // For extensionless ESM data `isPathModule` will return false
        const test = typeof module.isESMOverride === 'boolean' ? module.isESMOverride : module.isESM

        // Test source type.
        assert.strictEqual(result, test)
      })
    }
  })
})

// The following tests iterate over `data.errors` to validate common error conditions.
describe('ModuleLoader Failures:', () => {
  describe('load:', () => {
    for (const error of data.errors) {
      it(`${error.path}`, async () => {
        const config = new Config({root: process.cwd()})
        await config.load()

        await expect(load(config, error.path))
          .to.eventually.be.rejectedWith(error.message)
          .and.be.an.instanceOf(error.type)
      })
    }
  })

  describe('loadWithData:', () => {
    for (const error of data.errors) {
      it(`${error.path}`, async () => {
        const config = new Config({root: process.cwd()})
        await config.load()

        await expect(loadWithData(config, error.path))
          .to.eventually.be.rejectedWith(error.message)
          .and.be.an.instanceOf(error.type)
      })
    }
  })

  describe('ModuleLoadError:', () => {
    it("has code 'MODULE_NOT_FOUND'", () => {
      const error = new ModuleLoadError('MESSAGE')
      assert.strictEqual(error.code, 'MODULE_NOT_FOUND')
    })
  })
})
````

## File: test/parser/fixtures/preparse-plugin/src/commands/test.ts
````typescript
import {Command, Flags, Interfaces} from '../../../../../../src'
import {BooleanFlag} from '../../../../../../src/interfaces'

type GroupAliasOption = {
  flag: string
  option?: string
}

function groupAliasFlag<T = boolean>(
  options: Partial<BooleanFlag<T> & {groupAlias: GroupAliasOption[]}> = {},
): BooleanFlag<T> {
  return {
    parse: async (b, _) => b,
    ...options,
    allowNo: Boolean(options.allowNo),
    type: 'boolean',
  } as BooleanFlag<T>
}

export default class Test extends Command {
  static args = {}

  static flags = {
    burger: Flags.string({
      char: 'b',
      default: async () => 'double',
    }),
    combo: groupAliasFlag({
      char: 'c',
      groupAlias: [
        {flag: 'burger'},
        {flag: 'fries'},
        {
          flag: 'shake',
          option: 'strawberry',
        },
      ],
    }),
    shake: Flags.option({
      options: ['chocolate', 'vanilla', 'strawberry'],
      char: 's',
    })(),
    fries: Flags.boolean({
      allowNo: true,
      char: 'f',
    }),
    'flags-dir': Flags.directory(),
    sauce: Flags.string({
      multiple: true,
      default: ['ketchup'],
    }),
  }

  async run(): Promise<{
    args: Interfaces.InferredArgs<typeof Test.args>
    flags: Interfaces.InferredFlags<typeof Test.flags>
  }> {
    const {args, flags} = await this.parse(Test)
    return {
      args,
      flags,
    }
  }
}
````

## File: test/parser/fixtures/preparse-plugin/src/hooks/preparse.ts
````typescript
import {readdir, readFile} from 'node:fs/promises'
import {join, parse} from 'node:path'

import {Hook} from '../../../../../../src'

const hook: Hook.Preparse = async function ({argv, options}) {
  const flagsToIgnore = new Set(
    Object.entries(options.flags ?? {})
      .filter(
        ([_, flagOptions]) =>
          // don't ignore if flag can take multiple values
          (flagOptions.type === 'option' && flagOptions.multiple !== true) || flagOptions.type === 'boolean',
      )
      .filter(
        ([flagName, flagOptions]) =>
          // ignore if short char flag is present
          argv.includes(`-${flagOptions.char}`) ||
          // ignore if long flag is present
          argv.includes(`--${flagName}`) ||
          // ignore if --no- flag is present
          (flagOptions.type === 'boolean' && flagOptions.allowNo && argv.includes(`--no-${flagName}`)),
      )
      .map(([flagName]) => flagName),
  )

  const groupAliasFlags = Object.fromEntries(
    Object.entries(options.flags ?? {}).filter(
      ([_, flagOptions]) =>
        // @ts-expect-error because the type isn't aware of the custom flag we made
        flagOptions.groupAlias,
    ),
  )

  for (const [flagName, flagOptions] of Object.entries(groupAliasFlags)) {
    const groupAliasFlagPresent = argv.includes(`--${flagName}`) || argv.includes(`-${flagOptions.char}`)

    if (groupAliasFlagPresent) {
      // @ts-expect-error because the type isn't aware of the custom flag we made
      for (const groupAliasOption of flagOptions.groupAlias) {
        if (flagsToIgnore.has(groupAliasOption.flag)) continue
        argv.push(`--${groupAliasOption.flag}`)
        if (groupAliasOption.option) argv.push(groupAliasOption.option)
        if (typeof options.flags?.[groupAliasOption.flag].default === 'function') {
          // eslint-disable-next-line no-await-in-loop
          argv.push(await options.flags?.[groupAliasOption.flag].default())
          continue
        }

        if (options.flags?.[groupAliasOption.flag].default) {
          argv.push(options.flags?.[groupAliasOption.flag].default)
        }
      }
    }
  }

  if (argv.includes('--flags-dir')) {
    const flagsDir = argv[argv.indexOf('--flags-dir') + 1]
    const filesInDir = await readdir(flagsDir)
    const flagsToInsert = await Promise.all(
      filesInDir
        // ignore files that were provided as flags
        .filter((f) => !flagsToIgnore.has(f))
        .map(async (file) => {
          const contents = await readFile(join(flagsDir, file), 'utf8')
          const values = contents?.split('\n')
          return [parse(file).name, values]
        }),
    )

    for (const [flag, values] of flagsToInsert) {
      for (const value of values) {
        argv.push(`--${flag}`)
        if (value) argv.push(value)
      }
    }
  }

  return argv
}

export default hook
````

## File: test/parser/fixtures/preparse-plugin/package.json
````json
{
  "name": "preparse-plugin",
  "private": true,
  "files": [],
  "engines": {
    "node": ">=18.0.0"
  },
  "oclif": {
    "commands": "./lib/commands",
    "hooks": {
      "preparse": "./lib/hooks/preparse.js"
    }
  }
}
````

## File: test/parser/fixtures/preparse-plugin/tsconfig.json
````json
{
  "compilerOptions": {
    "outDir": "./lib",
    "rootDirs": ["./src"]
  },
  "include": ["./src/**/*"]
}
````

## File: test/parser/fixtures/test-plugin/src/commands/invalid.ts
````typescript
import {Args, Command, Flags} from '../../../../../../src'

export default class Invalid extends Command {
  public static readonly args = {
    arg1: Args.string({
      required: false,
    }),
    arg2: Args.string({
      required: true,
    }),
  }

  public static readonly flags = {
    flag1: Flags.integer({
      min: 1,
      max: 10,
      required: true,
    }),
    flag2: Flags.boolean({
      dependsOn: ['flag1'],
    }),
  }

  public async run(): Promise<unknown> {
    const {args, flags} = await this.parse(Invalid)
    return {args, flags}
  }
}
````

## File: test/parser/fixtures/test-plugin/src/commands/test.ts
````typescript
import {Args, Command, Flags} from '../../../../../../src'

export default class Test extends Command {
  public static readonly args = {
    arg1: Args.string({
      required: true,
    }),
  }

  public static readonly flags = {
    flag1: Flags.integer({
      min: 1,
      max: 10,
      required: true,
    }),
    flag2: Flags.boolean({
      dependsOn: ['flag1'],
    }),
  }

  public async run(): Promise<unknown> {
    const {args, flags} = await this.parse(Test)
    return {args, flags}
  }
}
````

## File: test/parser/fixtures/test-plugin/package.json
````json
{
  "name": "test-plugin",
  "private": true,
  "files": [],
  "oclif": {
    "commands": "./lib/commands"
  }
}
````

## File: test/parser/fixtures/test-plugin/tsconfig.json
````json
{
  "compilerOptions": {
    "outDir": "./lib",
    "rootDirs": ["./src"]
  },
  "include": ["./src/**/*"]
}
````

## File: test/parser/error-codes.test.ts
````typescript
import {expect} from 'chai'
import {join, resolve} from 'node:path'
import sinon from 'sinon'

import {Config} from '../../src'
import Cache from '../../src/cache'
import {CLIError} from '../../src/errors'

function hasExitCode(error: unknown, expectedCode: number): void {
  if (error instanceof Error && error.message === 'Expected command to fail but it passed') {
    throw error
  }

  if (error instanceof CLIError) {
    expect(error.oclif.exit).to.equal(expectedCode)
  } else {
    expect.fail('Expected CLIError')
  }
}

type AsyncFunction = (...args: unknown[]) => Promise<unknown>

async function runCommand(fn: AsyncFunction, expectedCode: number): Promise<void> {
  try {
    await fn()
    expect.fail('Expected command to fail but it passed')
  } catch (error) {
    hasExitCode(error, expectedCode)
  }
}

describe('configurable error codes', () => {
  let config: Config

  const defaultExitCode = 2
  const exitCodes = {
    failedFlagParsing: 101,
    failedFlagValidation: 102,
    invalidArgsSpec: 103,
    nonExistentFlag: 104,
    requiredArgs: 105,
    unexpectedArgs: 106,
  }

  beforeEach(async () => {
    config = await Config.load(resolve(__dirname, join('fixtures', 'test-plugin')))
  })

  afterEach(() => {
    sinon.restore()
  })

  describe('failedFlagParsing', () => {
    it('should use default exit code for failed flag parsing', async () => {
      await runCommand(() => config.runCommand('test', ['--flag1', '100', '--flag2', 'arg1']), defaultExitCode)
    })

    it('should use configured exit code for failed flag parsing', async () => {
      sinon.stub(Cache.prototype, 'get').withArgs('exitCodes').returns(exitCodes)
      await runCommand(
        () => config.runCommand('test', ['--flag1', '100', '--flag2', 'arg1']),
        exitCodes.failedFlagParsing,
      )
    })
  })

  describe('failedFlagValidation', () => {
    it('should use default exit code for failed flag parsing', async () => {
      await runCommand(() => config.runCommand('test', ['--flag2', 'arg1']), defaultExitCode)
    })

    it('should use configured exit code for failed flag validation', async () => {
      sinon.stub(Cache.prototype, 'get').withArgs('exitCodes').returns(exitCodes)
      await runCommand(() => config.runCommand('test', ['--flag2', 'arg1']), exitCodes.failedFlagValidation)
    })
  })

  describe('invalidArgsSpec', () => {
    it('should use default exit code for failed flag parsing', async () => {
      await runCommand(() => config.runCommand('invalid', ['arg1', 'arg2']), defaultExitCode)
    })

    it('should use configured exit code for invalid args spec', async () => {
      sinon.stub(Cache.prototype, 'get').withArgs('exitCodes').returns(exitCodes)
      await runCommand(() => config.runCommand('invalid', ['arg1', 'arg2']), exitCodes.invalidArgsSpec)
    })
  })

  describe('nonExistentFlag', () => {
    it('should use default exit code for failed flag parsing', async () => {
      await runCommand(() => config.runCommand('test', ['--DOES_NOT_EXIST', 'arg1']), defaultExitCode)
    })

    it('should use configured exit code for failed flag validation', async () => {
      sinon.stub(Cache.prototype, 'get').withArgs('exitCodes').returns(exitCodes)
      await runCommand(() => config.runCommand('test', ['--DOES_NOT_EXIST', 'arg1']), exitCodes.nonExistentFlag)
    })
  })

  describe('requiredArgs', () => {
    it('should use default exit code for failed flag parsing', async () => {
      await runCommand(() => config.runCommand('test', ['--flag1', '1']), defaultExitCode)
    })

    it('should use configured exit code for failed flag validation', async () => {
      sinon.stub(Cache.prototype, 'get').withArgs('exitCodes').returns(exitCodes)
      await runCommand(() => config.runCommand('test', ['--flag1', '1']), exitCodes.requiredArgs)
    })
  })

  describe('unexpectedArgs', () => {
    it('should use default exit code for failed flag parsing', async () => {
      await runCommand(() => config.runCommand('test', ['arg1', 'arg2', 'arg3']), defaultExitCode)
    })

    it('should use configured exit code for failed flag validation', async () => {
      sinon.stub(Cache.prototype, 'get').withArgs('exitCodes').returns(exitCodes)
      await runCommand(() => config.runCommand('test', ['arg1', 'arg2', 'arg3']), exitCodes.unexpectedArgs)
    })
  })
})
````

## File: test/parser/help.test.ts
````typescript
import ansis from 'ansis'
import {expect} from 'chai'

import * as flags from '../../src/flags'
import {flagUsages} from '../../src/parser/help'

describe('flagUsage', () => {
  it('shows usages', () => {
    const f = [
      flags.string({name: 'bak'}),
      flags.string({name: 'baz', description: 'baz'}),
      flags.string({name: 'bar', char: 'b', description: 'bar'}),
      flags.string({name: 'foo', char: 'f', description: 'desc'}),
      flags.string({name: 'foo', char: 'f', helpLabel: '-f'}),
      flags.boolean({char: 'g', description: 'goo'}),
    ]
    expect(flagUsages(f).map(([name, desc]) => [name, desc && ansis.strip(desc)])).to.deep.equal([
      [' -b, --bar BAR', 'bar'],
      [' -f, --foo FOO', 'desc'],
      [' -f FOO', undefined],
      [' -g', 'goo'],
      [' --bak BAK', undefined],
      [' --baz BAZ', 'baz'],
    ])
  })
})
````

## File: test/parser/parse.test.ts
````typescript
import ansis from 'ansis'
import {assert, config, expect} from 'chai'
import * as fs from 'node:fs'
import {URL} from 'node:url'
import sinon from 'sinon'

import {Args, Flags} from '../../src'
import {CLIError} from '../../src/errors'
import {FlagDefault} from '../../src/interfaces/parser'
import {parse} from '../../src/parser'
import * as parser from '../../src/parser/parse'

config.truncateThreshold = 0

describe('parse', () => {
  it('--bool', async () => {
    const out = await parse(['--bool'], {
      flags: {
        bool: Flags.boolean(),
      },
    })
    expect(out).to.deep.include({flags: {bool: true}})
  })

  describe('undefined flags', () => {
    it('omits undefined flags when no flags', async () => {
      const out = await parse([], {
        flags: {
          bool: Flags.boolean(),
        },
      })
      expect(out.flags).to.deep.equal({})
    })

    it('omits undefined flags when some flags exist', async () => {
      const out = await parse(['--bool', '--str', 'k'], {
        flags: {
          bool: Flags.boolean(),
          bool2: Flags.boolean(),
          str: Flags.string(),
          str2: Flags.string(),
        },
      })
      expect(out.flags).to.deep.equal({bool: true, str: 'k'})
    })
  })

  it('arg1', async () => {
    const out = await parse(['arg1'], {
      args: {foo: Args.string()},
    })
    expect(out.argv).to.deep.equal(['arg1'])
    expect(out.args).to.deep.equal({foo: 'arg1'})
  })

  it('arg1 arg2', async () => {
    const out = await parse(['arg1', 'arg2'], {
      args: {foo: Args.string(), bar: Args.string()},
    })
    expect(out.argv).to.deep.equal(['arg1', 'arg2'])
    expect(out.args).to.deep.equal({foo: 'arg1', bar: 'arg2'})
  })

  it('should throw if unexpected argument is provided', async () => {
    try {
      await parse(['arg1'], {})
      expect.fail('should have thrown')
    } catch (error) {
      const err = error as CLIError
      expect(err.message).to.include('Unexpected argument: arg1')
    }
  })

  describe('output: array', () => {
    it('--bool', async () => {
      const out = await parse(['--bool'], {
        flags: {
          bool: Flags.boolean(),
        },
      })
      expect(out.raw[0]).to.deep.include({flag: 'bool'})
    })

    it('arg1', async () => {
      const out = await parse(['arg1'], {
        args: {foo: Args.string()},
      })
      expect(out.raw[0]).to.have.property('input', 'arg1')
    })

    it('parses args and flags', async () => {
      const out = await parse(['foo', '--myflag', 'bar', 'baz'], {
        args: {myarg: Args.string(), myarg2: Args.string()},
        flags: {myflag: Flags.string()},
      })
      expect(out.argv[0]).to.equal('foo')
      expect(out.argv[1]).to.equal('baz')
      expect(out.flags.myflag).to.equal('bar')
    })

    describe('flags', () => {
      it('parses flags', async () => {
        const out = await parse(['--myflag', '--myflag2'], {
          flags: {myflag: Flags.boolean(), myflag2: Flags.boolean()},
        })
        expect(Boolean(out.flags.myflag)).to.equal(true)
        expect(Boolean(out.flags.myflag2)).to.equal(true)
      })

      it("doesn' throw if defaultHelp func fails", async () => {
        const out = await parse(['--foo', 'baz'], {
          flags: {
            foo: Flags.custom({
              async defaultHelp() {
                throw new Error('failed to get default help value')
              },
            })(),
          },
        })
        expect(out.flags.foo).to.equal('baz')
      })

      it("doesn't throw when 2nd char in value matches a flag char", async () => {
        const out = await parse(['--myflag', 'Ishikawa', '-s', 'value'], {
          flags: {myflag: Flags.string(), second: Flags.string({char: 's'})},
        })
        expect(out.flags.myflag).to.equal('Ishikawa')
        expect(out.flags.second).to.equal('value')
      })

      it("doesn't throw when an unprefixed flag value contains a flag name", async () => {
        const out = await parse(['--myflag', 'a-second-place-finish', '-s', 'value'], {
          flags: {myflag: Flags.string(), second: Flags.string({char: 's'})},
        })
        expect(out.flags.myflag).to.equal('a-second-place-finish')
        expect(out.flags.second).to.equal('value')
      })

      it('throws error when no value provided to required flag', async () => {
        try {
          await parse(['--myflag', '--second', 'value'], {
            flags: {myflag: Flags.string({required: true}), second: Flags.string()},
          })
          assert.fail('should have thrown')
        } catch (error) {
          expect((error as CLIError).message).to.include('Flag --myflag expects a value')
        }
      })

      it('throws error when no value provided to required flag with options', async () => {
        try {
          await parse(['--myflag', '--second', 'value'], {
            flags: {
              myflag: Flags.string({
                required: true,
                options: ['a', 'b'],
              }),
              second: Flags.string(),
            },
          })
          assert.fail('should have thrown')
        } catch (error) {
          expect((error as CLIError).message).to.include('Flag --myflag expects one of these values: a, b')
        }
      })

      it('throws error when no value provided to required flag before a short char flag', async () => {
        try {
          await parse(['--myflag', '-s', 'value'], {
            flags: {myflag: Flags.string({required: true}), second: Flags.string({char: 's'})},
          })
          assert.fail('should have thrown')
        } catch (error) {
          expect((error as CLIError).message).to.include('Flag --myflag expects a value')
        }
      })

      it("doesn't throw when boolean flag passed", async () => {
        const out = await parse(['--myflag', '--second', 'value'], {
          flags: {myflag: Flags.boolean(), second: Flags.string()},
        })
        expect(out.flags.myflag).to.be.true
        expect(out.flags.second).to.equal('value')
      })

      it("doesn't throw when negative number passed", async () => {
        const out = await parse(['--myflag', '-s', '-9'], {
          flags: {myflag: Flags.boolean(), second: Flags.integer({char: 's'})},
        })
        expect(out.flags.myflag).to.be.true
        expect(out.flags.second).to.equal(-9)
      })

      it("doesn't throw when boolean short char is passed", async () => {
        const out = await parse(['--myflag', '-s', 'value'], {
          flags: {myflag: Flags.boolean(), second: Flags.string({char: 's'})},
        })
        expect(out.flags.myflag).to.be.true
        expect(out.flags.second).to.equal('value')
      })

      it("doesn't throw when  short char is passed as a string value", async () => {
        const out = await parse(['--myflag', "'-s'", '-s', 'value'], {
          flags: {myflag: Flags.string(), second: Flags.string({char: 's'})},
        })
        expect(out.flags.myflag).to.equal("'-s'")
        expect(out.flags.second).to.equal('value')
      })

      it('parses short flags', async () => {
        const out = await parse(['-mf'], {
          flags: {
            force: Flags.boolean({char: 'f'}),
            myflag: Flags.boolean({char: 'm'}),
          },
        })
        expect(Boolean(out.flags.myflag)).to.equal(true)
        expect(Boolean(out.flags.force)).to.equal(true)
      })
    })

    it('parses flag value with "=" to separate', async () => {
      const out = await parse(['--myflag=foo'], {
        flags: {
          myflag: Flags.string({char: 'm'}),
        },
      })
      expect(out.flags).to.deep.equal({myflag: 'foo'})
    })

    it('parses flag value with "=" in value', async () => {
      const out = await parse(['--myflag', '=foo'], {
        flags: {
          myflag: Flags.string({char: 'm'}),
        },
      })
      expect(out.flags).to.deep.equal({myflag: '=foo'})
    })

    it('parses short flag value with "="', async () => {
      const out = await parse(['-m=foo'], {
        flags: {
          myflag: Flags.string({char: 'm'}),
        },
      })
      expect(out.flags).to.deep.equal({myflag: 'foo'})
    })

    it('parses value of ""', async () => {
      const out = await parse(['-m', ''], {
        flags: {
          myflag: Flags.string({char: 'm'}),
        },
      })
      expect(out.flags).to.deep.equal({myflag: ''})
    })

    it('requires required flag', async () => {
      let message = ''
      try {
        await parse([], {
          flags: {
            myflag: Flags.string({
              description: 'flag description',
              required: true,
            }),
          },
        })
      } catch (error: any) {
        message = ansis.strip(error.message)
      }

      expect(message).to.include('Missing required flag myflag')
    })

    it('removes flags from argv', async () => {
      const out = await parse(['--myflag', 'bar', 'foo'], {
        args: {myarg: Args.string()},
        flags: {myflag: Flags.string()},
      })
      expect(out.flags).to.deep.equal({myflag: 'bar'})
      expect(out.argv).to.deep.equal(['foo'])
    })

    describe('args', () => {
      it('requires required args with names', async () => {
        let message = ''
        try {
          await parse(['arg1'], {
            args: {
              arg1: Args.string({required: true}),
              arg2: Args.string({required: true, description: 'arg2 desc', options: ['a', 'b']}),
              arg3: Args.string({required: true, description: 'arg3 desc'}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include(`Missing 2 required args:
arg2  (a|b) arg2 desc
arg3  arg3 desc
See more help with --help`)
      })

      it('warns about having one flag with multiple values when missing an arg', async () => {
        let message = ''
        try {
          await parse(['--flag1', 'val1', 'arg1'], {
            args: {
              arg1: Args.string({required: true, description: 'arg1 desc'}),
            },
            flags: {
              flag1: Flags.string({multiple: true}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include(`Missing 1 required arg:
arg1  arg1 desc

Note: --flag1 allows multiple values. Because of this you need to provide all arguments before providing that flag.
Alternatively, you can use "--" to signify the end of the flags and the beginning of arguments.
See more help with --help`)
      })

      it('warns about having many flags with multiple values when missing an arg', async () => {
        let message = ''
        try {
          await parse(['--flag1', 'val1', '--flag2', 'val1', 'val2', 'arg1'], {
            args: {
              arg1: Args.string({required: true, description: 'arg1 desc'}),
            },
            flags: {
              flag1: Flags.string({multiple: true}),
              flag2: Flags.string({multiple: true}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include(`Missing 1 required arg:
arg1  arg1 desc

Note: --flag1, --flag2 allow multiple values. Because of this you need to provide all arguments before providing those flags.
Alternatively, you can use "--" to signify the end of the flags and the beginning of arguments.
See more help with --help`)
      })

      it('too many args', async () => {
        let message = ''
        try {
          await parse(['arg1', 'arg2'], {
            args: {
              arg1: Args.string({required: true}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include('Unexpected argument: arg2')
      })

      it('parses args', async () => {
        const out = await parse(['foo', 'bar'], {
          args: {myarg: Args.string(), myarg2: Args.string()},
        })
        expect(out.argv).to.deep.equal(['foo', 'bar'])
      })

      it('skips optional args', async () => {
        const out = await parse(['foo'], {
          args: {myarg: Args.string(), myarg2: Args.string()},
        })
        expect(out.argv).to.deep.equal(['foo'])
      })

      it('skips non-required args', async () => {
        const out = await parse(['foo'], {
          args: {myarg: Args.string(), myarg2: Args.string()},
        })
        expect(out.argv).to.deep.equal(['foo'])
      })

      it('throws an error when parsing a non-existent flag', async () => {
        try {
          await parse(['arg', '--foo'], {
            args: {
              myArg: Args.string(),
            },
          })
          assert.fail('should have thrown')
        } catch (error) {
          const err = error as Error
          expect(err.message).to.include('Nonexistent flag: --foo')
        }
      })

      it('parses negative number arg', async () => {
        const out = await parse(['-119.1949853', '34.14986578'], {
          args: {longitude: Args.string(), latitude: Args.string()},
        })
        expect(out.argv).to.deep.equal(['-119.1949853', '34.14986578'])
      })

      it('parses - as an arg', async () => {
        const out = await parse(['-'], {
          args: {myarg: Args.string()},
        })
        expect(out.argv).to.deep.equal(['-'])
      })
    })

    describe('args - no args passed in, with defaults', () => {
      it('two args: only first is required, only second has a default', async () => {
        let message = ''
        try {
          await parse([], {
            args: {
              arg1: Args.string({required: true}),
              arg2: Args.string({required: false, default: 'some_default'}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include(`Missing 1 required arg:
arg1
See more help with --help`)
      })

      it('two args: only first is required, only first has a default', async () => {
        await parse([], {
          args: {
            arg1: Args.string({required: true, default: 'my_default'}),
            arg2: Args.string({required: false}),
          },
        })
        // won't reach here if thrown
        expect(() => {}).to.not.throw()
      })

      it('two args: both have a default, only first is required', async () => {
        await parse([], {
          args: {
            arg1: Args.string({required: true, default: 'my_default'}),
            arg2: Args.string({required: false, default: 'some_default'}),
          },
        })
        // won't reach here if thrown
        expect(() => {}).to.not.throw()
      })
    })

    describe('optional args should always be after required args', () => {
      it('required arg after optional arg', async () => {
        let message = ''
        try {
          await parse([], {
            args: {
              arg1: Args.string({required: false}),
              arg2: Args.string({required: true, default: 'some_default'}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include(`Invalid argument spec:
arg1 (optional)
arg2 (required)
See more help with --help`)
      })

      it('required arg after multiple optional args', async () => {
        let message = ''
        try {
          await parse([], {
            args: {
              arg1: Args.string({required: false}),
              arg2: Args.string({required: false, default: 'my_default'}),
              arg3: Args.string({required: false}),
              arg4: Args.string({required: true}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include(`Invalid argument spec:
arg1 (optional)
arg2 (optional)
arg3 (optional)
arg4 (required)
See more help with --help`)
      })
    })

    describe('multiple flags', () => {
      it('parses multiple flags', async () => {
        const out = await parse(['--bar', 'a', '--bar=b', '--foo=c', '--baz=d'], {
          flags: {
            foo: Flags.string(),
            bar: Flags.string({multiple: true, required: true}),
            baz: Flags.string({required: true}),
          },
        })
        expect(out.flags.foo!.toUpperCase()).to.equal('C')
        expect(out.flags.baz.toUpperCase()).to.equal('D')
        expect(out.flags.bar.join('|')).to.equal('a|b')
      })

      it('parses multiple flags on custom flags', async () => {
        const out = await parse(['--foo', 'a', '--foo=b'], {
          flags: {
            foo: Flags.custom({multiple: true, parse: async (i) => i})(),
          },
        })
        expect(out.flags).to.deep.include({foo: ['a', 'b']})
      })

      it(`parses single flag starting with with escape char`, async () => {
        const out = await parse(['--foo', String.raw`\file:foo`], {
          flags: {
            foo: Flags.custom({multiple: true})(),
          },
        })
        expect(out.flags).to.deep.include({foo: [String.raw`\file:foo`]})
      })

      it('parses multiple space-delimited flags', async () => {
        const out = await parse(['--foo', 'a', 'b', 'c'], {
          flags: {foo: Flags.string({multiple: true})},
        })
        expect(out.flags).to.deep.include({foo: ['a', 'b', 'c']})
      })

      it(`parses multiple space-delimited flags ending with with escape char`, async () => {
        const out = await parse(['--foo', 'c:\\', 'd:\\'], {
          flags: {foo: Flags.string({multiple: true})},
        })
        expect(out.flags).to.deep.include({foo: ['c:\\', 'd:\\']})
      })

      it(`parses multiple space-delimited flags ending with with escape char`, async () => {
        const out = await parse(['--foo', 'c:\\', 'd:\\'], {
          flags: {foo: Flags.string({multiple: true})},
        })
        expect(out.flags).to.deep.include({foo: ['c:\\', 'd:\\']})
      })

      it('allowed options on multiple', async () => {
        const out = await parse(['--foo', 'a', '--foo=b'], {
          flags: {
            foo: Flags.string({multiple: true, parse: async (i) => i, options: ['a', 'b']}),
          },
        })
        expect(out.flags).to.deep.include({foo: ['a', 'b']})
      })

      it('one of allowed options on multiple', async () => {
        const out = await parse(['--foo', 'a'], {
          flags: {
            foo: Flags.string({multiple: true, options: ['a', 'b']}),
          },
        })
        expect(out.flags).to.deep.include({foo: ['a']})
      })

      it('throws if non-allowed options on multiple', async () => {
        try {
          await parse(['--foo', 'a', '--foo=c'], {
            flags: {
              foo: Flags.string({multiple: true, options: ['a', 'b']}),
            },
          })
        } catch (error: any) {
          expect(error.message).to.include('Expected --foo=c to be one of: a, b')
        }
      })

      describe('comma delimiter', () => {
        it('basic', async () => {
          const out = await parse(['--foo', 'a,b'], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a', 'b']})
        })

        it('preserves non-exterior double quotes (single and pairs)', async () => {
          const out = await parse(['--foo', 'a,",b,hi"yo"'], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a', '"', 'b', 'hi"yo"']})
        })

        it('preserves non-exterior single quotes (single and pairs)', async () => {
          const out = await parse(['--foo', "a,',b,hi'yo'"], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a', "'", 'b', "hi'yo'"]})
        })

        it('with spaces inside double quotes', async () => {
          const out = await parse(['--foo', '"a a","b b"'], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a a', 'b b']})
        })

        it('with spaces inside single quotes', async () => {
          const out = await parse(['--foo', "'a a','b b'"], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a a', 'b b']})
        })

        it('with options', async () => {
          const out = await parse(['--foo', 'a,b'], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ',', options: ['a', 'b']}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a', 'b']})
        })

        it('throws if non-allowed options on multiple', async () => {
          try {
            await parse(['--foo', 'a,c'], {
              flags: {
                foo: Flags.string({multiple: true, options: ['a', 'b']}),
              },
            })
          } catch (error: any) {
            expect(error.message).to.include('Expected --foo=a,c to be one of: a, b')
          }
        })

        it('with options and double quotes with spaces', async () => {
          const out = await parse(['--foo', '"a a","b b"'], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ',', options: ['a a', 'b b']}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a a', 'b b']})
        })

        it('with options and single quotes with spaces', async () => {
          const out = await parse(['--foo', "'a a','b b'"], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ',', options: ['a a', 'b b']}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a a', 'b b']})
        })

        it('throws if non-allowed with options and double quotes with spaces', async () => {
          try {
            await parse(['--foo', '"a a","b c"'], {
              flags: {
                foo: Flags.string({multiple: true, delimiter: ',', options: ['a a', 'b b']}),
              },
            })
          } catch (error: any) {
            expect(error.message).to.include('Expected --foo=b c to be one of: a a, b b')
          }
        })

        it('throws if non-allowed with options and single quotes with spaces', async () => {
          try {
            await parse(['--foo', "'a a','b c'"], {
              flags: {
                foo: Flags.string({multiple: true, delimiter: ',', options: ['a a', 'b b']}),
              },
            })
          } catch (error: any) {
            expect(error.message).to.include('Expected --foo=b c to be one of: a a, b b')
          }
        })

        it('retains escape char without delimiter', async () => {
          const out = await parse(['--foo', 'a\\'], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a\\']})
        })

        it('does not split on escaped delimiter', async () => {
          const out = await parse(['--foo', String.raw`a\,b,c`], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a,b', 'c']})
        })

        it('escapes with multiple invocation', async () => {
          const out = await parse(['--foo', String.raw`a\,b`, '--foo', 'b'], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: ['a,b', 'b']})
        })

        it('comma-escaped stringified json', async () => {
          const val = String.raw`{"a":"b"\,"c":"d"}`
          const expected = '{"a":"b","c":"d"}'
          const out = await parse(['--foo', val], {
            flags: {
              foo: Flags.string({multiple: true, delimiter: ','}),
            },
          })
          expect(out.flags).to.deep.include({foo: [expected]})
        })
      })
    })

    describe('multiple flags with single value', () => {
      it('parses multiple flags with single value', async () => {
        const out = await parse(['--bar', 'a', 'b', '--bar=c', '--baz=d', 'e'], {
          args: {argOne: Args.string()},
          flags: {
            bar: Flags.string({multiple: true, multipleNonGreedy: true}),
            baz: Flags.string({multiple: true}),
          },
        })
        expect(out.flags.baz?.join('|')).to.equal('d|e')
        expect(out.flags.bar?.join('|')).to.equal('a|c')
        expect(out.args).to.deep.equal({argOne: 'b'})
      })

      it('parses multiple flags with single value multiple args', async () => {
        const out = await parse(['c', '--bar', 'a', 'b'], {
          args: {argOne: Args.string(), argTwo: Args.string()},
          flags: {
            bar: Flags.string({multiple: true, multipleNonGreedy: true}),
          },
        })
        expect(out.flags.bar?.join('|')).to.equal('a')
        expect(out.args).to.deep.equal({argOne: 'c', argTwo: 'b'})
      })

      it('fails to parse with single value and no args option', async () => {
        let message = ''

        try {
          await parse(['--bar', 'a', 'b'], {
            flags: {
              bar: Flags.string({multiple: true, multipleNonGreedy: true}),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include('Unexpected argument: b')
      })
    })

    describe('strict: false', () => {
      it('skips flag parsing after "--"', async () => {
        const out = await parse(['foo', 'bar', '--', '--myflag'], {
          args: {argOne: Args.string()},
          flags: {myflag: Flags.boolean()},
          strict: false,
        })
        expect(out.argv).to.deep.equal(['foo', 'bar', '--myflag'])
        expect(out.args).to.deep.equal({argOne: 'foo'})
      })

      describe('--: false', () => {
        it('can be disabled', async () => {
          const out = await parse(['foo', 'bar', '--', '--myflag'], {
            args: {argOne: Args.string()},
            strict: false,
            '--': false,
          })
          expect(out.argv).to.deep.equal(['foo', 'bar', '--', '--myflag'])
          expect(out.args).to.deep.equal({argOne: 'foo'})
        })
      })

      it('does not repeat arguments', async () => {
        const out = await parse(['foo', '--myflag=foo bar'], {
          strict: false,
          flags: {
            myflag: Flags.string(),
          },
        })

        expect(out.argv).to.deep.equal(['foo'])
        expect(out.flags).to.deep.equal({myflag: 'foo bar'})
      })
    })

    describe('integer flag', () => {
      it('parses integers', async () => {
        const out = await parse(['--int', '100'], {
          flags: {int: Flags.integer(), s: Flags.string()},
        })
        expect(out.flags).to.deep.include({int: 100})
      })

      it('parses zero', async () => {
        const out = await parse(['--int', '0'], {
          flags: {int: Flags.integer(), s: Flags.string()},
        })
        expect(out.flags).to.deep.include({int: 0})
      })

      it('parses negative integers', async () => {
        const out = await parse(['--int', '-123'], {
          flags: {int: Flags.integer(), s: Flags.string()},
        })
        expect(out.flags).to.deep.include({int: -123})
      })

      it('does not parse floats', async () => {
        let message = ''
        try {
          await parse(['--int', '3.14'], {
            flags: {int: Flags.integer()},
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include('Parsing --int \n\tExpected an integer but received: 3.14')
      })

      it('does not parse fractions', async () => {
        let message = ''
        try {
          await parse(['--int', '3/4'], {
            flags: {int: Flags.integer()},
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include('Parsing --int \n\tExpected an integer but received: 3/4')
      })

      it('does not parse strings', async () => {
        let message = ''
        try {
          await parse(['--int', 's10'], {
            flags: {int: Flags.integer()},
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include('Parsing --int \n\tExpected an integer but received: s10')
      })

      describe('min/max', () => {
        it('min pass equal', async () => {
          const out = await parse(['--int', '10'], {
            flags: {int: Flags.integer({min: 10, max: 20})},
          })
          expect(out.flags).to.deep.include({int: 10})
        })

        it('min pass gt', async () => {
          const out = await parse(['--int', '11'], {
            flags: {int: Flags.integer({min: 10, max: 20})},
          })
          expect(out.flags).to.deep.include({int: 11})
        })

        it('max pass lt', async () => {
          const out = await parse(['--int', '19'], {
            flags: {int: Flags.integer({min: 10, max: 20})},
          })
          expect(out.flags).to.deep.include({int: 19})
        })

        it('max pass equal', async () => {
          const out = await parse(['--int', '20'], {
            flags: {int: Flags.integer({min: 10, max: 20})},
          })
          expect(out.flags).to.deep.include({int: 20})
        })

        it('min fail lt', async () => {
          let message = ''
          try {
            await parse(['--int', '9'], {
              flags: {int: Flags.integer({min: 10, max: 20})},
            })
          } catch (error: any) {
            message = error.message
          }

          expect(message).to.include(
            'Parsing --int \n\tExpected an integer greater than or equal to 10 but received: 9',
          )
        })

        it('max fail gt', async () => {
          let message = ''
          try {
            await parse(['--int', '21'], {
              flags: {int: Flags.integer({min: 10, max: 20})},
            })
          } catch (error: any) {
            message = error.message
          }

          expect(message).to.include('Parsing --int \n\tExpected an integer less than or equal to 20 but received: 21')
        })
      })
    })

    describe('custom parse functions', () => {
      const testIntPass = 6
      const testIntFail = 7
      const customParseException = 'NOT_OK'
      const validateEvenNumberString = async (input: string) =>
        Number.parseInt(input, 10) % 2 === 0 ? Number.parseInt(input, 10) : assert.fail(customParseException)

      it('accepts custom parse that passes', async () => {
        const out = await parse([`--int=${testIntPass}`], {
          flags: {int: Flags.integer({parse: validateEvenNumberString})},
        })
        expect(out.flags).to.deep.include({int: testIntPass})
      })

      it('accepts custom parse that fails', async () => {
        try {
          const out = await parse([`--int=${testIntFail}`], {
            flags: {int: Flags.integer({parse: validateEvenNumberString})},
          })
          throw new Error(`Should have thrown an error ${JSON.stringify(out)}`)
        } catch (error_) {
          const error = error_ as Error
          expect(error.message).to.include(`Parsing --int \n\t${customParseException}`)
        }
      })
    })
  })

  describe('parse', () => {
    it('parse', async () => {
      const out = await parse(['--foo=bar', '100'], {
        args: {num: Args.integer()},
        flags: {foo: Flags.string({parse: async (input) => input.toUpperCase()})},
      })
      expect(out.flags).to.deep.include({foo: 'BAR'})
      expect(out.args).to.deep.include({num: 100})
      expect(out.argv).to.deep.equal([100])
    })

    it('parse with a default does not parse default', async () => {
      const out = await parse([], {
        flags: {foo: Flags.string({parse: async (input) => input.toUpperCase(), default: 'baz'})},
      })
      expect(out.flags).to.deep.include({foo: 'baz'})
    })

    describe('parse with a default/value of another type (class)', async () => {
      class TestClass {
        public prop: string
        constructor(input: string) {
          this.prop = input
        }

        public toString(): string {
          return this.prop
        }
      }

      it('uses default via value', async () => {
        const out = await parse([], {
          flags: {
            foo: Flags.custom<TestClass>({
              parse: async (input) => new TestClass(input),
              default: new TestClass('baz'),
            })(),
          },
        })
        expect(out.flags.foo?.prop).to.equal('baz')
      })

      it('uses default via function', async () => {
        const out = await parse([], {
          flags: {
            foo: Flags.custom<TestClass>({
              parse: async (input) => new TestClass(input),
              default: async () => new TestClass('baz'),
            })(),
          },
        })
        expect(out.flags.foo?.prop).to.equal('baz')
      })

      it('should error with exclusive flag violation', async () => {
        try {
          const out = await parse(['--foo', 'baz', '--bar'], {
            flags: {
              foo: Flags.custom<TestClass>({
                parse: async (input) => new TestClass(input),
                defaultHelp: new TestClass('bar'),
              })(),
              bar: Flags.boolean({
                exclusive: ['foo'],
              }),
            },
          })
          expect.fail(`Should have thrown an error ${JSON.stringify(out)}`)
        } catch (error) {
          assert(error instanceof Error)
          expect(error.message).to.include('--foo=bar cannot also be provided when using --bar')
        }
      })

      it('should error with exclusive flag violation and defaultHelp value', async () => {
        try {
          const out = await parse(['--foo', 'baz', '--bar'], {
            flags: {
              foo: Flags.custom<TestClass>({
                parse: async (input) => new TestClass(input),
              })(),
              bar: Flags.boolean({
                exclusive: ['foo'],
              }),
            },
          })
          expect.fail(`Should have thrown an error ${JSON.stringify(out)}`)
        } catch (error) {
          assert(error instanceof Error)
          expect(error.message).to.include('--foo=baz cannot also be provided when using --bar')
        }
      })

      it('uses parser when value provided', async () => {
        const out = await parse(['--foo=bar'], {
          flags: {
            foo: Flags.custom<TestClass>({
              parse: async (input) => new TestClass(input),
              default: new TestClass('baz'),
            })(),
          },
        })
        expect(out.flags.foo?.prop).to.equal('bar')
      })
    })

    // it('gets arg/flag in context', async () => {
    //   const out = await parse({
    //     args: [{ name: 'num', parse: (_, ctx) => ctx.arg.name!.toUpperCase() }],
    //     argv: ['--foo=bar', '100'],
    //     flags: { foo: string({ parse: (_, ctx) => ctx.flag.name.toUpperCase() }) },
    //   })
    //   expect(out.flags).to.deep.include({ foo: 'FOO' })
    //   expect(out.args).to.deep.include({ num: 'NUM' })
    // })
  })

  describe('flag with multiple inputs', () => {
    it('flag multiple with flag in the middle', async () => {
      const out = await parse(['--foo=bar', '--foo', '100', '--hello', 'world'], {
        flags: {foo: Flags.string({multiple: true}), hello: Flags.string()},
      })
      expect(out.flags).to.deep.include({foo: ['bar', '100']})
      expect(out.flags).to.deep.include({hello: 'world'})
    })

    it('flag multiple without flag in the middle', async () => {
      const out = await parse(['--foo', './a.txt', './b.txt', './c.txt', '--hello', 'world'], {
        flags: {
          foo: Flags.string({multiple: true}),
          hello: Flags.string(),
        },
      })
      expect(out.flags).to.deep.include({
        foo: ['./a.txt', './b.txt', './c.txt'],
      })
      expect(out.flags).to.deep.include({hello: 'world'})
    })

    it('flag multiple with arguments', async () => {
      const out = await parse(['--foo', './a.txt', './b.txt', './c.txt', '--', '15'], {
        args: {num: Args.string()},
        flags: {foo: Flags.string({multiple: true})},
      })
      expect(out.flags).to.deep.include({
        foo: ['./a.txt', './b.txt', './c.txt'],
      })
      expect(out.args).to.deep.include({num: '15'})
    })

    it('flag multiple with arguments and custom delimiter and parser', async () => {
      const out = await parse(['--foo', './a.txt,./b.txt', '--foo', './c.txt', '--', '15'], {
        args: {num: Args.string()},
        flags: {
          foo: Flags.string({
            multiple: true,
            delimiter: ',',
            parse: async (input) => input.replace('.txt', '.json'),
          }),
        },
      })
      expect(out.flags).to.deep.include({
        foo: ['./a.json', './b.json', './c.json'],
      })
      expect(out.args).to.deep.include({num: '15'})
    })
  })

  describe('defaults', () => {
    it('generates metadata for defaults', async () => {
      const out = await parse(['-n', 'heroku'], {
        flags: {
          name: Flags.string({
            char: 'n',
          }),
          startup: Flags.string({
            char: 's',
            default: 'apero',
          }),
        },
      })
      expect(out.metadata.flags).to.deep.equal({
        startup: {setFromDefault: true},
      })
    })

    it('defaults', async () => {
      const out = await parse([], {
        args: {baz: Args.string({default: 'BAZ'})},
        flags: {foo: Flags.string({default: 'bar'})},
      })
      expect(out.args).to.deep.include({baz: 'BAZ'})
      expect(out.argv).to.deep.equal(['BAZ'])
      expect(out.flags).to.deep.include({foo: 'bar'})
    })

    it('accepts falsy', async () => {
      const out = await parse([], {
        args: {baz: Args.boolean({default: false})},
      })
      expect(out.args).to.deep.include({baz: false})
    })

    it('accepts falsy flags', async () => {
      const out = await parse([], {
        flags: {
          foo1: Flags.string({default: ''}),
          foo2: Flags.string({default: '0'}),
          foo3: Flags.string({default: 'false'}),
          foo4: Flags.string({default: 'undefined'}),
          bar: Flags.integer({default: 0}),
          baz: Flags.boolean({default: false}),
        },
      })
      expect(out.flags).to.deep.include({foo1: ''})
      expect(out.flags).to.deep.include({foo2: '0'})
      expect(out.flags).to.deep.include({foo3: 'false'})
      expect(out.flags).to.deep.include({foo4: 'undefined'})
      expect(out.flags).to.deep.include({bar: 0})
      expect(out.flags).to.deep.include({baz: false})
    })

    it('default as function', async () => {
      const out = await parse([], {
        args: {baz: Args.string({default: async () => 'BAZ'})},
        flags: {foo: Flags.string({default: async () => 'bar'})},
      })
      expect(out.args).to.deep.include({baz: 'BAZ'})
      expect(out.argv).to.deep.equal(['BAZ'])
      expect(out.flags).to.deep.include({foo: 'bar'})
    })

    it('default has options', async () => {
      const def: FlagDefault<string | undefined> = async ({options}) => options.description
      const out = await parse([], {
        flags: {foo: Flags.string({description: 'bar', default: def})},
      })
      expect(out.flags).to.deep.include({foo: 'bar'})
    })

    it('can default to a different flag', async () => {
      const def: FlagDefault<string | undefined> = async (opts) => opts.flags.foo
      const out = await parse(['--foo=bar'], {
        flags: {
          bar: Flags.string({
            default: def,
          }),
          foo: Flags.string(),
        },
      })
      expect(out.flags).to.deep.include({foo: 'bar', bar: 'bar'})
    })
  })

  describe('boolean defaults', () => {
    it('default is true', async () => {
      const out = await parse([], {
        flags: {
          color: Flags.boolean({default: true}),
        },
      })
      expect(out).to.deep.include({flags: {color: true}})
    })

    it('default is false', async () => {
      const out = await parse([], {
        flags: {
          color: Flags.boolean({default: false}),
        },
      })
      expect(out).to.deep.include({flags: {color: false}})
    })

    it('default as function', async () => {
      const out = await parse([], {
        flags: {
          color: Flags.boolean({default: async () => true}),
        },
      })
      expect(out).to.deep.include({flags: {color: true}})
    })

    it('overridden true default', async () => {
      const out = await parse(['--no-color'], {
        flags: {
          color: Flags.boolean({allowNo: true, default: true}),
        },
      })
      expect(out).to.deep.include({flags: {color: false}})
    })

    it('overridden false default', async () => {
      const out = await parse(['--color'], {
        flags: {
          color: Flags.boolean({default: false}),
        },
      })
      expect(out).to.deep.include({flags: {color: true}})
    })
  })

  describe('custom option', () => {
    it('can pass parse fn', async () => {
      const foo = Flags.custom({char: 'f', parse: async () => 100})()
      const out = await parse(['-f', 'bar'], {
        flags: {foo},
      })
      expect(out.flags).to.deep.include({foo: 100})
    })
  })

  describe('build', () => {
    it('can pass parse fn', async () => {
      const foo = Flags.custom({char: 'f', parse: async () => 100})
      const out = await parse(['-f', 'bar'], {
        flags: {foo: foo()},
      })
      expect(out.flags).to.deep.include({foo: 100})
    })

    it('does not require parse fn', async () => {
      const foo = Flags.custom({char: 'f'})
      const out = await parse(['-f', 'bar'], {
        flags: {foo: foo()},
      })
      expect(out.flags).to.deep.include({foo: 'bar'})
    })
  })

  describe('flag options', () => {
    it('accepts valid option', async () => {
      const out = await parse(['--foo', 'myotheropt'], {
        flags: {foo: Flags.string({options: ['myopt', 'myotheropt']})},
      })
      expect(out.flags.foo).to.equal('myotheropt')
    })

    it('fails when invalid', async () => {
      let message = ''
      try {
        await parse(['--foo', 'invalidopt'], {
          flags: {foo: Flags.string({options: ['myopt', 'myotheropt']})},
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('Expected --foo=invalidopt to be one of: myopt, myotheropt')
    })

    it('fails when invalid env var', async () => {
      let message = ''
      process.env.TEST_FOO = 'invalidopt'
      try {
        await parse([], {
          flags: {foo: Flags.string({options: ['myopt', 'myotheropt'], env: 'TEST_FOO'})},
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('Expected --foo=invalidopt to be one of: myopt, myotheropt')
    })

    it('accepts valid option env var', async () => {
      process.env.TEST_FOO = 'myopt'

      const out = await parse([], {
        flags: {foo: Flags.string({options: ['myopt', 'myotheropt'], env: 'TEST_FOO'})},
      })
      expect(out.flags.foo).to.equal('myopt')
    })
  })

  describe('url flag', () => {
    it('accepts valid url', async () => {
      const out = await parse(['--foo', 'https://example.com'], {
        flags: {foo: Flags.url()},
      })
      expect(out.flags.foo).to.be.instanceOf(URL)
      expect(out.flags.foo?.href).to.equal('https://example.com/')
    })

    it('fails when invalid', async () => {
      let message = ''
      try {
        await parse(['--foo', 'example'], {
          flags: {foo: Flags.url()},
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('Parsing --foo \n\tExpected a valid url but received: example')
    })
  })

  describe('arg options', () => {
    it('accepts valid option', async () => {
      const out = await parse(['myotheropt'], {
        args: {foo: Args.string({options: ['myopt', 'myotheropt']})},
      })
      expect(out.args.foo).to.equal('myotheropt')
    })

    it('fails when invalid', async () => {
      let message = ''
      try {
        await parse(['invalidopt'], {
          args: {foo: Args.string({options: ['myopt', 'myotheropt']})},
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('Expected invalidopt to be one of: myopt, myotheropt')
    })
  })

  describe('env', () => {
    describe('string', () => {
      it('accepts as environment variable', async () => {
        process.env.TEST_FOO = '101'
        const out = await parse([], {
          flags: {foo: Flags.string({env: 'TEST_FOO'})},
        })
        expect(out.flags.foo).to.equal('101')
        delete process.env.TEST_FOO
      })
    })

    describe('boolean', () => {
      const truthy = ['true', 'TRUE', '1', 'yes', 'YES', 'y', 'Y']
      for (const value of truthy) {
        it(`accepts '${value}' as a truthy environment variable`, async () => {
          process.env.TEST_FOO = value
          const out = await parse([], {
            flags: {
              foo: Flags.boolean({env: 'TEST_FOO'}),
            },
          })
          expect(out.flags.foo).to.be.true
          delete process.env.TEST_FOO
        })
      }

      const falsy = ['false', 'FALSE', '0', 'no', 'NO', 'n', 'N']
      for (const value of falsy) {
        it(`accepts '${value}' as a falsy environment variable`, async () => {
          process.env.TEST_FOO = value
          const out = await parse([], {
            flags: {
              foo: Flags.boolean({env: 'TEST_FOO'}),
            },
          })
          expect(out.flags.foo).to.be.false
          delete process.env.TEST_FOO
        })
      }

      it('ignores unset environment variables', async () => {
        delete process.env.TEST_FOO
        const out = await parse([], {
          flags: {
            foo: Flags.boolean({env: 'TEST_FOO'}),
          },
        })
        expect(out.flags.foo).to.be.undefined
      })

      it('uses default when environment variable is unset', async () => {
        delete process.env.TEST_FOO
        const out = await parse([], {
          flags: {
            foo: Flags.boolean({env: 'TEST_FOO', default: true}),
          },
        })
        expect(out.flags.foo).to.be.true
      })
    })
  })

  describe('flag context', () => {
    it('accepts context in parse', async () => {
      const out = await parse(['--foo'], {
        // @ts-expect-error
        context: {a: 101},
        flags: {
          foo: Flags.boolean({
            parse: async (_: any, ctx: any) => ctx.a,
          }),
        },
      })
      expect(out.flags.foo).to.equal(101)
    })
  })

  it('throws an error when multiple flags of non-multiple flag is provided', async () => {
    let message = ''
    try {
      await parse(['--foo=a', '--foo', 'b'], {
        flags: {foo: Flags.string()},
      })
    } catch (error: any) {
      message = error.message
    }

    expect(message).to.include('can only be specified once')
  })

  describe('dependsOn', () => {
    it('ignores', async () => {
      await parse([], {
        flags: {
          foo: Flags.string({dependsOn: ['bar']}),
          bar: Flags.string({char: 'b'}),
        },
      })
    })

    it('succeeds', async () => {
      const out = await parse(['--foo', 'a', '-bb'], {
        flags: {
          foo: Flags.string({dependsOn: ['bar']}),
          bar: Flags.string({char: 'b'}),
        },
      })
      expect(out.flags.foo).to.equal('a')
      expect(out.flags.bar).to.equal('b')
    })

    it('fails', async () => {
      let message = ''
      try {
        await parse(['--foo', 'a'], {
          flags: {
            foo: Flags.string({dependsOn: ['bar']}),
            bar: Flags.string({char: 'b'}),
          },
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('All of the following must be provided when using --foo: --bar')
    })
  })

  describe('exclusive', () => {
    it('ignores', async () => {
      await parse([], {
        flags: {
          foo: Flags.string({exclusive: ['bar']}),
          bar: Flags.string({char: 'b'}),
        },
      })
    })

    it('succeeds', async () => {
      const out = await parse(['--foo', 'a'], {
        flags: {
          foo: Flags.string({exclusive: ['bar']}),
          bar: Flags.string({char: 'b'}),
        },
      })
      expect(out.flags.foo).to.equal('a')
    })

    it('fails', async () => {
      let message = ''
      try {
        await parse(['--foo', 'a', '-bb'], {
          flags: {
            foo: Flags.string({exclusive: ['bar']}),
            bar: Flags.string({char: 'b'}),
          },
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('--bar=b cannot also be provided when using --foo')
    })
  })

  describe('exactlyOne', () => {
    it('throws if neither is set', async () => {
      let message = ''
      try {
        await parse([], {
          flags: {
            foo: Flags.string({exactlyOne: ['bar', 'foo']}),
            bar: Flags.string({char: 'b', exactlyOne: ['bar', 'foo']}),
          },
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('Exactly one of the following must be provided: --bar, --foo')
    })

    it('throws if multiple are set', async () => {
      let message = ''
      try {
        await parse(['--foo', 'a', '--bar', 'b'], {
          flags: {
            foo: Flags.string({exactlyOne: ['bar']}),
            bar: Flags.string({char: 'b', exactlyOne: ['foo']}),
          },
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('The following errors occurred:')
      expect(message).to.include('--bar cannot also be provided when using --foo')
      expect(message).to.include('--foo cannot also be provided when using --bar')
    })

    it('succeeds if exactly one', async () => {
      const out = await parse(['--foo', 'a', '--else', '4'], {
        flags: {
          foo: Flags.string({exactlyOne: ['bar']}),
          bar: Flags.string({char: 'b', exactlyOne: ['foo']}),
          else: Flags.string({char: 'e'}),
        },
      })
      expect(out.flags.foo).to.equal('a')
    })

    it('succeeds if exactly one (the other option)', async () => {
      const out = await parse(['--bar', 'b', '--else', '4'], {
        flags: {
          foo: Flags.string({exactlyOne: ['bar']}),
          bar: Flags.string({char: 'b', exactlyOne: ['foo']}),
          else: Flags.string({char: 'e'}),
        },
      })
      expect(out.flags.bar).to.equal('b')
    })

    it('succeeds if exactly one of three', async () => {
      const out = await parse(['--bar', 'b'], {
        flags: {
          foo: Flags.string({exactlyOne: ['bar', 'else']}),
          bar: Flags.string({char: 'b', exactlyOne: ['foo', 'else']}),
          else: Flags.string({char: 'e', exactlyOne: ['foo', 'bar']}),
        },
      })
      expect(out.flags.bar).to.equal('b')
    })

    it('lets user list flag in its own list', async () => {
      const out = await parse(['--bar', 'b'], {
        flags: {
          foo: Flags.string({exactlyOne: ['foo', 'bar', 'else']}),
          bar: Flags.string({char: 'b', exactlyOne: ['foo', 'bar', 'else']}),
          else: Flags.string({char: 'e', exactlyOne: ['foo', 'bar', 'else']}),
        },
      })
      expect(out.flags.bar).to.equal('b')
    })

    it('fails if multiple of three', async () => {
      let message = ''
      try {
        await parse(['--foo', 'a', '--else', '4'], {
          flags: {
            foo: Flags.string({exactlyOne: ['bar', 'else']}),
            bar: Flags.string({char: 'b', exactlyOne: ['foo', 'else']}),
            else: Flags.string({char: 'e', exactlyOne: ['foo', 'bar']}),
          },
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('The following errors occurred:')
      expect(message).to.include('--else cannot also be provided when using --foo')
      expect(message).to.include('--foo cannot also be provided when using --else')
    })

    it("handles cross-references/pairings that don't make sense", async () => {
      const crazyFlags = {
        foo: Flags.string({exactlyOne: ['bar']}),
        bar: Flags.string({char: 'b', exactlyOne: ['else']}),
        else: Flags.string({char: 'e'}),
      }
      let message1 = ''
      try {
        await parse(['--foo', 'a', '--bar', '4'], {
          flags: crazyFlags,
        })
      } catch (error: any) {
        message1 = error.message
      }

      expect(message1).to.include('--bar cannot also be provided when using --foo')

      let message2 = ''
      try {
        await parse(['--bar', 'a', '--else', '4'], {
          flags: crazyFlags,
        })
      } catch (error: any) {
        message2 = error.message
      }

      expect(message2).to.include('--else cannot also be provided when using --bar')

      const out = await parse(['--foo', 'a', '--else', '4'], {
        flags: crazyFlags,
      })
      expect(out.flags.foo).to.equal('a')
      expect(out.flags.else).to.equal('4')
      expect(out.flags.bar).to.equal(undefined)
    })
  })

  describe('atLeastOne', () => {
    it('throws if none are set', async () => {
      let message = ''
      try {
        await parse([], {
          flags: {
            foo: Flags.string({atLeastOne: ['foo', 'bar']}),
            bar: Flags.string({char: 'b', atLeastOne: ['foo', 'bar']}),
          },
        })
      } catch (error: any) {
        message = error.message
      }

      expect(message).to.include('At least one of the following must be provided: --bar, --foo')
    })

    it('succeeds if one is set', async () => {
      const out = await parse(['--foo', 'a'], {
        flags: {
          foo: Flags.string({atLeastOne: ['foo', 'bar', 'baz']}),
          bar: Flags.string({char: 'b', atLeastOne: ['foo', 'bar', 'baz']}),
          baz: Flags.string({char: 'z'}),
        },
      })
      expect(out.flags.foo).to.equal('a')
    })

    it('succeeds if some are set', async () => {
      const out = await parse(['--foo', 'a', '--bar', 'b'], {
        flags: {
          foo: Flags.string({atLeastOne: ['foo', 'bar', 'baz']}),
          bar: Flags.string({char: 'b', atLeastOne: ['foo', 'bar', 'baz']}),
          baz: Flags.string({char: 'z'}),
        },
      })
      expect(out.flags.foo).to.equal('a')
      expect(out.flags.bar).to.equal('b')
    })

    it('succeeds if all are set', async () => {
      const out = await parse(['--foo', 'a', '--bar', 'b', '--baz', 'c'], {
        flags: {
          foo: Flags.string({atLeastOne: ['foo', 'bar', 'baz']}),
          bar: Flags.string({char: 'b', atLeastOne: ['foo', 'bar', 'baz']}),
          baz: Flags.string({char: 'z'}),
        },
      })
      expect(out.flags.foo).to.equal('a')
      expect(out.flags.bar).to.equal('b')
      expect(out.flags.baz).to.equal('c')
    })
  })

  describe('allowNo', () => {
    it('is undefined if not set', async () => {
      const out = await parse([], {
        flags: {
          foo: Flags.boolean({allowNo: true}),
        },
      })
      expect(out.flags.foo).to.equal(undefined)
    })

    it('is false', async () => {
      const out = await parse(['--no-foo'], {
        flags: {
          foo: Flags.boolean({allowNo: true}),
        },
      })
      expect(out.flags.foo).to.equal(false)
    })

    it('is true', async () => {
      const out = await parse(['--foo'], {
        flags: {
          foo: Flags.boolean({allowNo: true}),
        },
      })
      expect(out.flags.foo).to.equal(true)
    })
  })

  describe('fs flags', () => {
    let statStub: sinon.SinonStub

    beforeEach(() => {
      statStub = sinon.stub(fs.promises, 'stat')
    })

    afterEach(() => {
      sinon.restore()
    })

    describe('directory', () => {
      const testDir = 'some/dir'

      it('passes if dir !exists but exists:false', async () => {
        const out = await parse([`--dir=${testDir}`], {
          flags: {dir: Flags.directory({exists: false})},
        })
        expect(out.flags).to.deep.include({dir: testDir})
      })

      it('passes if dir !exists but exists not defined', async () => {
        const out = await parse([`--dir=${testDir}`], {
          flags: {dir: Flags.directory()},
        })
        expect(out.flags).to.deep.include({dir: testDir})
      })

      it('passes when dir exists', async () => {
        statStub.returns({isDirectory: () => true})
        const out = await parse([`--dir=${testDir}`], {
          flags: {dir: Flags.directory({exists: true})},
        })
        expect(out.flags).to.deep.include({dir: testDir})
      })

      it("fails when dir doesn't exist", async () => {
        statStub.throws()
        try {
          const out = await parse([`--dir=${testDir}`], {
            flags: {dir: Flags.directory({exists: true})},
          })
          throw new Error(`Should have thrown an error ${JSON.stringify(out)}`)
        } catch (error_) {
          const error = error_ as Error
          expect(error.message).to.include(`Parsing --dir \n\tNo directory found at ${testDir}`)
        }
      })

      it('fails when dir exists but is not a dir', async () => {
        statStub.returns({isDirectory: () => false})
        try {
          const out = await parse([`--dir=${testDir}`], {
            flags: {dir: Flags.directory({exists: true})},
          })
          throw new Error(`Should have thrown an error ${JSON.stringify(out)}`)
        } catch (error_) {
          const error = error_ as Error
          expect(error.message).to.include(`Parsing --dir \n\t${testDir} exists but is not a directory`)
        }
      })

      describe('custom parse functions', () => {
        const customParseException = 'NOT_OK'

        it('accepts custom parse that passes', async () => {
          statStub.returns({isDirectory: () => true})
          const out = await parse([`--dir=${testDir}`], {
            flags: {
              dir: Flags.directory({
                exists: true,
                parse: async (input) => (input.includes('some') ? input : assert.fail(customParseException)),
              }),
            },
          })
          expect(out.flags).to.deep.include({dir: testDir})
        })

        it('accepts custom parse that fails', async () => {
          statStub.returns({isDirectory: () => true})
          try {
            const out = await parse([`--dir=${testDir}`], {
              flags: {
                dir: Flags.directory({
                  exists: true,
                  parse: async (input) => (input.includes('NOT_THERE') ? input : assert.fail(customParseException)),
                }),
              },
            })
            throw new Error(`Should have thrown an error ${JSON.stringify(out)}`)
          } catch (error_) {
            const error = error_ as Error
            expect(error.message).to.include(`Parsing --dir \n\t${customParseException}`)
          }
        })
      })
    })

    describe('file', () => {
      const testFile = 'some/file.ext'

      it("passes if file doesn't exist but not exists:true", async () => {
        const out = await parse([`--file=${testFile}`], {
          flags: {file: Flags.file({exists: false})},
        })
        expect(out.flags).to.deep.include({file: testFile})
      })

      it("passes if file doesn't exist but not exists not defined", async () => {
        const out = await parse([`--file=${testFile}`], {
          flags: {file: Flags.file()},
        })
        expect(out.flags).to.deep.include({file: testFile})
      })

      it('passes when file exists', async () => {
        statStub.returns({isFile: () => true})
        const out = await parse([`--file=${testFile}`], {
          flags: {file: Flags.file({exists: true})},
        })
        expect(out.flags).to.deep.include({file: testFile})
      })

      it("fails when dir doesn't exist", async () => {
        statStub.throws()
        try {
          const out = await parse([`--file=${testFile}`], {
            flags: {file: Flags.file({exists: true})},
          })
          throw new Error(`Should have thrown an error ${JSON.stringify(out)}`)
        } catch (error_) {
          const error = error_ as Error
          expect(error.message).to.include(`Parsing --file \n\tNo file found at ${testFile}`)
        }
      })

      it('fails when file exists but is not a file', async () => {
        statStub.returns({isFile: () => false})
        try {
          const out = await parse([`--file=${testFile}`], {
            flags: {file: Flags.file({exists: true})},
          })
          throw new Error(`Should have thrown an error ${JSON.stringify(out)}`)
        } catch (error_) {
          const error = error_ as Error
          expect(error.message).to.include(`Parsing --file \n\t${testFile} exists but is not a file`)
        }
      })

      describe('custom parse functions', () => {
        const customParseException = 'NOT_OK'

        it('accepts custom parse that passes', async () => {
          statStub.returns({isFile: () => true})
          const out = await parse([`--dir=${testFile}`], {
            flags: {
              dir: Flags.file({
                exists: false,
                parse: async (input) => (input.includes('some') ? input : assert.fail(customParseException)),
              }),
            },
          })
          expect(out.flags).to.deep.include({dir: testFile})
        })

        it('accepts custom parse that fails', async () => {
          statStub.returns({isFile: () => true})
          try {
            const out = await parse([`--dir=${testFile}`], {
              flags: {
                dir: Flags.file({
                  exists: true,
                  parse: async (input) => (input.includes('NOT_THERE') ? input : assert.fail(customParseException)),
                }),
              },
            })
            throw new Error(`Should have thrown an error ${JSON.stringify(out)}`)
          } catch (error_) {
            const error = error_ as Error
            expect(error.message).to.include(`Parsing --dir \n\t${customParseException}`)
          }
        })
      })
    })
  })

  describe('flag aliases', () => {
    it('works with defined name', async () => {
      const out = await parse(['--foo'], {
        flags: {
          foo: Flags.boolean({
            aliases: ['bar'],
          }),
        },
      })
      expect(out.flags.foo).to.equal(true)
    })

    it('works with aliased name', async () => {
      const out = await parse(['--bar'], {
        flags: {
          foo: Flags.boolean({
            aliases: ['bar'],
          }),
        },
      })
      expect(out.flags.foo).to.equal(true)
    })

    describe('aliased short char', () => {
      it('boolean', async () => {
        const out = await parse(['-b'], {
          flags: {
            foo: Flags.boolean({
              charAliases: ['b'],
            }),
          },
        })
        expect(out.flags.foo).to.equal(true)
      })

      it('string', async () => {
        const out = await parse(['-b', 'hello'], {
          flags: {
            foo: Flags.string({
              charAliases: ['b'],
            }),
          },
        })
        expect(out.flags.foo).to.equal('hello')
      })

      it('empty charAliases', async () => {
        const out = await parse(['--foo', 'hello'], {
          flags: {
            foo: Flags.string({
              charAliases: [],
            }),
          },
        })
        expect(out.flags.foo).to.equal('hello')
      })

      it('duplicated flag via charAliases and full name throws error', async () => {
        let message = ''
        try {
          await parse(['--foo', 'hello', '--foo', 'hi'], {
            flags: {
              foo: Flags.string({
                charAliases: ['b'],
              }),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include('can only be specified once')
      })

      it('duplicated via aliases charAliases throws error', async () => {
        let message = ''
        try {
          await parse(['-b', 'hello', '-b', 'hi'], {
            flags: {
              foo: Flags.string({
                aliases: ['b'],
                charAliases: ['b'],
              }),
            },
          })
        } catch (error: any) {
          message = error.message
        }

        expect(message).to.include('can only be specified once')
      })
    })
  })
})

describe('allowStdin', () => {
  const stdinValue = 'x'
  const stdinPromise = new Promise<null | string>((resolve) => {
    resolve(stdinValue)
  })

  afterEach(() => {
    sinon.restore()
  })

  it('should read stdin as input for flag when value is "-"', async () => {
    sinon.stub(parser, 'readStdin').returns(stdinPromise)
    const out = await parse(['--myflag', '-'], {
      flags: {
        myflag: Flags.string({allowStdin: true}),
      },
    })

    expect(out.flags.myflag).to.equals(stdinValue)
    expect(out.raw[0].input).to.equal('x')
  })

  it('should not read stdin when value is not "-"', async () => {
    sinon.stub(parser, 'readStdin').returns(stdinPromise)
    const out = await parse(['--myflag', 'foo'], {
      flags: {
        myflag: Flags.string({allowStdin: true}),
      },
    })

    expect(out.flags.myflag).to.equals('foo')
    expect(out.raw[0].input).to.equal('foo')
  })

  it('should read stdin as input for flag when allowStdin is "only" and when value is "-"', async () => {
    sinon.stub(parser, 'readStdin').returns(stdinPromise)
    const out = await parse(['--myflag', '-'], {
      flags: {
        myflag: Flags.string({allowStdin: 'only'}),
      },
    })

    expect(out.flags.myflag).to.equals(stdinValue)
    expect(out.raw[0].input).to.equal('x')
  })

  it('should read stdin as input for flag when allowStdin is "only" and no value is given', async () => {
    sinon.stub(parser, 'readStdin').returns(stdinPromise)
    const out = await parse(['--myflag'], {
      flags: {
        myflag: Flags.string({allowStdin: 'only'}),
      },
    })

    expect(out.flags.myflag).to.equals(stdinValue)
    expect(out.raw[0].input).to.equal('x')
  })

  it('should throw if allowStdin is "only" but value is not "-" or undefined', async () => {
    sinon.stub(parser, 'readStdin').returns(stdinPromise)
    try {
      await parse(['--myflag', 'INVALID'], {
        flags: {
          myflag: Flags.string({allowStdin: 'only'}),
        },
      })
      expect.fail('Should have thrown an error')
    } catch (error) {
      if (error instanceof CLIError) {
        expect(error.message).to.equal(
          'Flag --myflag can only be read from stdin. The value must be "-" or not provided at all.',
        )
      } else {
        expect.fail('Should have thrown a CLIError')
      }
    }
  })

  it('should read stdin as input for flag when allowStdin is "only" and no value is given, and a second flag is used after', async () => {
    sinon.stub(parser, 'readStdin').returns(stdinPromise)
    const out = await parse(['--myflag', '--myflag2'], {
      flags: {
        myflag: Flags.string({allowStdin: 'only'}),
        myflag2: Flags.boolean(),
      },
    })

    expect(out.flags.myflag).to.equals(stdinValue)
    expect(out.raw[0].input).to.equal('x')
  })
})
````

## File: test/parser/preparse.test.ts
````typescript
import {expect} from 'chai'
import fs from 'node:fs/promises'
import {join, resolve} from 'node:path'
import sinon from 'sinon'

import {Config, Interfaces} from '../../src'
import Test from './fixtures/preparse-plugin/src/commands/test'

type TestReturnType = {
  args: Interfaces.InferredArgs<typeof Test.args>
  flags: Interfaces.InferredFlags<typeof Test.flags>
}

describe('preparse hook', () => {
  let config: Config

  beforeEach(async () => {
    config = await Config.load(resolve(__dirname, join('fixtures', 'preparse-plugin')))
  })

  afterEach(() => {
    sinon.restore()
  })

  describe('implement groupAliases', () => {
    it('should add flags that belong to alias group', async () => {
      const {flags} = await config.runCommand<TestReturnType>('test', ['--combo'])
      expect(flags).to.deep.equal({
        burger: 'double',
        combo: true,
        fries: true,
        shake: 'strawberry',
        sauce: ['ketchup'],
      })
    })

    it('should add flags that belong to alias group when using short char', async () => {
      const {flags} = await config.runCommand<TestReturnType>('test', ['-c'])
      expect(flags).to.deep.equal({
        burger: 'double',
        combo: true,
        fries: true,
        shake: 'strawberry',
        sauce: ['ketchup'],
      })
    })

    it('should add flags that belong to alias group and allow flag overrides', async () => {
      const {flags} = await config.runCommand<TestReturnType>('test', ['--combo', '--shake', 'vanilla'])
      expect(flags).to.deep.equal({
        burger: 'double',
        combo: true,
        fries: true,
        shake: 'vanilla',
        sauce: ['ketchup'],
      })
    })

    it('should add flags that belong to alias group and allow short char flag overrides', async () => {
      const {flags} = await config.runCommand<TestReturnType>('test', ['--combo', '-s', 'vanilla'])
      expect(flags).to.deep.equal({
        burger: 'double',
        combo: true,
        fries: true,
        shake: 'vanilla',
        sauce: ['ketchup'],
      })
    })
  })

  describe('implement --flags-dir', () => {
    const flagsDir = resolve(__dirname, 'fixtures', 'flags')

    function makeStubs(files: Array<{name: string; content: string}>) {
      // @ts-expect-error because sinon wants it to be a Dirent[] but node returns string[]
      sinon.stub(fs, 'readdir').resolves(files.map(({name}) => name))

      for (const {name, content} of files) {
        sinon.stub(fs, 'readFile').withArgs(sinon.match(name)).resolves(content)
      }
    }

    describe('boolean flags', () => {
      it('should add boolean from directory', async () => {
        makeStubs([{name: 'fries', content: ''}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir])
        expect(flags).to.deep.equal({
          burger: 'double',
          fries: true,
          'flags-dir': flagsDir,
          sauce: ['ketchup'],
        })
      })

      it('should add boolean from directory and allow flag overrides', async () => {
        makeStubs([{name: 'fries', content: ''}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir, '--no-fries'])
        expect(flags).to.deep.equal({
          burger: 'double',
          fries: false,
          'flags-dir': flagsDir,
          sauce: ['ketchup'],
        })
      })

      it('should add boolean from directory and allow short char flag overrides', async () => {
        makeStubs([{name: 'fries', content: 'false'}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir, '-f'])
        expect(flags).to.deep.equal({
          burger: 'double',
          fries: true,
          'flags-dir': flagsDir,
          sauce: ['ketchup'],
        })
      })
    })

    describe('string flags', () => {
      it('should add string from directory', async () => {
        makeStubs([{name: 'shake', content: 'vanilla'}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir])
        expect(flags).to.deep.equal({
          burger: 'double',
          shake: 'vanilla',
          'flags-dir': flagsDir,
          sauce: ['ketchup'],
        })
      })

      it('should add string from directory to override default', async () => {
        makeStubs([{name: 'burger', content: 'single'}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir])
        expect(flags).to.deep.equal({
          burger: 'single',
          'flags-dir': flagsDir,
          sauce: ['ketchup'],
        })
      })

      it('should add string from directory and allow flag overrides', async () => {
        makeStubs([{name: 'shake', content: 'vanilla'}])
        const {flags} = await config.runCommand<TestReturnType>('test', [
          '--flags-dir',
          flagsDir,
          '--shake',
          'chocolate',
        ])
        expect(flags).to.deep.equal({
          burger: 'double',
          shake: 'chocolate',
          'flags-dir': flagsDir,
          sauce: ['ketchup'],
        })
      })

      it('should add string from directory and allow short char flag overrides', async () => {
        makeStubs([{name: 'shake', content: 'vanilla'}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir, '-s', 'chocolate'])
        expect(flags).to.deep.equal({
          burger: 'double',
          shake: 'chocolate',
          'flags-dir': flagsDir,
          sauce: ['ketchup'],
        })
      })
    })

    describe('multiple flags', () => {
      it('should combine values from directory with values from argv', async () => {
        makeStubs([{name: 'sauce', content: 'bbq'}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir, '--sauce', 'mustard'])
        expect(flags).to.deep.equal({
          burger: 'double',
          sauce: ['mustard', 'bbq'],
          'flags-dir': flagsDir,
        })
      })

      it('should add multiple from directory', async () => {
        makeStubs([{name: 'sauce', content: 'ketchup\nmustard\nbbq'}])
        const {flags} = await config.runCommand<TestReturnType>('test', ['--flags-dir', flagsDir, '--sauce', 'mayo'])
        expect(flags).to.deep.equal({
          burger: 'double',
          sauce: ['mayo', 'ketchup', 'mustard', 'bbq'],
          'flags-dir': flagsDir,
        })
      })
    })
  })
})
````

## File: test/parser/validate.test.ts
````typescript
import {expect} from 'chai'
import {fail} from 'node:assert'

import {CLIError} from '../../src/errors'
import {validate} from '../../src/parser/validate'

describe('validate', () => {
  const input = {
    argv: [],
    flags: {
      dinner: {
        description: 'what you want to eat for dinner',
        input: [],
        name: 'dinner',
        exclusive: ['dessert'],
      },
      dessert: {
        description: 'what you want to eat for dessert',
        default: 'cheesecake',
        input: [],
        name: 'dessert',
        exclusive: [],
      },
    },
    args: {},
    strict: true,
    context: {},
    '--': true,
  }

  it('enforces exclusivity for flags', async () => {
    const output = {
      args: {},
      argv: [],
      flags: {
        dinner: 'pizza',
        dessert: 'cheesecake',
      },
      raw: [
        {
          type: 'flag',
          flag: 'dinner',
          input: 'pizza',
        },
      ],
      metadata: {
        flags: {
          dessert: {
            setFromDefault: false,
          },
        },
      },
    }

    try {
      // @ts-expect-error
      await validate({input, output})
      fail('should have thrown')
    } catch (error) {
      const err = error as CLIError
      expect(err.message).to.include('--dessert=cheesecake cannot also be provided when using --dinner')
    }
  })

  it('ignores exclusivity for defaulted flags', async () => {
    const output = {
      args: {},
      argv: [],
      flags: {
        dinner: 'pizza',
        dessert: 'cheesecake',
      },
      raw: [
        {
          type: 'flag',
          flag: 'dinner',
          input: 'pizza',
        },
      ],
      metadata: {
        flags: {
          dessert: {
            setFromDefault: true,
          },
        },
      },
    }

    // @ts-expect-error
    await validate({input, output})
  })

  it('allows zero for integer', async () => {
    const input = {
      argv: [],
      flags: {
        int: {
          description: 'zero as integer',
          required: true,
        },
      },
      args: {
        zero: {required: true},
      },
      strict: true,
      context: {},
      '--': true,
    }

    const output = {
      args: {zero: 0},
      argv: [0],
      flags: {int: 0},
      raw: [],
      metadata: {
        flags: {},
      },
    }

    // @ts-expect-error
    await validate({input, output})
  })

  it('allows empty string as arg', async () => {
    const input = {
      argv: [],
      flags: {},
      args: {
        emptyString: {required: true},
      },
      strict: true,
      context: {},
      '--': true,
    }

    const output = {
      args: {emptyString: ''},
      argv: [''],
      raw: [],
      metadata: {
        flags: {},
      },
    }

    // @ts-expect-error
    await validate({input, output})
  })

  it('throws when required flag is undefined', async () => {
    const input = {
      argv: [],
      flags: {
        foobar: {
          description: 'foobar flag',
          required: true,
        },
      },
      args: {},
      strict: true,
      context: {},
      '--': true,
    }

    const output = {
      args: {},
      argv: [],
      flags: {foobar: undefined},
      raw: [],
      metadata: {
        flags: {},
      },
    }

    try {
      // @ts-expect-error
      await validate({input, output})
      fail('should have thrown')
    } catch (error) {
      const err = error as CLIError
      expect(err.message).to.include('Missing required flag')
    }
  })

  describe('relationships', () => {
    describe('type: all', () => {
      it('should pass if all required flags are provided', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'all',
                  flags: ['cookies', 'sprinkles'],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', sprinkles: true, cookies: true},
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'sprinkles', input: true},
            {type: 'flag', flag: 'cookies', input: true},
          ],
          metadata: {},
        }

        // @ts-expect-error
        await validate({input, output})
      })

      it('should exclude any flags whose when property resolves to false', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'all',
                  flags: ['cookies', {name: 'sprinkles', when: async () => false}],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', cookies: true},
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'cookies', input: true},
          ],
          metadata: {},
        }

        // @ts-expect-error
        await validate({input, output})
      })

      it('should require all specified flags', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'all',
                  flags: ['cookies', 'sprinkles'],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream'},
          raw: [{type: 'flag', flag: 'dessert', input: 'ice-cream'}],
          metadata: {},
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include(
            'All of the following must be provided when using --dessert: --cookies, --sprinkles',
          )
        }
      })

      it('should require all specified flags with when property that resolves to true', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            birthday: {input: [], name: 'birthday'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'all',
                  flags: [
                    'cookies',
                    {
                      name: 'sprinkles',
                      when: async (flags: {birthday: boolean}) => flags.birthday,
                    },
                  ],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', birthday: true},
          raw: [{type: 'flag', flag: 'dessert', input: 'ice-cream'}],
          metadata: {},
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include(
            'All of the following must be provided when using --dessert: --cookies, --sprinkles',
          )
        }
      })

      it('should require all specified flags with when property that resolves to false', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            birthday: {input: [], name: 'birthday'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'all',
                  flags: [
                    'cookies',
                    {
                      name: 'sprinkles',
                      when: async (flags: {birthday: boolean}) => flags.birthday,
                    },
                  ],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', birthday: false},
          raw: [{type: 'flag', flag: 'dessert', input: 'ice-cream'}],
          metadata: {},
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include('All of the following must be provided when using --dessert: --cookies')
        }
      })
    })

    describe('type: some', () => {
      it('should pass if some of the specified flags are provided', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'some',
                  flags: ['cookies', 'sprinkles'],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', sprinkles: true},
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'sprinkles', input: true},
          ],
          metadata: {},
        }

        // @ts-expect-error
        await validate({input, output})
      })

      it('should require some of the specified flags', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'some',
                  flags: ['cookies', 'sprinkles'],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream'},
          raw: [{type: 'flag', flag: 'dessert', input: 'ice-cream'}],
          metadata: {},
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include(
            'One of the following must be provided when using --dessert: --cookies, --sprinkles',
          )
        }
      })

      it('should require some of the specified flags with when property that resolves to true', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            birthday: {input: [], name: 'birthday'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'some',
                  flags: [
                    'cookies',
                    {
                      name: 'sprinkles',
                      when: async (flags: {birthday: boolean}) => flags.birthday,
                    },
                  ],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', birthday: true},
          raw: [{type: 'flag', flag: 'dessert', input: 'ice-cream'}],
          metadata: {},
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include(
            'One of the following must be provided when using --dessert: --cookies, --sprinkles',
          )
        }
      })

      it('should require some of the specified flags with when property that resolves to false', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            birthday: {input: [], name: 'birthday'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'some',
                  flags: [
                    'cookies',
                    {
                      name: 'sprinkles',
                      when: async (flags: {birthday: boolean}) => flags.birthday,
                    },
                  ],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', birthday: false},
          raw: [{type: 'flag', flag: 'dessert', input: 'ice-cream'}],
          metadata: {},
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include('One of the following must be provided when using --dessert: --cookies')
        }
      })
    })

    describe('type: none', () => {
      it('should pass if none of the specified flags are provided', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'none',
                  flags: ['cookies', 'sprinkles'],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream'},
          raw: [{type: 'flag', flag: 'dessert', input: 'ice-cream'}],
          metadata: {},
        }

        // @ts-expect-error
        await validate({input, output})
      })

      it('should fail if the specified flags are provided', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'none',
                  flags: ['cookies', 'sprinkles'],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', sprinkles: true},
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'sprinkles', input: true},
          ],
          metadata: {
            flags: {
              dessert: {setFromDefault: false},
              sprinkles: {setFromDefault: false},
            },
          },
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include('--sprinkles=true cannot also be provided when using --dessert')
        }
      })

      it('should fail if the specified flags are provided with when property that resolves to true', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            birthday: {input: [], name: 'birthday'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'none',
                  flags: [
                    {
                      name: 'sprinkles',
                      when: async (flags: {birthday: boolean}) => flags.birthday,
                    },
                  ],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', birthday: true, sprinkles: true},
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'sprinkles', input: true},
            {type: 'flag', flag: 'birthday', input: true},
          ],
          metadata: {
            flags: {
              dessert: {setFromDefault: false},
              sprinkles: {setFromDefault: false},
              birthday: {setFromDefault: false},
            },
          },
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include('--sprinkles=true cannot also be provided when using --dessert')
        }
      })

      it('should pass if the specified flags are provided with when property that resolves to false', async () => {
        const input = {
          argv: [],
          flags: {
            cookies: {input: [], name: 'cookies'},
            sprinkles: {input: [], name: 'sprinkles'},
            birthday: {input: [], name: 'birthday'},
            dessert: {
              input: [],
              name: 'dessert',
              relationships: [
                {
                  type: 'none',
                  flags: [
                    {
                      name: 'sprinkles',
                      when: async (flags: {birthday: boolean}) => flags.birthday,
                    },
                  ],
                },
              ],
            },
          },
          args: {},
          strict: true,
          context: {},
          '--': true,
        }

        const output = {
          args: {},
          argv: [],
          flags: {dessert: 'ice-cream', birthday: false, sprinkles: true},
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'sprinkles', input: true},
            {type: 'flag', flag: 'birthday', input: false},
          ],
          metadata: {
            flags: {
              dessert: {setFromDefault: false},
              sprinkles: {setFromDefault: false},
              birthday: {setFromDefault: false},
            },
          },
        }

        // @ts-expect-error
        await validate({input, output})
      })
    })

    it('should pass if the specified flags whose when property resolves to true, flag has a false value', async () => {
      const input = {
        argv: [],
        flags: {
          cookies: {input: [], name: 'cookies'},
          sprinkles: {input: [], name: 'sprinkles'},
          dessert: {
            input: [],
            name: 'dessert',
            relationships: [
              {
                type: 'all',
                flags: ['sprinkles', {name: 'cookies', when: async () => true}],
              },
            ],
          },
        },
        args: [],
        strict: true,
        context: {},
        '--': true,
      }

      const output = {
        args: {},
        argv: [],
        flags: {sprinkles: true, dessert: 'ice-cream', cookies: false},
        raw: [
          {type: 'flag', flag: 'sprinkles', input: true},
          {type: 'flag', flag: 'dessert', input: 'ice-cream'},
          {type: 'flag', flag: 'cookies', input: false},
        ],
        metadata: {},
      }

      // @ts-expect-error
      await validate({input, output})
    })

    it('should fail if the specified flags whose when property resolves to true in exclusive, flag has a false value', async () => {
      const input = {
        argv: [],
        flags: {
          cookies: {input: [], name: 'cookies'},
          sprinkles: {input: [], name: 'sprinkles'},
          dessert: {
            input: [],
            name: 'dessert',
            exclusive: [{name: 'cookies', when: async () => true}],
          },
        },
        args: [],
        strict: true,
        context: {},
        '--': true,
      }

      const output = {
        args: {},
        argv: [],
        flags: {sprinkles: true, dessert: 'ice-cream', cookies: false},
        raw: [
          {type: 'flag', flag: 'sprinkles', input: true},
          {type: 'flag', flag: 'dessert', input: 'ice-cream'},
          {type: 'flag', flag: 'cookies', input: false},
        ],
        metadata: {},
      }

      try {
        // @ts-expect-error
        await validate({input, output})
        fail('should have thrown')
      } catch (error) {
        const err = error as CLIError
        expect(err.message).to.include('--cookies=false cannot also be provided when using --dessert')
      }
    })

    describe('mixed', () => {
      const input = {
        argv: [],
        flags: {
          cookies: {input: [], name: 'cookies'},
          sprinkles: {input: [], name: 'sprinkles'},
          cake: {input: [], name: 'cake'},
          brownies: {input: [], name: 'brownies'},
          pie: {input: [], name: 'pie'},
          fudge: {input: [], name: 'fudge'},
          cupcake: {input: [], name: 'cupcake'},
          muffin: {input: [], name: 'muffin'},
          scone: {input: [], name: 'scone'},
          dessert: {
            input: [],
            name: 'dessert',
            relationships: [
              {
                type: 'all',
                flags: [
                  'cookies',
                  {name: 'sprinkles', when: async () => false},
                  {name: 'cake', when: async () => true},
                ],
              },
              {
                type: 'some',
                flags: ['brownies', {name: 'pie', when: async () => false}, {name: 'fudge', when: async () => true}],
              },
              {
                type: 'none',
                flags: ['cupcake', {name: 'muffin', when: async () => false}, {name: 'scone', when: async () => true}],
              },
            ],
          },
        },
        args: {},
        strict: true,
        context: {},
        '--': true,
      }

      it('should succeed', async () => {
        const output = {
          args: {},
          argv: [],
          flags: {
            dessert: 'ice-cream',
            cookies: true,
            brownies: true,
            cake: true,
            muffin: true,
          },
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'cookies', input: true},
            {type: 'flag', flag: 'brownies', input: true},
            {type: 'flag', flag: 'cake', input: true},
            {type: 'flag', flag: 'muffin', input: true},
          ],
          metadata: {},
        }

        // @ts-expect-error
        await validate({input, output})
      })

      it('should fail', async () => {
        const output = {
          args: {},
          argv: [],
          flags: {
            dessert: 'ice-cream',
            sprinkles: true,
            cake: true,
            scone: true,
            pie: true,
          },
          raw: [
            {type: 'flag', flag: 'dessert', input: 'ice-cream'},
            {type: 'flag', flag: 'sprinkles', input: true},
            {type: 'flag', flag: 'cake', input: true},
            {type: 'flag', flag: 'scone', input: true},
            {type: 'flag', flag: 'pie', input: true},
          ],
          metadata: {},
        }

        try {
          // @ts-expect-error
          await validate({input, output})
          fail('should have thrown')
        } catch (error) {
          const err = error as CLIError
          expect(err.message).to.include(
            'All of the following must be provided when using --dessert: --cookies, --cake',
          )
          expect(err.message).to.include('--scone=true cannot also be provided when using --dessert')
          expect(err.message).to.include(
            'One of the following must be provided when using --dessert: --brownies, --fudge',
          )
        }
      })
    })
  })
})
````

## File: test/perf/parser.perf.ts
````typescript
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import {Suite} from 'benchmark'

import {Flags} from '../../src'
import {parse} from '../../src/parser'

const suite = new Suite()

// eslint-disable-next-line no-promise-executor-return
const delay100 = () => new Promise((resolve) => setTimeout(resolve, 100))

suite
  .add('simple', {
    defer: true,
    fn(deferred: {resolve: () => any}) {
      parse(['--bool'], {
        flags: {
          bool: Flags.boolean(),
        },
      }).then(() => deferred.resolve())
    },
  })
  .add('multiple async flags that take time', {
    defer: true,
    fn(deferred: {resolve: () => any}) {
      parse(['--flagA', 'foo', '--flagB', 'bar'], {
        flags: {
          flagA: Flags.string({
            async parse(input) {
              await delay100()
              return input
            },
          }),
          flagB: Flags.string({
            async parse(input) {
              await delay100()
              return input
            },
          }),
        },
      }).then(() => deferred.resolve())
    },
  })

  .add('flagstravaganza', {
    defer: true,
    fn(deferred: {resolve: () => any}) {
      const flags = [
        ['--bool'],
        ['-S', 'foo'],

        ['--dep-string', 'foo'],
        ['--excl-string', 'foo'],
        ['--exactly-one', 'foo'],

        ['--parsed-string-as-number', '5'],
        ['--dir', process.cwd()],
        ['--file', __filename],

        ['--multiple', '1'],
        ['--multiple', '2'],
        ['--multiple', '3'],
        ['--multiple2', '5,6,7,8,9,10,11'],
      ]
      const exactlyOne = ['exactly-one-nope', 'exactly-one-nope2', 'exactly-one']
      parse(flags.flat(), {
        flags: {
          bool: Flags.boolean(),
          string: Flags.string({char: 's', aliases: ['S']}),

          'dep-string': Flags.string({dependsOn: ['string']}),
          // don't populate this one, used for exclusive test
          nope: Flags.boolean(),
          'excl-string': Flags.string({exclusive: ['nope']}),
          'exactly-one-nope': Flags.string({exactlyOne}),
          'exactly-one-nope2': Flags.string({exactlyOne}),
          'exactly-one': Flags.string({exactlyOne}),

          'parsed-string-as-number': Flags.integer({
            parse: (input) => Promise.resolve(Number.parseInt(input, 10) + 1000),
          }),
          dir: Flags.directory({exists: true}),
          file: Flags.file({exists: true}),

          multiple: Flags.string({multiple: true}),
          multiple2: Flags.string({multiple: true, delimiter: ','}),
        },
      }).then(() => deferred.resolve())
    },
  })

  // add listeners
  .on('cycle', (event: any) => {
    console.log(String(event.target))
  })
  .run({async: true})
````

## File: test/util/cache-command.test.ts
````typescript
import {expect} from 'chai'

import {Args, Command, Flags} from '../../src/index'
import {cacheCommand} from '../../src/util/cache-command'

describe('cacheCommand', () => {
  it('should return a cached command with every thing set', async () => {
    class C extends Command {
      static aliases = ['alias1', 'alias2']
      static args = {
        arg1: Args.string({
          description: 'arg1 desc',
          required: true,
          hidden: false,
          options: ['af', 'b'],
          default: async () => 'a',
        }),
      }

      static description = 'test command'
      static flags = {
        flaga: Flags.boolean(),
        flagb: Flags.string({
          char: 'b',
          hidden: true,
          required: false,
          description: 'flagb desc',
          options: ['a', 'b'],
          default: async () => 'a',
        }),
        flagc: Flags.integer({
          char: 'c',
          min: 1,
          max: 10,
          env: 'FLAGC',
          required: false,
          description: 'flagc desc',
          options: ['a', 'b'],
          default: async (context) => (context.options.min ?? 1) + 1,
        }),
      }

      static hidden = true
      static id = 'foo:bar'
      static title = 'cmd title'
      static type = 'mytype'

      static usage = ['$ usage']

      public async run(): Promise<void> {}
    }
    const c = await cacheCommand(C, undefined, false)
    expect(c).to.deep.equal({
      id: 'foo:bar',
      type: 'mytype',
      hidden: true,
      pluginName: undefined,
      pluginAlias: undefined,
      pluginType: undefined,
      state: undefined,
      description: 'test command',
      aliases: ['alias1', 'alias2'],
      hiddenAliases: [],
      title: 'cmd title',
      usage: ['$ usage'],
      examples: undefined,
      deprecationOptions: undefined,
      deprecateAliases: undefined,
      summary: undefined,
      strict: true,
      enableJsonFlag: false,
      hasDynamicHelp: false,
      flags: {
        flaga: {
          aliases: undefined,
          char: undefined,
          charAliases: undefined,
          description: undefined,
          dependsOn: undefined,
          deprecateAliases: undefined,
          deprecated: undefined,
          env: undefined,
          exclusive: undefined,
          helpGroup: undefined,
          helpLabel: undefined,
          summary: undefined,
          name: 'flaga',
          hidden: undefined,
          required: undefined,
          relationships: undefined,
          allowNo: false,
          type: 'boolean',
          noCacheDefault: undefined,
        },
        flagb: {
          aliases: undefined,
          char: 'b',
          charAliases: undefined,
          description: 'flagb desc',
          dependsOn: undefined,
          deprecateAliases: undefined,
          deprecated: undefined,
          env: undefined,
          exclusive: undefined,
          helpGroup: undefined,
          helpLabel: undefined,
          summary: undefined,
          name: 'flagb',
          hidden: true,
          required: false,
          multiple: false,
          relationships: undefined,
          type: 'option',
          helpValue: undefined,
          default: 'a',
          options: ['a', 'b'],
          delimiter: undefined,
          noCacheDefault: undefined,
          hasDynamicHelp: false,
        },
        flagc: {
          aliases: undefined,
          char: 'c',
          charAliases: undefined,
          default: 2,
          delimiter: undefined,
          dependsOn: undefined,
          deprecateAliases: undefined,
          deprecated: undefined,
          description: 'flagc desc',
          env: 'FLAGC',
          exclusive: undefined,
          helpGroup: undefined,
          helpLabel: undefined,
          helpValue: undefined,
          hidden: undefined,
          multiple: false,
          name: 'flagc',
          options: ['a', 'b'],
          relationships: undefined,
          required: false,
          summary: undefined,
          type: 'option',
          noCacheDefault: undefined,
          hasDynamicHelp: false,
        },
      },
      args: {
        arg1: {
          description: 'arg1 desc',
          name: 'arg1',
          hidden: false,
          required: true,
          options: ['af', 'b'],
          default: 'a',
          noCacheDefault: undefined,
        },
      },
    })
  })

  it('should return a cached command with multiple Command classes in inheritance chain', async () => {
    class Base extends Command {
      public static aliases = ['base']
      public static enableJsonFlag = true

      public static flags = {
        parentFlag: Flags.boolean(),
      }

      public static state = 'beta'
      public static summary = 'base summary'

      public async run(): Promise<void> {}
    }

    class Child extends Base {
      static flags = {
        ...Base.flags,
        childFlag: Flags.boolean(),
      }

      static id = 'command'
      public static summary = 'child summary'

      public async run(): Promise<void> {}
    }

    const cached = await cacheCommand(Child, undefined, false)

    expect(cached).to.deep.equal({
      id: 'command',
      summary: 'child summary',
      description: undefined,
      strict: true,
      usage: undefined,
      pluginName: undefined,
      pluginAlias: undefined,
      pluginType: undefined,
      hidden: undefined,
      state: 'beta',
      aliases: ['base'],
      hiddenAliases: [],
      examples: undefined,
      deprecationOptions: undefined,
      deprecateAliases: undefined,
      flags: {
        json: {
          name: 'json',
          type: 'boolean',
          char: undefined,
          summary: undefined,
          description: 'Format output as json.',
          env: undefined,
          hidden: undefined,
          required: undefined,
          helpLabel: undefined,
          helpGroup: 'GLOBAL',
          allowNo: false,
          dependsOn: undefined,
          relationships: undefined,
          exclusive: undefined,
          deprecated: undefined,
          deprecateAliases: undefined,
          aliases: undefined,
          charAliases: undefined,
          noCacheDefault: undefined,
        },
        childFlag: {
          name: 'childFlag',
          type: 'boolean',
          char: undefined,
          summary: undefined,
          description: undefined,
          env: undefined,
          hidden: undefined,
          required: undefined,
          helpLabel: undefined,
          helpGroup: undefined,
          allowNo: false,
          dependsOn: undefined,
          relationships: undefined,
          exclusive: undefined,
          deprecated: undefined,
          deprecateAliases: undefined,
          aliases: undefined,
          charAliases: undefined,
          noCacheDefault: undefined,
        },
        parentFlag: {
          name: 'parentFlag',
          type: 'boolean',
          char: undefined,
          summary: undefined,
          description: undefined,
          env: undefined,
          hidden: undefined,
          required: undefined,
          helpLabel: undefined,
          helpGroup: undefined,
          allowNo: false,
          dependsOn: undefined,
          relationships: undefined,
          exclusive: undefined,
          deprecated: undefined,
          deprecateAliases: undefined,
          aliases: undefined,
          charAliases: undefined,
          noCacheDefault: undefined,
        },
      },
      args: {},
      hasDynamicHelp: false,
      enableJsonFlag: true,
    })
  })

  it('should set dynamicHelp to true if defaultHelp is a function', async () => {
    class C extends Command {
      static flags = {
        flaga: Flags.boolean(),
        flagb: Flags.string({
          defaultHelp: async () => 'foo',
        }),
      }

      static id = 'foo:bar'

      public async run(): Promise<void> {}
    }
    const c = await cacheCommand(C, undefined, false)
    expect(c.hasDynamicHelp).to.be.true
    expect(c.flags.flagb.hasDynamicHelp).to.be.true
  })

  it('should add additional command properties', async () => {
    class C extends Command {
      static envVars = ['FOO_BAR']
      static flags = {
        flaga: Flags.boolean(),
      }

      static id = 'foo:bar'

      public async run(): Promise<void> {}
    }

    const c = await cacheCommand(C, undefined, false)
    expect(c.envVars).to.deep.equal(['FOO_BAR'])
  })
})
````

## File: test/util/cache-default-value.test.ts
````typescript
import {expect} from 'chai'

import {cacheDefaultValue} from '../../src/util/cache-default-value'

describe('cacheDefaultValue', () => {
  it('should do nothing if noCacheDefault is true', async () => {
    const flag = {noCacheDefault: true}
    const result = await cacheDefaultValue(flag as any, true)
    expect(result).to.be.undefined
  })

  it('should do nothing if respectNoCacheDefault is true', async () => {
    const result = await cacheDefaultValue({} as any, true)
    expect(result).to.be.undefined
  })

  it('should return the result of defaultHelp if it exists', async () => {
    const flag = {defaultHelp: async () => 'foo'}
    const result = await cacheDefaultValue(flag as any, false)
    expect(result).to.equal('foo')
  })

  it('should return undefined if defaultHelp throws', async () => {
    const flag = {
      async defaultHelp() {
        throw new Error('foo')
      },
    }
    const result = await cacheDefaultValue(flag as any, false)
    expect(result).to.be.undefined
  })

  it("should return the result of the default if it's a function", async () => {
    const flag = {default: async () => 'foo'}
    const result = await cacheDefaultValue(flag as any, false)
    expect(result).to.equal('foo')
  })

  it("should return the result of the default if it's a simple value", async () => {
    const flag = {default: 'foo'}
    const result = await cacheDefaultValue(flag as any, false)
    expect(result).to.equal('foo')
  })
})
````

## File: test/util/determine-priority.test.ts
````typescript
import {expect} from 'chai'

import {Plugin} from '../../src'
import {determinePriority} from '../../src/util/determine-priority'
import {makeCommandClass, makeLoadable} from '../help/help-test-utils'

async function makeCommand(id: string, pluginAlias: string, pluginType: string) {
  const plugin = new Plugin({root: 'root', name: pluginAlias})
  plugin.name = pluginAlias
  plugin.alias = pluginAlias
  plugin.type = pluginType
  return makeLoadable(makeCommandClass({id}), plugin)
}

describe('determinePriority', () => {
  it('should return the command that belongs to first core plugin in list', async () => {
    const commands = [await makeCommand('foo', 'plugin1', 'core'), await makeCommand('foo', 'plugin2', 'core')]
    const result = determinePriority(
      commands.map((c) => c.pluginName ?? 'plugin'),
      commands,
    )
    expect(result.pluginName).to.equal('plugin1')
  })

  it('should return command owned by core plugin over command owned by user plugin', async () => {
    const commands = [await makeCommand('foo', 'plugin1', 'core'), await makeCommand('foo', 'plugin2', 'user')]
    const result = determinePriority(
      commands.map((c) => c.pluginName ?? 'plugin'),
      commands,
    )
    expect(result.pluginName).to.equal('plugin1')
  })

  it('should return command owned core plugin over command owned by non-core plugin', async () => {
    const commands = [await makeCommand('foo', 'plugin1', 'user'), await makeCommand('foo', 'plugin2', 'core')]
    const result = determinePriority(
      commands.map((c) => c.pluginName ?? 'plugin'),
      commands,
    )
    expect(result.pluginName).to.equal('plugin2')
  })

  it('should return command owned by jit plugin over command owned by user plugin', async () => {
    const commands = [await makeCommand('foo', 'plugin1', 'user'), await makeCommand('foo', 'plugin2', 'jit')]
    const result = determinePriority(
      commands.map((c) => c.pluginName ?? 'plugin'),
      commands,
    )
    expect(result.pluginName).to.equal('plugin1')
  })

  it('should return command owned by user plugin over command owned by jit plugin', async () => {
    const commands = [await makeCommand('foo', 'plugin1', 'jit'), await makeCommand('foo', 'plugin2', 'user')]
    const result = determinePriority(
      commands.map((c) => c.pluginName ?? 'plugin'),
      commands,
    )
    expect(result.pluginName).to.equal('plugin2')
  })

  it('should return the first command if no core plugin is present', async () => {
    const commands = [await makeCommand('foo', 'plugin1', 'user'), await makeCommand('foo', 'plugin2', 'user')]
    const result = determinePriority(
      commands.map((c) => c.pluginName ?? 'plugin'),
      commands,
    )
    expect(result.pluginName).to.equal('plugin1')
  })
})
````

## File: test/util/ensure-arg-object.ts
````typescript
import {expect} from 'chai'

import {ensureArgObject} from '../../src/util/ensure-arg-object'
describe('ensureArgObject', () => {
  it('should convert array of arguments to an object', () => {
    const args = [
      {name: 'foo', description: 'foo desc', required: true},
      {name: 'bar', description: 'bar desc'},
    ]
    const expected = {foo: args[0], bar: args[1]}
    expect(ensureArgObject(args)).to.deep.equal(expected)
  })

  it('should do nothing to an arguments object', () => {
    const args = {
      foo: {name: 'foo', description: 'foo desc', required: true},
      bar: {name: 'bar', description: 'bar desc'},
    }
    expect(ensureArgObject(args)).to.deep.equal(args)
  })
})
````

## File: test/util/fs.test.ts
````typescript
import {expect} from 'chai'

import {readJson, safeReadJson} from '../../src/util/fs'

describe('readJson', () => {
  it('should return parsed JSON', async () => {
    const json = await readJson<{name: string}>('package.json')
    expect(json.name).to.equal('@oclif/core')
  })

  it('should throw an error if the file does not exist', async () => {
    try {
      await readJson('does-not-exist.json')
      throw new Error('Expected an error to be thrown')
    } catch (error) {
      const err = error as Error
      expect(err.message).to.include('ENOENT: no such file or directory')
    }
  })
})

describe('safeReadJson', () => {
  it('should return parsed JSON', async () => {
    const json = await safeReadJson<{name: string}>('package.json')
    expect(json?.name).to.equal('@oclif/core')
  })

  it('should return undefined if the file does not exist', async () => {
    const json = await safeReadJson('does-not-exist.json')
    expect(json).to.be.undefined
  })
})
````

## File: test/util/os.test.ts
````typescript
import {expect} from 'chai'
import {homedir} from 'node:os'

import {getHomeDir} from '../../src/util/os'

describe('getHomeDir', () => {
  it('should return the home directory', () => {
    expect(getHomeDir()).to.equal(homedir())
  })
})
````

## File: test/util/util.test.ts
````typescript
import {expect} from 'chai'

import {capitalize, castArray, isNotFalsy, isTruthy, last, maxBy, mergeNestedObjects, sumBy} from '../../src/util/util'

describe('capitalize', () => {
  it('capitalizes the string', () => {
    expect(capitalize('dominik')).to.equal('Dominik')
  })

  it('works with an empty string', () => {
    expect(capitalize('')).to.equal('')
  })
})

type Item = {x: number}

describe('sumBy', () => {
  it('returns zero for empty array', () => {
    const arr: Item[] = []
    expect(sumBy(arr, (i) => i.x)).to.equal(0)
  })

  it('returns sum for non-empty array', () => {
    const arr: Item[] = [{x: 1}, {x: 2}, {x: 3}]
    expect(sumBy(arr, (i) => i.x)).to.equal(6)
  })
})

describe('maxBy', () => {
  it('returns undefined for empty array', () => {
    const arr: Item[] = []
    expect(maxBy(arr, (i) => i.x)).to.be.undefined
  })

  it('returns max value in the array', () => {
    const arr: Item[] = [{x: 1}, {x: 3}, {x: 2}]
    expect(maxBy(arr, (i) => i.x)).to.equal(arr[1])
  })
})

describe('last', () => {
  it('returns undefined for empty array', () => {
    expect(last([])).to.be.undefined
  })

  it('returns undefined for undefined', () => {
    expect(last()).to.be.undefined
  })

  it('returns last value in the array', () => {
    const arr: Item[] = [{x: 1}, {x: 3}, {x: 2}]
    expect(last(arr)).to.equal(arr[2])
  })

  it('returns only item in array', () => {
    expect(last([6])).to.equal(6)
  })
})

describe('isNotFalsy', () => {
  it('should return true for truthy values', () => {
    expect(isNotFalsy('true')).to.be.true
    expect(isNotFalsy('1')).to.be.true
    expect(isNotFalsy('yes')).to.be.true
    expect(isNotFalsy('y')).to.be.true
  })

  it('should return false for falsy values', () => {
    expect(isNotFalsy('false')).to.be.false
    expect(isNotFalsy('0')).to.be.false
    expect(isNotFalsy('no')).to.be.false
    expect(isNotFalsy('n')).to.be.false
  })
})

describe('isTruthy', () => {
  it('should return true for truthy values', () => {
    expect(isTruthy('true')).to.be.true
    expect(isTruthy('1')).to.be.true
    expect(isTruthy('yes')).to.be.true
    expect(isTruthy('y')).to.be.true
  })

  it('should return false for falsy values', () => {
    expect(isTruthy('false')).to.be.false
    expect(isTruthy('0')).to.be.false
    expect(isTruthy('no')).to.be.false
    expect(isTruthy('n')).to.be.false
  })
})

describe('castArray', () => {
  it('should cast a value to an array', () => {
    expect(castArray('foo')).to.deep.equal(['foo'])
  })

  it('should return an array if the value is an array', () => {
    expect(castArray(['foo'])).to.deep.equal(['foo'])
  })

  it('should return an empty array if the value is undefined', () => {
    expect(castArray()).to.deep.equal([])
  })
})

describe('mergeNestedObjects', () => {
  it('should merge nested objects', () => {
    const a = {
      tsconfig: {
        compilerOptions: {
          outDir: 'dist',
          rootDir: 'src',
        },
        'ts-node': {
          transpileOnly: true,
        },
      },
    }

    const b = {
      tsconfig: {
        compilerOptions: {
          outDir: 'dist',
          rootDir: 'src',
        },
        'ts-node': {
          transpileOnly: false,
        },
      },
    }

    expect(mergeNestedObjects([a, b], 'tsconfig.ts-node')).to.deep.equal({
      transpileOnly: true,
    })
  })
})
````

## File: test/ux/action/simple.test.ts
````typescript
import {captureOutput} from '@oclif/test'
import {expect} from 'chai'

import SimpleSpinner from '../../../src/ux/action/simple'

describe('SimpleSpinner', () => {
  it('should start', async () => {
    let wasSetToActive = false
    const {stderr} = await captureOutput(async () => {
      const spinner = new SimpleSpinner()
      spinner.start('Testing a simple spinner')
      wasSetToActive = spinner.running
      spinner.stop()
    })

    expect(stderr).to.equal('Testing a simple spinner... done\n')
    expect(wasSetToActive).to.be.true
  })

  it('should pause', async () => {
    let wasPaused = false
    await captureOutput(async () => {
      const spinner = new SimpleSpinner()
      spinner.start('Testing a simple spinner')
      spinner.pause(() => {
        wasPaused = true
      })
      spinner.stop()
    })

    expect(wasPaused).to.be.true
  })

  it('should use stdout', async () => {
    const {stdout} = await captureOutput(async () => {
      const spinner = new SimpleSpinner()
      spinner.start('Testing a simple spinner', undefined, {stdout: true})
      spinner.stop()
    })

    expect(stdout).to.equal('Testing a simple spinner... done\n')
  })
})
````

## File: test/ux/action/spinner.test.ts
````typescript
import {captureOutput} from '@oclif/test'
import {expect} from 'chai'

import Spinner from '../../../src/ux/action/spinner'

const sleep = (ms: number) =>
  new Promise((resolve) => {
    setTimeout(resolve, ms)
  })

describe('Spinner', () => {
  it('should start', async () => {
    let wasSetToActive = false
    await captureOutput(async () => {
      const spinner = new Spinner()
      spinner.start('Testing a spinner')
      wasSetToActive = spinner.running
      spinner.stop()
    })
    expect(wasSetToActive).to.be.true
  })

  it('should pause', async () => {
    let wasPaused = false
    await captureOutput(async () => {
      const spinner = new Spinner()
      spinner.start('Testing a spinner')
      spinner.pause(() => {
        wasPaused = true
      })
      spinner.stop()
    })

    expect(wasPaused).to.be.true
  })

  it('should pauseAsync', async () => {
    let wasPaused = false
    await captureOutput(async () => {
      const spinner = new Spinner()
      spinner.start('Testing a spinner')
      spinner.pauseAsync(async () => {
        wasPaused = true
      })
      spinner.stop()
    })

    expect(wasPaused).to.be.true
  })

  it('should use stdout', async () => {
    const {stdout} = await captureOutput(async () => {
      const spinner = new Spinner()
      spinner.start('Testing a spinner', undefined, {stdout: true})
      // Have to give the spinner enough time to render the status
      await sleep(100)
      spinner.stop()
    })

    expect(stdout).to.include('Testing a spinner... done\n')
  })

  describe('status', () => {
    ;(process.platform === 'win32' ? it.skip : it)('should update with status', async () => {
      const {stderr, result} = await captureOutput(async () => {
        const spinner = new Spinner()
        spinner.start('Testing a spinner')
        spinner.status = 'still testing'
        // Have to give the spinner enough time to render the status
        await sleep(100)
        const {status} = spinner
        spinner.stop()
        return status
      })

      expect(stderr).to.include('still testing\n')
      expect(result).to.equal('still testing')
    })

    it('should not do anything if not active', async () => {
      const {result} = await captureOutput(async () => {
        const spinner = new Spinner()
        spinner.status = 'still testing'
        return spinner.status
      })
      expect(result).to.be.undefined
    })
  })
})
````

## File: test/ux/colorize-json.test.ts
````typescript
import {expect} from 'chai'

import {stringifyInput, tokenize} from '../../src/ux/colorize-json'

describe('colorizeJson', () => {
  it('tokenizes a basic JSON object', () => {
    const result = tokenize({
      foo: 'bar',
    })

    expect(result).to.deep.equal([
      {type: 'brace', value: '{'},
      {type: 'key', value: '"foo"'},
      {type: 'colon', value: ':'},
      {type: 'string', value: '"bar"'},
      {type: 'brace', value: '}'},
    ])
  })

  it('tokenizes a basic JSON string', () => {
    const result = tokenize('{"foo":"bar"}')

    expect(result).to.deep.equal([
      {type: 'brace', value: '{'},
      {type: 'key', value: '"foo"'},
      {type: 'colon', value: ':'},
      {type: 'string', value: '"bar"'},
      {type: 'brace', value: '}'},
    ])
  })

  it('tokenizes an array', () => {
    const result = tokenize(['foo', 'bar'])

    expect(result).to.deep.equal([
      {type: 'bracket', value: '['},
      {type: 'string', value: '"foo"'},
      {type: 'comma', value: ','},
      {type: 'string', value: '"bar"'},
      {type: 'bracket', value: ']'},
    ])
  })

  it('includes whitespace', () => {
    const result = tokenize('{\n  "foo": "bar"\n}')

    expect(result).to.deep.equal([
      {type: 'brace', value: '{'},
      {type: 'whitespace', value: '\n  '},
      {type: 'key', value: '"foo"'},
      {type: 'colon', value: ':'},
      {type: 'whitespace', value: ' '},
      {type: 'string', value: '"bar"'},
      {type: 'whitespace', value: '\n'},
      {type: 'brace', value: '}'},
    ])
  })

  it('tokenizes boolean values', () => {
    let result = tokenize('true')
    expect(result).to.deep.equal([{type: 'boolean', value: 'true'}])

    result = tokenize('false')
    expect(result).to.deep.equal([{type: 'boolean', value: 'false'}])
  })

  it('tokenizes integer values', () => {
    let result = tokenize('123')
    expect(result).to.deep.equal([{type: 'number', value: '123'}])

    result = tokenize('-10')
    expect(result).to.deep.equal([{type: 'number', value: '-10'}])
  })

  it('tokenizes a decimal number', () => {
    const result = tokenize('1.234')
    expect(result).to.deep.equal([{type: 'number', value: '1.234'}])
  })

  it('tokenizes a scientific notation number', () => {
    let result = tokenize('12e5')
    expect(result).to.deep.equal([{type: 'number', value: '12e5'}])

    result = tokenize('12e+5')
    expect(result).to.deep.equal([{type: 'number', value: '12e+5'}])

    result = tokenize('12E-5')
    expect(result).to.deep.equal([{type: 'number', value: '12E-5'}])
  })

  it('tokenizes null', () => {
    const result = tokenize('null')
    expect(result).to.deep.equal([{type: 'null', value: 'null'}])
  })

  it('tokenizes a string literal with brace characters', () => {
    const result = tokenize('"{hello}"')
    expect(result).to.deep.equal([{type: 'string', value: '"{hello}"'}])
  })

  it('tokenizes a string literal with bracket characters', () => {
    const result = tokenize('"[hello]"')
    expect(result).to.deep.equal([{type: 'string', value: '"[hello]"'}])
  })

  it('tokenizes a string literal with an escaped quote', () => {
    const result = tokenize(String.raw`"a\"b"`)
    expect(result).to.deep.equal([{type: 'string', value: String.raw`"a\"b"`}])
  })

  it('tokenizes a key-value pair with whitespace between the :', () => {
    const result = tokenize('"foo" : "bar"')
    expect(result).to.deep.equal([
      {type: 'key', value: '"foo"'},
      {type: 'whitespace', value: ' '},
      {type: 'colon', value: ':'},
      {type: 'whitespace', value: ' '},
      {type: 'string', value: '"bar"'},
    ])
  })

  it('given an undefined json when get token should have no results', () => {
    const result = tokenize()

    expect(result).to.deep.equal([])
  })

  it('removes circular references from json', () => {
    const obj = {
      foo: 'bar',
      baz: {
        qux: 'quux',
      },
    }
    // @ts-expect-error
    obj.circular = obj

    const result = tokenize(obj)
    expect(result).to.deep.equal([
      {type: 'brace', value: '{'},
      {type: 'key', value: '"foo"'},
      {type: 'colon', value: ':'},
      {type: 'string', value: '"bar"'},
      {type: 'comma', value: ','},
      {type: 'key', value: '"baz"'},
      {type: 'colon', value: ':'},
      {type: 'brace', value: '{'},
      {type: 'key', value: '"qux"'},
      {type: 'colon', value: ':'},
      {type: 'string', value: '"quux"'},
      {type: 'brace', value: '}'},
      {type: 'comma', value: ','},
      {type: 'key', value: '"circular"'},
      {type: 'colon', value: ':'},
      {type: 'string', value: '"[Circular ~]"'},
      {type: 'brace', value: '}'},
    ])
  })
})

describe('formatInput', () => {
  it('converts a json object to a string', () => {
    const obj = {
      foo: 'bar',
      baz: {
        qux: 'quux',
      },
    }

    const result = stringifyInput(obj)
    expect(result).to.equal('{"foo":"bar","baz":{"qux":"quux"}}')
  })

  it('converts a json string to a string', () => {
    const objString = '{"foo":"bar","baz":{"qux":"quux"}}'

    const result = stringifyInput(objString)
    expect(result).to.deep.equal(objString)
  })

  it('adds indentation to json object when pretty is true', () => {
    const obj = {
      foo: 'bar',
      baz: {
        qux: 'quux',
      },
    }

    const result = stringifyInput(obj, {pretty: true})
    expect(result).to.equal(`{
  "foo": "bar",
  "baz": {
    "qux": "quux"
  }
}`)
  })

  it('adds indentation to json string when pretty is true', () => {
    const objString = '{"foo":"bar","baz":{"qux":"quux"}}'

    const result = stringifyInput(objString, {pretty: true})
    expect(result).to.equal(`{
  "foo": "bar",
  "baz": {
    "qux": "quux"
  }
}`)
  })

  it('removes circular references from json objects', () => {
    const obj = {
      foo: 'bar',
      baz: {
        qux: 'quux',
      },
    }
    // @ts-expect-error
    obj.circular = obj

    const result = stringifyInput(obj)

    expect(JSON.parse(result)).to.deep.equal({
      foo: 'bar',
      baz: {
        qux: 'quux',
      },
      circular: '[Circular ~]',
    })
  })

  it('removes circular references from objects in json array', () => {
    const obj = {
      foo: 'bar',
      baz: {
        qux: 'quux',
      },
    }
    // @ts-expect-error
    obj.circular = obj
    const arr = [{foo: 'bar'}, obj]

    const result = stringifyInput(arr)
    expect(JSON.parse(result)).to.deep.equal([
      {
        foo: 'bar',
      },
      {
        baz: {
          qux: 'quux',
        },
        foo: 'bar',
        circular: '[Circular ~.1]',
      },
    ])
  })

  it('does not remove repeated objects', () => {
    const repeatedObj = {
      name: 'FooBar',
      state: 'Unchanged',
      path: '/path/to/file.txt',
    }
    const obj = {
      key1: [{key2: [repeatedObj]}],
      key2: [repeatedObj],
    }

    const result = JSON.parse(stringifyInput(obj))
    expect(result.key1[0].key2[0]).to.deep.equal(repeatedObj)
    expect(result.key2[0]).to.deep.equal(repeatedObj)
  })
})
````

## File: test/ux/theme.test.ts
````typescript
import ansis from 'ansis'
import {expect} from 'chai'
import sinon from 'sinon'

import * as supportsColor from '../../src/ux/supports-color'
import {colorize, parseTheme} from '../../src/ux/theme'

describe('colorize', () => {
  beforeEach(() => {
    sinon.stub(supportsColor, 'supportsColor').returns(true)
  })

  afterEach(() => {
    sinon.restore()
  })

  it('should return text with ansi characters when given hex code', () => {
    const color = '#FF0000'
    const text = colorize(color, 'brazil')
    expect(text).to.equal(ansis.hex(color)('brazil'))
  })

  it('should return text with ansi characters when standard ansis color', () => {
    const text = colorize('red', 'brazil')
    expect(text).to.equal(ansis.red('brazil'))
  })

  it('should return text without ansi characters when given undefined', () => {
    const text = colorize(undefined, 'brazil')
    expect(text).to.equal('brazil')
  })

  it('should return empty text without ansi characters when given color', () => {
    const color = '#FF0000'
    const text = colorize(color, '')
    expect(text).to.equal('')
  })

  it('should return empty text without ansi characters when given undefined', () => {
    const text = colorize(undefined, '')
    expect(text).to.equal('')
  })

  it('should return text with ansi characters when given rgb color', () => {
    const color = 'rgb(255, 0, 0)'
    const text = colorize(color, 'brazil')
    expect(text).to.equal(ansis.rgb(255, 0, 0)('brazil'))
  })

  it('should do nothing if color is not a valid color', () => {
    const text = colorize('INVALID_COLOR', 'brazil')
    expect(text).to.equal('brazil')
  })
})

describe('theme parsing', () => {
  it('should parse untyped theme json to theme using hex codes', () => {
    const untypedTheme = {
      alias: '#FFFFFF',
      bin: '#FFFFFF',
      command: '#FFFFFF',
      commandSummary: '#FFFFFF',
      dollarSign: '#FFFFFF',
      flag: '#FFFFFF',
      flagDefaultValue: '#FFFFFF',
      flagOptions: '#FFFFFF',
      flagRequired: '#FFFFFF',
      flagSeparator: '#FFFFFF',
      sectionDescription: '#FFFFFF',
      sectionHeader: '#FFFFFF',
      topic: '#FFFFFF',
      version: '#FFFFFF',
    }

    const theme = parseTheme(untypedTheme)

    expect(theme).to.deep.equal(untypedTheme)
  })

  it('should parse untyped theme json to theme using rgb', () => {
    const untypedTheme = {
      alias: 'rgb(255, 255, 255)',
    }

    const theme = parseTheme(untypedTheme)

    expect(theme).to.deep.equal({alias: 'rgb(255, 255, 255)'})
  })

  it('should parse untyped theme json to theme using ansis standard colors', () => {
    const untypedTheme = {
      alias: 'cyan',
      bin: 'cyan',
      command: 'cyan',
      commandSummary: 'cyan',
      dollarSign: 'cyan',
      flag: 'cyan',
      flagDefaultValue: 'cyan',
      flagOptions: 'cyan',
      flagRequired: 'cyan',
      flagSeparator: 'cyan',
      sectionDescription: 'cyan',
      sectionHeader: 'cyan',
      topic: 'cyan',
      version: 'cyan',
    }

    const theme = parseTheme(untypedTheme)
    for (const value of Object.values(theme)) {
      expect(value).to.equal('cyan')
    }
  })

  it('should ignore unsupported values', () => {
    const untypedTheme = {
      alias: 'FOO',
    }

    const theme = parseTheme(untypedTheme)
    expect(theme).to.deep.equal({})
  })

  it('should recursively parse nested theme', () => {
    const untypedTheme = {
      alias: 'red',
      json: {
        key: 'green',
      },
    }

    const theme = parseTheme(untypedTheme)
    expect(theme).to.deep.equal({
      alias: 'red',
      json: {
        key: 'green',
      },
    })
  })
})
````

## File: test/ux/write.test.ts
````typescript
import {captureOutput} from '@oclif/test'
import {expect} from 'chai'

import {stderr as writeStderr, stdout as writeStdout} from '../../src/ux/write'

describe('write', () => {
  describe('stdout', () => {
    it('should write with a string', async () => {
      const {stdout} = await captureOutput(async () => writeStdout('foo'))
      expect(stdout).to.equal('foo\n')
    })

    it('should write with a string array', async () => {
      const {stdout} = await captureOutput(async () => writeStdout(['foo', 'bar']))
      expect(stdout).to.equal('foo bar\n')
    })

    it('should write with formatted string', async () => {
      const {stdout} = await captureOutput(async () => writeStdout('foo %s', 'bar'))
      expect(stdout).to.equal('foo bar\n')
    })

    it('should write with formatted string array', async () => {
      const {stdout} = await captureOutput(async () => writeStdout(['%s', 'foo'], 'bar'))
      expect(stdout).to.equal('foo bar\n')
    })

    it('should handle undefined input', async () => {
      const {stdout} = await captureOutput(async () => writeStdout(undefined, 'bar'))
      expect(stdout).to.equal('bar\n')
    })

    it('should write a new line with no input', async () => {
      const {stdout} = await captureOutput(async () => writeStdout())
      expect(stdout).to.equal('\n')
    })

    it('should not lose data', async () => {
      const lines = Array.from(
        {length: 100_000},
        (_, i) =>
          `Line ${i} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer convallis fringilla sollicitudin. Nunc scelerisque neque non ipsum accumsan commodo. In et porttitor eros, ut vestibulum magna. Morbi felis diam, pharetra eu dui non, sollicitudin feugiat nisi. Aliquam cursus malesuada risus, vel luctus leo ornare sed. Morbi condimentum odio id ex facilisis bibendum. Nullam consectetur consectetur viverra. Donec nec ante dui. Integer lacinia facilisis urna vitae feugiat.`,
      )

      const {stdout} = await captureOutput(async () => {
        for (const line of lines) {
          writeStdout(line)
        }
      })

      expect(stdout).to.equal(lines.join('\n') + '\n')
    })
  })

  describe('stderr', () => {
    it('should write with a string', async () => {
      const {stderr} = await captureOutput(async () => writeStderr('foo'))
      expect(stderr).to.equal('foo\n')
    })

    it('should write with a string array', async () => {
      const {stderr} = await captureOutput(async () => writeStderr(['foo', 'bar']))
      expect(stderr).to.equal('foo bar\n')
    })

    it('should write with formatted string', async () => {
      const {stderr} = await captureOutput(async () => writeStderr('foo %s', 'bar'))
      expect(stderr).to.equal('foo bar\n')
    })

    it('should write with formatted string array', async () => {
      const {stderr} = await captureOutput(async () => writeStderr(['%s', 'foo'], 'bar'))
      expect(stderr).to.equal('foo bar\n')
    })

    it('should handle undefined input', async () => {
      const {stderr} = await captureOutput(async () => writeStderr(undefined, 'bar'))
      expect(stderr).to.equal('bar\n')
    })

    it('should write a new line with no input', async () => {
      const {stderr} = await captureOutput(async () => writeStderr())
      expect(stderr).to.equal('\n')
    })

    it('should not lose data', async () => {
      const lines = Array.from(
        {length: 100_000},
        (_, i) =>
          `Line ${i} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer convallis fringilla sollicitudin. Nunc scelerisque neque non ipsum accumsan commodo. In et porttitor eros, ut vestibulum magna. Morbi felis diam, pharetra eu dui non, sollicitudin feugiat nisi. Aliquam cursus malesuada risus, vel luctus leo ornare sed. Morbi condimentum odio id ex facilisis bibendum. Nullam consectetur consectetur viverra. Donec nec ante dui. Integer lacinia facilisis urna vitae feugiat.`,
      )

      const {stderr} = await captureOutput(async () => {
        for (const line of lines) {
          writeStderr(line)
        }
      })

      expect(stderr).to.equal(lines.join('\n') + '\n')
    })
  })
})
````

## File: test/logger.test.ts
````typescript
import {expect} from 'chai'
import sinon from 'sinon'

import {Config} from '../src/config/config'
import {clearLoggers, getLogger, setLogger} from '../src/logger'

describe('getLogger', () => {
  let childStub: sinon.SinonStub
  let config: Config

  beforeEach(async () => {
    clearLoggers()
    childStub = sinon
      .stub()
      .callsFake((ns: string, delimiter?: string) => customLogger(`MY_CLI${delimiter ?? ':'}${ns}`))
    const customLogger = (namespace: string) => ({
      child: childStub,
      debug(_formatter: unknown, ..._args: unknown[]) {},
      error(_formatter: unknown, ..._args: unknown[]) {},
      info(_formatter: unknown, ..._args: unknown[]) {},
      trace(_formatter: unknown, ..._args: unknown[]) {},
      warn(_formatter: unknown, ..._args: unknown[]) {},
      namespace,
    })

    config = await Config.load({
      root: __dirname,
      logger: customLogger('MY_CLI'),
    })
    setLogger(config)
  })

  afterEach(() => {
    sinon.restore()
  })

  it('should return the root logger if no namespace is provided', () => {
    const logger = getLogger()
    expect(logger.namespace).to.equal('MY_CLI')
  })

  it('should create a new logger if the namespace has not been created', () => {
    const logger = getLogger('test')
    expect(logger.namespace).to.equal('MY_CLI:test')
    expect(childStub.withArgs('test').callCount).to.equal(1)
  })

  it('should return a cached logger if the namespace has already been created', () => {
    getLogger('test')
    expect(childStub.withArgs('test').callCount, 'first getLogger call should call .child()').to.equal(1)

    const logger = getLogger('test')

    expect(logger.namespace).to.equal('MY_CLI:test')
    expect(childStub.withArgs('test').callCount, 'second getLogger call should not call .child()').to.equal(1)
  })

  it('should return default oclif logger if no custom logger is set', async () => {
    clearLoggers()
    const logger = getLogger()
    expect(logger.namespace).to.equal('oclif')
  })
})

describe('setLogger', () => {
  const customLogger = (namespace: string) => ({
    child: (ns: string, delimiter?: string) => customLogger(`${namespace}${delimiter ?? ':'}${ns}`),
    debug(_formatter: unknown, ..._args: unknown[]) {},
    error(_formatter: unknown, ..._args: unknown[]) {},
    info(_formatter: unknown, ..._args: unknown[]) {},
    trace(_formatter: unknown, ..._args: unknown[]) {},
    warn(_formatter: unknown, ..._args: unknown[]) {},
    namespace,
  })

  beforeEach(async () => {
    clearLoggers()
  })

  it('should set the logger to the custom logger provided in loadOptions', async () => {
    const config = await Config.load({
      root: __dirname,
      logger: customLogger('MY_CLI'),
    })
    setLogger(config)

    const logger = getLogger()
    expect(logger.namespace).to.equal('MY_CLI')
  })

  it('should set the logger to the default oclif logger if no custom logger is provided', async () => {
    const config = await Config.load({
      root: __dirname,
    })
    setLogger(config)

    const logger = getLogger()
    expect(logger.namespace).to.equal('oclif')
  })

  it('should use default logger if the provided logger does not match the Logger interface', async () => {
    const logger = customLogger('MY_CLI')
    // @ts-expect-error because we are testing an invalid logger interface
    delete logger.child
    const config = await Config.load({
      root: __dirname,
      logger,
    })
    setLogger(config)
    const oclifLogger = getLogger()
    expect(oclifLogger.namespace).to.equal('oclif')
  })
})
````

## File: test/tsconfig.json
````json
{
  "extends": "../tsconfig",
  "compilerOptions": {
    "sourceMap": true
  },
  "include": ["./**/*", "../src/**/*"]
}
````

## File: .commitlintrc.json
````json
{
  "extends": ["@commitlint/config-conventional"]
}
````

## File: .gitattributes
````
* text=auto
*.js text eol=lf
*.ts text eol=lf
````

## File: .gitignore
````
*-debug.log
*-error.log
/.nyc_output
/.vscode
/coverage
/coverage.lcov
/lib
/node_modules
/tmp
/test/tmp
.DS_Store
.idea
/test/**/node_modules
/test/**/yarn.lock
````

## File: .lintstagedrc.json
````json
{
  "*.json": ["prettier --write"],
  "*.md": ["prettier --write"],
  "+(src|test)/**/*.+(ts|js)": ["eslint --fix", "prettier --write"]
}
````

## File: .mocharc.json
````json
{
  "recursive": true,
  "reporter": "spec",
  "require": ["test/helpers/init.js", "ts-node/register"],
  "timeout": 60000,
  "watch-extensions": ["ts"],
  "watch-files": ["src", "test"],
  "watch-ignore": ["test/tmp"]
}
````

## File: .nycrc.json
````json
{
  "check-coverage": true,
  "lines": 79,
  "statements": 70,
  "functions": 70,
  "branches": 60,
  "reporter": ["lcov", "text"],
  "extension": [".ts"],
  "include": ["**/*.ts"],
  "exclude": ["**/*.d.ts", "test/**"]
}
````

## File: .prettierrc.json
````json
"@oclif/prettier-config"
````

## File: CHANGELOG.md
````markdown
## [4.4.1](https://github.com/oclif/core/compare/4.4.0...4.4.1) (2025-07-03)


### Bug Fixes

* do not list hidden arguments in usage ([#1412](https://github.com/oclif/core/issues/1412)) ([#1413](https://github.com/oclif/core/issues/1413)) ([33d8dda](https://github.com/oclif/core/commit/33d8dda070c1c19275cf1118a8b5ae7c792a93a3))



# [4.4.0](https://github.com/oclif/core/compare/4.3.3...4.4.0) (2025-06-17)


### Features

* add tar flags config ([#1400](https://github.com/oclif/core/issues/1400)) ([1923c0f](https://github.com/oclif/core/commit/1923c0f95de747a88c328dcbe28a313d7cf14431))



## [4.3.3](https://github.com/oclif/core/compare/4.3.2...4.3.3) (2025-06-09)


### Bug Fixes

* **deps:** bump tinyglobby from 0.2.13 to 0.2.14 ([#1393](https://github.com/oclif/core/issues/1393)) ([53a7354](https://github.com/oclif/core/commit/53a7354cc571e112973332e97064bd55603b3a28))



## [4.3.2](https://github.com/oclif/core/compare/4.3.1...4.3.2) (2025-06-06)


### Bug Fixes

* prevent TypeError when using version flag ([#1391](https://github.com/oclif/core/issues/1391)) ([a3f08e1](https://github.com/oclif/core/commit/a3f08e1148829157f8bd7aad44d52c30668307da))



## [4.3.1](https://github.com/oclif/core/compare/4.3.0...4.3.1) (2025-06-02)


### Bug Fixes

* migrate from globby to tinyglobby ([#1363](https://github.com/oclif/core/issues/1363)) ([#1387](https://github.com/oclif/core/issues/1387)) ([a66a7eb](https://github.com/oclif/core/commit/a66a7eba84e354e1da8ba9f1323bdaf683db2852))



# [4.3.0](https://github.com/oclif/core/compare/4.2.10...4.3.0) (2025-04-28)


### Features

* add generic for extending `Hooks` on `config.runHook` ([#1359](https://github.com/oclif/core/issues/1359)) ([#1362](https://github.com/oclif/core/issues/1362)) ([667e396](https://github.com/oclif/core/commit/667e39644c01937de913c1888339a52df4164881))



## [4.2.10](https://github.com/oclif/core/compare/4.2.9...4.2.10) (2025-03-12)


### Bug Fixes

* export validate from the Parse module ([#1331](https://github.com/oclif/core/issues/1331)) ([2fd297d](https://github.com/oclif/core/commit/2fd297d6071e442a4c11013502c7e68cdfeb128b))



## [4.2.9](https://github.com/oclif/core/compare/4.2.8...4.2.9) (2025-03-08)


### Bug Fixes

* **deps:** bump ansis from 3.16.0 to 3.17.0 ([83b4db2](https://github.com/oclif/core/commit/83b4db257094b1bbd7987339572a2b7adbb2560c))



## [4.2.8](https://github.com/oclif/core/compare/4.2.7...4.2.8) (2025-02-22)


### Bug Fixes

* **deps:** bump ansis from 3.14.0 to 3.16.0 ([beabb00](https://github.com/oclif/core/commit/beabb005271709cf80454154414e121fc4379acb))



## [4.2.7](https://github.com/oclif/core/compare/4.2.6...4.2.7) (2025-02-17)


### Bug Fixes

* **deps:** bump ansis from 3.10.0 to 3.14.0 ([#1319](https://github.com/oclif/core/issues/1319)) ([1de1085](https://github.com/oclif/core/commit/1de10854d7b51a92713c3e2275611a56f5b56e08))



## [4.2.6](https://github.com/oclif/core/compare/4.2.5...4.2.6) (2025-02-02)


### Bug Fixes

* **deps:** bump ansis from 3.9.0 to 3.10.0 ([0c3b168](https://github.com/oclif/core/commit/0c3b1685bbc130f88533c6429a212460cfa022f7))



## [4.2.5](https://github.com/oclif/core/compare/4.2.4...4.2.5) (2025-01-28)


### Bug Fixes

* **W-17692101:** migrate to eslint 9 ([#1305](https://github.com/oclif/core/issues/1305)) ([e42713c](https://github.com/oclif/core/commit/e42713cc5b5965e9ed5ac1f696609ca33922d03d))



## [4.2.4](https://github.com/oclif/core/compare/4.2.3...4.2.4) (2025-01-21)


### Bug Fixes

* **deps:** bump ansis from 3.8.1 to 3.9.0 ([#1298](https://github.com/oclif/core/issues/1298)) ([aefdbf8](https://github.com/oclif/core/commit/aefdbf8e2aeba79af078371b894daa0233678dd2))



## [4.2.3](https://github.com/oclif/core/compare/4.2.2...4.2.3) (2025-01-14)


### Bug Fixes

* **deps:** bump ansis from 3.6.0 to 3.8.1 ([#1292](https://github.com/oclif/core/issues/1292)) ([3fdceb9](https://github.com/oclif/core/commit/3fdceb9f5e47ad9ff3b88da8e8ebfe1feb10b3ef))



## [4.2.2](https://github.com/oclif/core/compare/4.2.1...4.2.2) (2025-01-07)


### Bug Fixes

* **deps:** bump ansis from 3.5.2 to 3.6.0 ([15feb6e](https://github.com/oclif/core/commit/15feb6ef88d229cabe6272eb013b3d26a8f88f12))



## [4.2.1](https://github.com/oclif/core/compare/4.2.0...4.2.1) (2025-01-06)


### Bug Fixes

* **deps:** bump ansis from 3.4.0 to 3.5.2 ([#1282](https://github.com/oclif/core/issues/1282)) ([bc1580b](https://github.com/oclif/core/commit/bc1580b432d80b084cb7698c83341826de79a63d))



# [4.2.0](https://github.com/oclif/core/compare/4.1.1...4.2.0) (2024-12-20)


### Features

* add finally hook ([16901c3](https://github.com/oclif/core/commit/16901c3d2af42655f9605bd2b9ad1a608fb1f973))



## [4.1.1](https://github.com/oclif/core/compare/4.1.0...4.1.1) (2024-12-19)


### Bug Fixes

* export action from ux ([c7fad54](https://github.com/oclif/core/commit/c7fad547f318182effee3a3976220bdeb1b1e382))



# [4.1.0](https://github.com/oclif/core/compare/4.0.37...4.1.0) (2024-12-17)


### Features

* add atLeastOne flag property ([d4746f3](https://github.com/oclif/core/commit/d4746f31272e66fa33493c27799de04444e4a285))



## [4.0.37](https://github.com/oclif/core/compare/4.0.36...4.0.37) (2024-12-13)


### Bug Fixes

* **deps:** bump nanoid from 3.3.6 to 3.3.8 ([e9cbfdb](https://github.com/oclif/core/commit/e9cbfdb7ebdf374ea08dee8d62a896229768c062))



## [4.0.36](https://github.com/oclif/core/compare/4.0.35...4.0.36) (2024-12-08)


### Bug Fixes

* **deps:** bump lilconfig from 3.1.2 to 3.1.3 ([7bdf5f3](https://github.com/oclif/core/commit/7bdf5f31b6f11be21d164e789c84d715cd21a778))



## [4.0.35](https://github.com/oclif/core/compare/4.0.34...4.0.35) (2024-12-08)


### Bug Fixes

* **deps:** bump debug from 4.3.7 to 4.4.0 ([e8aaaea](https://github.com/oclif/core/commit/e8aaaea5a2e59b3def2026257f434f71355b5ef1))



## [4.0.34](https://github.com/oclif/core/compare/4.0.33...4.0.34) (2024-12-02)


### Bug Fixes

* typo in ux module README ([#1250](https://github.com/oclif/core/issues/1250)) ([2c44e46](https://github.com/oclif/core/commit/2c44e46241337ba9f233837bef28d35e6da329f4))



## [4.0.33](https://github.com/oclif/core/compare/4.0.32...4.0.33) (2024-11-19)


### Bug Fixes

* **deps:** bump cross-spawn from 7.0.3 to 7.0.6 ([dfd138e](https://github.com/oclif/core/commit/dfd138e17338cd578215669e684a638e204d227e))



## [4.0.32](https://github.com/oclif/core/compare/4.0.31...4.0.32) (2024-11-12)


### Bug Fixes

* add env var to disable link warning ([df48c93](https://github.com/oclif/core/commit/df48c93730712a728e56f63987ae67cc5f83be2d))



## [4.0.31](https://github.com/oclif/core/compare/4.0.30...4.0.31) (2024-10-28)


### Reverts

* Revert "fix: bump is-wsl to v3 (#1211)" (#1235) ([fa76792](https://github.com/oclif/core/commit/fa767920b23e802e60c512fa42179aca0deffd12)), closes [#1211](https://github.com/oclif/core/issues/1211) [#1235](https://github.com/oclif/core/issues/1235)



## [4.0.30](https://github.com/oclif/core/compare/4.0.29...4.0.30) (2024-10-22)


### Bug Fixes

* fix aliases in config.commandIDs missing the default topic separator ([#1229](https://github.com/oclif/core/issues/1229)) ([#1230](https://github.com/oclif/core/issues/1230)) ([f86d9f7](https://github.com/oclif/core/commit/f86d9f736e40abb345dc9f261efb7aa5068d8a97))



## [4.0.29](https://github.com/oclif/core/compare/4.0.28...4.0.29) (2024-10-15)


### Bug Fixes

* improve solution for handling circular json ([#1222](https://github.com/oclif/core/issues/1222)) ([9073052](https://github.com/oclif/core/commit/90730524f2e695dce3dc2b87ec43e480f0dcdd54))



## [4.0.28](https://github.com/oclif/core/compare/4.0.27...4.0.28) (2024-10-11)


### Bug Fixes

* remove circular references when colorizing json ([de9ed4e](https://github.com/oclif/core/commit/de9ed4e236b0f0db82ce84ee6ff22e356d5dd9dd))



## [4.0.27](https://github.com/oclif/core/compare/4.0.26...4.0.27) (2024-10-03)


### Bug Fixes

* add respectNoCacheDefault to help options ([7320fff](https://github.com/oclif/core/commit/7320fff4860fe788674e672e6c284340fdc48918))



## [4.0.26](https://github.com/oclif/core/compare/4.0.25...4.0.26) (2024-10-02)


### Bug Fixes

* bump is-wsl to v3 ([#1211](https://github.com/oclif/core/issues/1211)) ([7fd9162](https://github.com/oclif/core/commit/7fd9162a165884657c2ead87f5c0e9e2fd9b708d))



## [4.0.25](https://github.com/oclif/core/compare/4.0.24...4.0.25) (2024-10-01)


### Bug Fixes

* deprecated aliases bug ([#1208](https://github.com/oclif/core/issues/1208)) ([353e715](https://github.com/oclif/core/commit/353e715d483c24dcfd425ea03f4da3f5ab510c89))



## [4.0.24](https://github.com/oclif/core/compare/4.0.23...4.0.24) (2024-10-01)


### Bug Fixes

* use topic separator for deprecated alias warnings in `help` ([#1209](https://github.com/oclif/core/issues/1209)) ([fb6ace2](https://github.com/oclif/core/commit/fb6ace237c5f6b3f7707edb7ba93e00aeee9b412))



## [4.0.23](https://github.com/oclif/core/compare/4.0.22...4.0.23) (2024-09-23)


### Bug Fixes

* warn about node version mismatch ([#1198](https://github.com/oclif/core/issues/1198)) ([ae2ceac](https://github.com/oclif/core/commit/ae2ceac79feea1d7c5acce7fbfdfae0a63711f6d))



## [4.0.22](https://github.com/oclif/core/compare/4.0.21...4.0.22) (2024-09-13)


### Bug Fixes

* **deps:** bump path-to-regexp from 6.2.1 to 6.3.0 ([d051b64](https://github.com/oclif/core/commit/d051b64cbb541184ff20c77f2ff85945d2e316aa))



## [4.0.21](https://github.com/oclif/core/compare/4.0.20...4.0.21) (2024-09-07)


### Bug Fixes

* **deps:** bump debug from 4.3.6 to 4.3.7 ([839ab85](https://github.com/oclif/core/commit/839ab85290eaf6281527462fb585366c77953e59))



## [4.0.20](https://github.com/oclif/core/compare/4.0.19...4.0.20) (2024-09-04)


### Bug Fixes

* handle large throughput writes ([5e336ce](https://github.com/oclif/core/commit/5e336cea259d33bc9e43c7656eb29ceff8f6e5c9))



## [4.0.19](https://github.com/oclif/core/compare/4.0.18...4.0.19) (2024-08-24)


### Bug Fixes

* **deps:** bump micromatch from 4.0.7 to 4.0.8 ([eb2aa14](https://github.com/oclif/core/commit/eb2aa14f4d75728f740ea0fe6ac2796d9323c315))



## [4.0.18](https://github.com/oclif/core/compare/4.0.17...4.0.18) (2024-08-21)


### Bug Fixes

* **ts-path:** use file url to import `tsx` at runtime ([#1171](https://github.com/oclif/core/issues/1171)) ([be3f6e9](https://github.com/oclif/core/commit/be3f6e9c2a028d87a154ade81d032b311b2ca24f))



## [4.0.17](https://github.com/oclif/core/compare/4.0.16...4.0.17) (2024-07-28)


### Bug Fixes

* **deps:** bump ansis from 3.3.1 to 3.3.2 ([081e8bc](https://github.com/oclif/core/commit/081e8bc6f4e13118c4b377e3b15f40658695bbda))



## [4.0.16](https://github.com/oclif/core/compare/4.0.15...4.0.16) (2024-07-27)


### Bug Fixes

* **deps:** bump requirejs from 2.3.6 to 2.3.7 ([216d8e7](https://github.com/oclif/core/commit/216d8e7a050c7bd4cdba82c6920c6e9744186ed2))



## [4.0.15](https://github.com/oclif/core/compare/4.0.14...4.0.15) (2024-07-26)


### Bug Fixes

* ignore escaped delimiters ([#1148](https://github.com/oclif/core/issues/1148)) ([a41962a](https://github.com/oclif/core/commit/a41962af85fb9d84040614c4a1aab7a8e4c7d4af))



## [4.0.14](https://github.com/oclif/core/compare/4.0.13...4.0.14) (2024-07-23)


### Bug Fixes

* husky 9.1.1 fix ([#1147](https://github.com/oclif/core/issues/1147)) ([cd3720f](https://github.com/oclif/core/commit/cd3720f9722b619be229b1605f354020c44df21e))



## [4.0.13](https://github.com/oclif/core/compare/4.0.12...4.0.13) (2024-07-21)


### Bug Fixes

* **deps:** bump ansis from 3.2.1 to 3.3.1 ([a0eba0a](https://github.com/oclif/core/commit/a0eba0abec7aa297fe0fc38ea60e9f26f4ce7166))



## [4.0.12](https://github.com/oclif/core/compare/4.0.11...4.0.12) (2024-07-13)


### Bug Fixes

* **deps:** bump ansis from 3.2.0 to 3.2.1 ([0d84684](https://github.com/oclif/core/commit/0d846842dea1c1963c93d4581d2211eb1a16ba14))



## [4.0.11](https://github.com/oclif/core/compare/4.0.10...4.0.11) (2024-07-10)


### Bug Fixes

* export ArgDefinition ([#1137](https://github.com/oclif/core/issues/1137)) ([db8d951](https://github.com/oclif/core/commit/db8d9513862d9702cb573d5d0544e0e164427032))



## [4.0.10](https://github.com/oclif/core/compare/4.0.9...4.0.10) (2024-07-10)


### Bug Fixes

* use colorize to ensure proper TTY detection ([8a5d71f](https://github.com/oclif/core/commit/8a5d71f93104ce17555adc28998db0520a2a7187))



## [4.0.9](https://github.com/oclif/core/compare/4.0.8...4.0.9) (2024-07-09)


### Bug Fixes

* correctly identify powershell on windows ([#1134](https://github.com/oclif/core/issues/1134)) ([bcec7df](https://github.com/oclif/core/commit/bcec7dfbcb27579ddd312f8ebda5a7b6c0829e98))



## [4.0.8](https://github.com/oclif/core/compare/4.0.7...4.0.8) (2024-07-01)


### Bug Fixes

* **deps:** bump minimatch from 9.0.4 to 9.0.5 ([#1126](https://github.com/oclif/core/issues/1126)) ([ab337cf](https://github.com/oclif/core/commit/ab337cfd14dea9c0a8449921904beb6945c3dc22))



## [4.0.7](https://github.com/oclif/core/compare/4.0.6...4.0.7) (2024-06-25)


### Bug Fixes

* ignore cache when reading user pjson ([#1124](https://github.com/oclif/core/issues/1124)) ([6038c5c](https://github.com/oclif/core/commit/6038c5c34aca5442e2034c6c574f9c20150bb2f9)), closes [#1125](https://github.com/oclif/core/issues/1125)



## [4.0.6](https://github.com/oclif/core/compare/4.0.5...4.0.6) (2024-06-12)


### Bug Fixes

* single command cli symbol on help output ([#1112](https://github.com/oclif/core/issues/1112)) ([5de6a40](https://github.com/oclif/core/commit/5de6a402129299a3b0d17dc6ddc2dc1cd82b6005))



## [4.0.5](https://github.com/oclif/core/compare/4.0.4...4.0.5) (2024-06-12)


### Bug Fixes

* **deps:** bump braces from 3.0.2 to 3.0.3 ([d20f082](https://github.com/oclif/core/commit/d20f082dea6f13d2c2f25c2cb68ee40f0ec170ec))



## [4.0.4](https://github.com/oclif/core/compare/4.0.3...4.0.4) (2024-06-11)


### Bug Fixes

* use lilconfig ([#1108](https://github.com/oclif/core/issues/1108)) ([804db9b](https://github.com/oclif/core/commit/804db9b5a5c35a1d2cdc85d8635f61ca44a27e04))



## [4.0.3](https://github.com/oclif/core/compare/4.0.2...4.0.3) (2024-06-06)


### Bug Fixes

* export parser related types ([#1099](https://github.com/oclif/core/issues/1099)) ([0daafdd](https://github.com/oclif/core/commit/0daafdd47f4f7925502513dc9097193a691bad1f))



## [4.0.2](https://github.com/oclif/core/compare/4.0.1...4.0.2) (2024-06-05)


### Bug Fixes

* add export for parser ([#1098](https://github.com/oclif/core/issues/1098)) ([f7bfc76](https://github.com/oclif/core/commit/f7bfc7607ecafbe669696b6b18a332af617dd981))



## [4.0.1](https://github.com/oclif/core/compare/4.0.0...4.0.1) (2024-06-04)


### Bug Fixes

* parsed args regression ([#1096](https://github.com/oclif/core/issues/1096)) ([53f915b](https://github.com/oclif/core/commit/53f915b949596a0a30784586790f5cdee6a60426))



# [4.0.0](https://github.com/oclif/core/compare/3.27.0...4.0.0) (2024-06-04)



# [3.27.0](https://github.com/oclif/core/compare/3.26.9...3.27.0) (2024-06-04)


### Features

* added option to specify example flag value in docopts ([#1095](https://github.com/oclif/core/issues/1095)) ([0345ac3](https://github.com/oclif/core/commit/0345ac33bb8726c4d9870d4f2a8f3dcdee8bd07a)), closes [#1091](https://github.com/oclif/core/issues/1091)



## [3.26.9](https://github.com/oclif/core/compare/3.26.8...3.26.9) (2024-06-03)


### Bug Fixes

* only replace command id in usage if it's at beginning of string ([#1090](https://github.com/oclif/core/issues/1090)) ([3916945](https://github.com/oclif/core/commit/391694559446ef82bc5fc307e6e9ff72e44f7558))



## [3.26.8](https://github.com/oclif/core/compare/3.26.7...3.26.8) (2024-06-03)


### Bug Fixes

* **deps:** bump debug from 4.3.4 to 4.3.5 ([#1093](https://github.com/oclif/core/issues/1093)) ([58b9fed](https://github.com/oclif/core/commit/58b9fed6c7b32026279afc707227aab8dfb4ef6f))



## [3.26.7](https://github.com/oclif/core/compare/3.26.6...3.26.7) (2024-06-03)


### Bug Fixes

* get core meta version ([#1094](https://github.com/oclif/core/issues/1094)) ([9639fd4](https://github.com/oclif/core/commit/9639fd421824f58fbd209b771f0bdd5eac0426d0))



## [3.26.6](https://github.com/oclif/core/compare/3.26.5...3.26.6) (2024-05-06)


### Bug Fixes

* new "dont check npm" option for plugin-update  ([#1071](https://github.com/oclif/core/issues/1071)) ([9ccc797](https://github.com/oclif/core/commit/9ccc797c314d032daaee6ffd9a27da4dbbca882a))



## [3.26.5](https://github.com/oclif/core/compare/3.26.4...3.26.5) (2024-04-30)


### Bug Fixes

* better warnings ([439e933](https://github.com/oclif/core/commit/439e9339e693fcf116ba41cb62cc831a2dc27f59))



## [3.26.4](https://github.com/oclif/core/compare/3.26.3...3.26.4) (2024-04-18)


### Bug Fixes

* **deps:** bump tar from 6.1.15 to 6.2.1 ([#1049](https://github.com/oclif/core/issues/1049)) ([6507e37](https://github.com/oclif/core/commit/6507e37007b565060aed26bfe9d5c371830d80cf))



## [3.26.3](https://github.com/oclif/core/compare/3.26.2...3.26.3) (2024-04-13)


### Bug Fixes

* **deps:** bump ejs from 3.1.9 to 3.1.10 ([72dd869](https://github.com/oclif/core/commit/72dd869b54f49ac14cab7a0bd5409ec523ae4332))



## [3.26.2](https://github.com/oclif/core/compare/3.26.1...3.26.2) (2024-04-08)


### Bug Fixes

* do not throw an error if a flag with allowStdin='only' is immediately followed by another flag ([#1046](https://github.com/oclif/core/issues/1046)) ([#1047](https://github.com/oclif/core/issues/1047)) ([f05b0c8](https://github.com/oclif/core/commit/f05b0c8119853b8a9de62d9076a42d8d93a94046))



## [3.26.1](https://github.com/oclif/core/compare/3.26.0...3.26.1) (2024-04-08)


### Bug Fixes

* **deps:** bump minimatch from 9.0.3 to 9.0.4 ([#1041](https://github.com/oclif/core/issues/1041)) ([87cd0e6](https://github.com/oclif/core/commit/87cd0e6cafba4e2d461a9a9d61f729e694091558))



# [3.26.0](https://github.com/oclif/core/compare/3.25.3...3.26.0) (2024-03-22)


### Features

* add preparse hook ([#1005](https://github.com/oclif/core/issues/1005)) ([80745c4](https://github.com/oclif/core/commit/80745c46942cf69653afac8ed242da9f58631d82))



## [3.25.3](https://github.com/oclif/core/compare/3.25.2...3.25.3) (2024-03-19)


### Bug Fixes

* show options when required flag or arg is not given a value ([#1017](https://github.com/oclif/core/issues/1017)) ([003ad6f](https://github.com/oclif/core/commit/003ad6fc2d28a53db3335237de02aa244cb9cbec))



## [3.25.2](https://github.com/oclif/core/compare/3.25.1...3.25.2) (2024-03-15)


### Bug Fixes

* allow .tsx and .jsx help class files ([#1016](https://github.com/oclif/core/issues/1016)) ([0b7385f](https://github.com/oclif/core/commit/0b7385f4938368aa18110f1f79273d6476eb0ed7))



## [3.25.1](https://github.com/oclif/core/compare/3.25.0...3.25.1) (2024-03-14)


### Bug Fixes

* ensure string is passed to process.emitWarning ([#1015](https://github.com/oclif/core/issues/1015)) ([47081db](https://github.com/oclif/core/commit/47081db8dedacc2f553d53cd157f1db8cbd9ad2e))



# [3.25.0](https://github.com/oclif/core/compare/3.24.0...3.25.0) (2024-03-12)


### Features

* show truncated help on some errors ([#1004](https://github.com/oclif/core/issues/1004)) ([7133a97](https://github.com/oclif/core/commit/7133a9725c1308e6b203d7e6fc192f529a9f48d1))



# [3.24.0](https://github.com/oclif/core/compare/3.23.1...3.24.0) (2024-03-11)


### Bug Fixes

* use correct prop name ([a509fa4](https://github.com/oclif/core/commit/a509fa4f999511f767c3eb0afb1f37476da64213))


### Features

* print ellipsis on arg if static is false ([7a71524](https://github.com/oclif/core/commit/7a71524c88906d2fbbfd7ede8dd16175560c9461))



## [3.23.1](https://github.com/oclif/core/compare/3.23.0...3.23.1) (2024-03-11)


### Bug Fixes

* remove configured id from usage override ([#1012](https://github.com/oclif/core/issues/1012)) ([a8efedd](https://github.com/oclif/core/commit/a8efedde818f0e62577c39c470c7419cc25de255))



# [3.23.0](https://github.com/oclif/core/compare/3.22.0...3.23.0) (2024-03-05)


### Features

* deprecate ux module ([#1000](https://github.com/oclif/core/issues/1000)) ([503c7ae](https://github.com/oclif/core/commit/503c7ae39aa1e42cebf79bdd98c05d85c3721309))



# [3.22.0](https://github.com/oclif/core/compare/3.21.2...3.22.0) (2024-03-05)


### Features

* support plugins with wildcards ([966db94](https://github.com/oclif/core/commit/966db94f6f6e82630b2bf7eadf1d277ee0aa79c0))



## [3.21.2](https://github.com/oclif/core/compare/3.21.1...3.21.2) (2024-03-04)


### Bug Fixes

* improve module load error handling ([#996](https://github.com/oclif/core/issues/996)) ([5cec2b2](https://github.com/oclif/core/commit/5cec2b20e637c536d2bbeefc1c6119676f65cfad))



## [3.21.1](https://github.com/oclif/core/compare/3.21.0...3.21.1) (2024-03-04)


### Bug Fixes

* allow arg to be empty string ([629d482](https://github.com/oclif/core/commit/629d482d0059486c78054a66983a3a228ece7993))



# [3.21.0](https://github.com/oclif/core/compare/3.20.0...3.21.0) (2024-03-04)


### Features

* add strategies for command discovery ([#945](https://github.com/oclif/core/issues/945)) ([eaf5a86](https://github.com/oclif/core/commit/eaf5a8692c85d37b1c1728230a851151a895704f))



# [3.20.0](https://github.com/oclif/core/compare/3.19.7...3.20.0) (2024-02-27)


### Features

* add enableAutoTranspile setting ([ae66106](https://github.com/oclif/core/commit/ae661065301da5f6e6c970633a246376acaf3a99))
* support bun and tsx for development ([17ad3e6](https://github.com/oclif/core/commit/17ad3e69d40d4dcbfd35576ea61acd5f9b64334e))



## [3.19.7](https://github.com/oclif/core/compare/3.19.6...3.19.7) (2024-02-26)


### Bug Fixes

* dont assume plugin-help is installed ([35acf97](https://github.com/oclif/core/commit/35acf97c04a3050305e496ff1d71ff484b18fce3))



## [3.19.6](https://github.com/oclif/core/compare/3.19.5...3.19.6) (2024-02-23)


### Bug Fixes

* revert to original prompt implementation ([a96e567](https://github.com/oclif/core/commit/a96e5679c366a300d3149cecd2ef8fd3fb11a954))



## [3.19.5](https://github.com/oclif/core/compare/3.19.4...3.19.5) (2024-02-22)


### Bug Fixes

* only set timeout for TTY ([8a97f20](https://github.com/oclif/core/commit/8a97f2087d07290474d9bf224057322ae2abe4bc))



## [3.19.4](https://github.com/oclif/core/compare/3.19.3...3.19.4) (2024-02-21)


### Bug Fixes

* **deps:** bump ip from 2.0.0 to 2.0.1 ([c2dcb43](https://github.com/oclif/core/commit/c2dcb4371a0468367677f0b575aad067e75c5136))



## [3.19.3](https://github.com/oclif/core/compare/3.19.2...3.19.3) (2024-02-19)


### Bug Fixes

* clear timeout when prompt times out ([#961](https://github.com/oclif/core/issues/961)) ([f5c698a](https://github.com/oclif/core/commit/f5c698af081d171f246fefc0d1509e4dd84d7e3a))



## [3.19.2](https://github.com/oclif/core/compare/3.19.1...3.19.2) (2024-02-14)


### Bug Fixes

* allow long text in ux.prompt ([7d521b2](https://github.com/oclif/core/commit/7d521b2350e488bf5c1570f8f82bf7a582eea0d8))



## [3.19.1](https://github.com/oclif/core/compare/3.19.0...3.19.1) (2024-02-06)


### Bug Fixes

* **parser:** cache stdin value in global scope ([#935](https://github.com/oclif/core/issues/935)) ([c8bf886](https://github.com/oclif/core/commit/c8bf886c570ab4dc3b8a139be4a716d4e6a053af))



# [3.19.0](https://github.com/oclif/core/compare/3.18.2...3.19.0) (2024-02-05)


### Bug Fixes

* dont indent when no shor char ([03c597a](https://github.com/oclif/core/commit/03c597a851442be8785401680b89af295ed95e52))
* merge default and user theme ([3798f4c](https://github.com/oclif/core/commit/3798f4cc4ec6165917b61c009ad7a044dc556b7a))
* prefer user theme ([5eaed66](https://github.com/oclif/core/commit/5eaed66ead363e29c324ce171ef6ebe01e694ad9))
* return undefined if no theme ([3cb3373](https://github.com/oclif/core/commit/3cb33734ff0a69e3d24f129ff210e8e52139002d))


### Features

* allow theme file to be configurable ([ab502b4](https://github.com/oclif/core/commit/ab502b4e151d854dacd6025fb1dd27bc94c2f154))



## [3.18.2](https://github.com/oclif/core/compare/3.18.1...3.18.2) (2024-01-31)


### Bug Fixes

* update keywords ([#933](https://github.com/oclif/core/issues/933)) ([a733b58](https://github.com/oclif/core/commit/a733b5866933a2df489678d64d6e0ad037241756))



## [3.18.1](https://github.com/oclif/core/compare/3.18.0...3.18.1) (2024-01-10)


### Bug Fixes

* make @types/cli-progress a dependency ([#922](https://github.com/oclif/core/issues/922)) ([6528850](https://github.com/oclif/core/commit/6528850442e7c537d089f119f3f71299a1b54e5b))



# [3.18.0](https://github.com/oclif/core/compare/3.17.0...3.18.0) (2024-01-09)


### Features

* no longer use tsconfck ([79c4028](https://github.com/oclif/core/commit/79c40280f5bb75fca271fabd921702347f54445a))



# [3.17.0](https://github.com/oclif/core/compare/3.16.0...3.17.0) (2024-01-09)


### Features

* add node.options to pjson typings ([#919](https://github.com/oclif/core/issues/919)) ([42b113b](https://github.com/oclif/core/commit/42b113b1d462267150deff7568d2974efba7e0f6)), closes [oclif/oclif#1238](https://github.com/oclif/oclif/issues/1238)



# [3.16.0](https://github.com/oclif/core/compare/3.15.1...3.16.0) (2024-01-02)


### Features

* add 'only' option to allowStdin ([#900](https://github.com/oclif/core/issues/900)) ([4f7346e](https://github.com/oclif/core/commit/4f7346e2ebcbf72181f147e38a7d94bcd443c08b))



## [3.15.1](https://github.com/oclif/core/compare/3.15.0...3.15.1) (2023-12-23)


### Bug Fixes

* **deps:** bump password-prompt from 1.1.2 to 1.1.3 ([39f8860](https://github.com/oclif/core/commit/39f8860e6da3b9bd98ed9c5357cbdbe66f73b186))



# [3.15.0](https://github.com/oclif/core/compare/3.14.1...3.15.0) (2023-12-15)


### Features

* add flagSortOrder to help options ([#896](https://github.com/oclif/core/issues/896)) ([3903720](https://github.com/oclif/core/commit/3903720377dde5c9f92d8c24f57cf9a32e516b3d))



## [3.14.1](https://github.com/oclif/core/compare/3.14.0...3.14.1) (2023-12-08)


### Bug Fixes

* peserve original error coming from failed flag parsing ([#897](https://github.com/oclif/core/issues/897)) ([a7a3bba](https://github.com/oclif/core/commit/a7a3bbabdf2a6cce19dd86583ca91409e0de3123))



# [3.14.0](https://github.com/oclif/core/compare/3.13.2...3.14.0) (2023-12-07)


### Features

* allowStdin option for flags ([#894](https://github.com/oclif/core/issues/894)) ([#895](https://github.com/oclif/core/issues/895)) ([379e940](https://github.com/oclif/core/commit/379e9401f8c8f7400be71e2e45c65fd6564a8c21))



## [3.13.2](https://github.com/oclif/core/compare/3.13.1...3.13.2) (2023-12-04)


### Bug Fixes

* add exit codes to different flag validation errors ([#861](https://github.com/oclif/core/issues/861)) ([1c841bf](https://github.com/oclif/core/commit/1c841bf296f89529183a182433ce2baddc697072))



## [3.13.1](https://github.com/oclif/core/compare/3.13.0...3.13.1) (2023-11-30)


### Bug Fixes

* cache this.commandsDir ([#891](https://github.com/oclif/core/issues/891)) ([7b217a4](https://github.com/oclif/core/commit/7b217a45aac2aa44bc696054924ef2280ecdc944))



# [3.13.0](https://github.com/oclif/core/compare/3.12.1...3.13.0) (2023-11-30)


### Features

* add 'multipleNonGreedy' flag option to assign only one value per multiple flag ([#880](https://github.com/oclif/core/issues/880)) ([#889](https://github.com/oclif/core/issues/889)) ([354cead](https://github.com/oclif/core/commit/354cead9ae44ac8036911fce8ba94f085294ceb9))



## [3.12.1](https://github.com/oclif/core/compare/3.12.0...3.12.1) (2023-11-30)


### Bug Fixes

* command not found on empty arg ([#887](https://github.com/oclif/core/issues/887)) ([#888](https://github.com/oclif/core/issues/888)) ([a8ca6cc](https://github.com/oclif/core/commit/a8ca6cc495d7aeba2b276477ab8217ec22f0ce63))



# [3.12.0](https://github.com/oclif/core/compare/3.11.0...3.12.0) (2023-11-20)


### Features

* enable themes ([#852](https://github.com/oclif/core/issues/852)) ([#862](https://github.com/oclif/core/issues/862)) ([da2bd5b](https://github.com/oclif/core/commit/da2bd5b30edc1d4c682e440e31f115471ed469e4))



# [3.11.0](https://github.com/oclif/core/compare/3.10.8...3.11.0) (2023-11-13)


### Features

* indent all flags with no char below each other ([#863](https://github.com/oclif/core/issues/863)) ([#872](https://github.com/oclif/core/issues/872)) ([0fcd6ed](https://github.com/oclif/core/commit/0fcd6edc12e839a2b6ef9cf33550862840547fbf))



## [3.10.8](https://github.com/oclif/core/compare/3.10.7...3.10.8) (2023-11-08)


### Bug Fixes

* move up prod check in tsPath ([#858](https://github.com/oclif/core/issues/858)) ([204de58](https://github.com/oclif/core/commit/204de58ddd158e10943007d50c658e0e1ef81d4f))



## [3.10.7](https://github.com/oclif/core/compare/3.10.6...3.10.7) (2023-11-07)


### Bug Fixes

* handle undefined flags in help ([bd5a38f](https://github.com/oclif/core/commit/bd5a38f3abb05586b71b2bbe8c202987f38ba5da))



## [3.10.6](https://github.com/oclif/core/compare/3.10.5...3.10.6) (2023-11-06)


### Bug Fixes

* improve plugin loading performance ([#856](https://github.com/oclif/core/issues/856)) ([3c17c24](https://github.com/oclif/core/commit/3c17c24b3955c9d74e462790c3cf0a46908a2b85)), closes [#857](https://github.com/oclif/core/issues/857)



## [3.10.5](https://github.com/oclif/core/compare/3.10.4...3.10.5) (2023-11-06)


### Bug Fixes

* extra parens in debug logs ([81c9efc](https://github.com/oclif/core/commit/81c9efcb1a042344761bbea01f12e54e39190c59))



## [3.10.4](https://github.com/oclif/core/compare/3.10.3...3.10.4) (2023-11-06)


### Bug Fixes

* **deps:** bump get-func-name from 2.0.0 to 2.0.2 ([#796](https://github.com/oclif/core/issues/796)) ([a6c5f3c](https://github.com/oclif/core/commit/a6c5f3c18721b0f2893ea17eb4eb9cc4c2774869))



## [3.10.3](https://github.com/oclif/core/compare/3.10.2...3.10.3) (2023-11-06)


### Bug Fixes

* **deps:** bump postcss from 8.4.30 to 8.4.31 ([#809](https://github.com/oclif/core/issues/809)) ([fd938d3](https://github.com/oclif/core/commit/fd938d3a91f58cad5c59286815567a0cff14b69d))



## [3.10.2](https://github.com/oclif/core/compare/3.10.1...3.10.2) (2023-11-06)


### Bug Fixes

* dont drop ts-node options if there are no extends ([#853](https://github.com/oclif/core/issues/853)) ([039b42a](https://github.com/oclif/core/commit/039b42a9dcfb8e1bd953820bf65d7c9ddbbf9740))



## [3.10.1](https://github.com/oclif/core/compare/3.10.0...3.10.1) (2023-11-03)


### Bug Fixes

* check for ENOENT code ([44fb9dc](https://github.com/oclif/core/commit/44fb9dc40a307ea1656e726806b62c9d165ae32f))
* handle non-existent tsconfig ([0b15536](https://github.com/oclif/core/commit/0b15536b1b021eec182b18e99d5ab2b6c9deacd3))
* support jsonc tsconfig ([026f835](https://github.com/oclif/core/commit/026f8358006eea5651961070d77105111e1a37a2))
* use tsconfck to handle json-c ([7f0c9f0](https://github.com/oclif/core/commit/7f0c9f0a78c9d4f78bbdcc8b174aef01a007a918))



# [3.10.0](https://github.com/oclif/core/compare/3.9.2...3.10.0) (2023-11-02)


### Features

* read extended tsconfigs ([#845](https://github.com/oclif/core/issues/845)) ([59145ee](https://github.com/oclif/core/commit/59145ee40ec33f70aec3fb79c1431de19e7fb041))



## [3.9.2](https://github.com/oclif/core/compare/3.9.1...3.9.2) (2023-10-30)


### Bug Fixes

* support `hasDynamicHelp` for v2 commands ([#844](https://github.com/oclif/core/issues/844)) ([1b1e053](https://github.com/oclif/core/commit/1b1e053e47e3e5dcd529db3d0fe8a9dd282c56bf))



## [3.9.1](https://github.com/oclif/core/compare/3.9.0...3.9.1) (2023-10-27)


### Bug Fixes

* restore exit(0) behavior ([0c3fdd7](https://github.com/oclif/core/commit/0c3fdd7a7e3bfe605274d69894e9a2fba8c2e3d7))



# [3.9.0](https://github.com/oclif/core/compare/3.8.0...3.9.0) (2023-10-26)


### Features

* export ModuleLoader ([5e40c0b](https://github.com/oclif/core/commit/5e40c0bd1100db022a721a5258a9c75057cc39ef))



# [3.8.0](https://github.com/oclif/core/compare/3.7.1...3.8.0) (2023-10-25)


### Features

* run tsPath on hooks ([8275a2e](https://github.com/oclif/core/commit/8275a2ea5ab93c9a387ce90170afcf6a3205ca04))



## [3.7.1](https://github.com/oclif/core/compare/3.7.0...3.7.1) (2023-10-24)



## [3.3.3-dev.0](https://github.com/oclif/core/compare/3.3.2...3.3.3-dev.0) (2023-10-18)


### Bug Fixes

* clear commands belogning to legacy plugins before reloading ([6a53997](https://github.com/oclif/core/commit/6a5399704a9644d26c54269ae88cbbb420af5490))



# [3.7.0](https://github.com/oclif/core/compare/3.6.0...3.7.0) (2023-10-24)


### Features

* remove ux.makeStubs ([8a81413](https://github.com/oclif/core/commit/8a81413267f30f60aa91b7c6875f74385850044d))



# [3.6.0](https://github.com/oclif/core/compare/3.4.1-dev.0...3.6.0) (2023-10-23)


### Bug Fixes

* safely fail if pnpapi cannot be found ([c2fc8d2](https://github.com/oclif/core/commit/c2fc8d2cfe4360602ad8be9ae5c4fe1947c9ef27))



# [3.5.0](https://github.com/oclif/core/compare/3.4.0...3.5.0) (2023-10-19)



## [3.4.1-dev.0](https://github.com/oclif/core/compare/3.5.0...3.4.1-dev.0) (2023-10-19)


### Features

* better support yarn PnP ([c5d87fc](https://github.com/oclif/core/commit/c5d87fc9bb30973fb055143c92df7bc27de16554))
* support pnp plugins ([8e217a6](https://github.com/oclif/core/commit/8e217a6b9a0d5824113f0c68c9be009440331f23))



# [3.5.0](https://github.com/oclif/core/compare/3.4.0...3.5.0) (2023-10-19)


### Bug Fixes

* compile error ([15d6556](https://github.com/oclif/core/commit/15d65561583e5f419ce0037435978f2a58745f0c))


### Features

* don't error on exit code 0 ([c62fb01](https://github.com/oclif/core/commit/c62fb012a8e579c46f76d66397abe40a3894a9b1))



# [3.4.0](https://github.com/oclif/core/compare/3.3.3...3.4.0) (2023-10-19)


### Bug Fixes

* add pluginPrefix type ([f14181e](https://github.com/oclif/core/commit/f14181e071f8c5d7f93646eef2e8d35b39dde0a7))


### Features

* export ux stubs ([4b7cdda](https://github.com/oclif/core/commit/4b7cddafef4e0f4a494b8be273f09575081a93c8))
* no longer use wrapped process.stdout and process.stderr ([3ff5f63](https://github.com/oclif/core/commit/3ff5f6357a1157aa402ca580babb05eb13e7a249))



## [3.3.3](https://github.com/oclif/core/compare/3.3.3-dev.0...3.3.3) (2023-10-19)


### Bug Fixes

* allow github-installed plugins to be auto-transpiled ([6f2c5e2](https://github.com/oclif/core/commit/6f2c5e2ec9b9bafa7dea4ae2e7350ada64ff0e88))
* handle ModuleLoadError from hooks ([0321093](https://github.com/oclif/core/commit/0321093e4f8a0f659346a9e2e808ad44c6d3771f))



## [3.3.3-dev.0](https://github.com/oclif/core/compare/3.3.2...3.3.3-dev.0) (2023-10-18)


### Bug Fixes

* clear commands belogning to legacy plugins before reloading ([6a53997](https://github.com/oclif/core/commit/6a5399704a9644d26c54269ae88cbbb420af5490))



## [3.3.2](https://github.com/oclif/core/compare/3.3.1...3.3.2) (2023-10-17)


### Bug Fixes

* **deps:** bump @babel/traverse from 7.23.0 to 7.23.2 ([d53498a](https://github.com/oclif/core/commit/d53498af1da6bdcb3fb70f7c0b6e0da8da0831a1))



## [3.3.1](https://github.com/oclif/core/compare/3.3.0...3.3.1) (2023-10-16)


### Bug Fixes

* add frequency and frequencyUnit to warn-if-update ([#827](https://github.com/oclif/core/issues/827)) ([3567c74](https://github.com/oclif/core/commit/3567c748a8a04ab94cca493aa1dfcb4f10370f6e))



# [3.3.0](https://github.com/oclif/core/compare/3.2.1...3.3.0) (2023-10-16)



## [3.2.1](https://github.com/oclif/core/compare/3.2.0...3.2.1) (2023-10-13)


### Bug Fixes

* add types for warn-if-update-available ([#826](https://github.com/oclif/core/issues/826)) ([5464dcf](https://github.com/oclif/core/commit/5464dcf0933bd8afec26704662dfc5276ef07f47))



# [3.2.0](https://github.com/oclif/core/compare/3.1.0...3.2.0) (2023-10-13)


### Bug Fixes

* add Cache class for caching root plugin ([9452b19](https://github.com/oclif/core/commit/9452b191dafe64bd50bda116baa62c0b14552af3))
* bump ejs and other deps ([14a0e48](https://github.com/oclif/core/commit/14a0e48c5e9868bff9c28a640073966aa138528c))
* ignore .d.mts and .d.cts ([4ba853f](https://github.com/oclif/core/commit/4ba853fe51b0d0f623921ed025f61cf6665f66f3))
* support baseUrl for ts source ([03b824b](https://github.com/oclif/core/commit/03b824bdfc61810bc4e4ff89b21cccd3dfe0ebe4))


### Features

* support .mts and .cts file extensions ([5f16e0b](https://github.com/oclif/core/commit/5f16e0bd57f25b4f2d5f1fce70971c4538c54b1b))


### Performance Improvements

* promise.all flag and arg caching ([c592ce0](https://github.com/oclif/core/commit/c592ce0d1de21fc8624cac0240e22dc54a3f1f20))



# [3.1.0](https://github.com/oclif/core/compare/3.0.9...3.1.0) (2023-10-13)


### Features

* add hiddenAliases property to Command ([5bf0a2e](https://github.com/oclif/core/commit/5bf0a2e5ac08bee500543a379ba68251dc850574))
* add hideAliases help option ([f1925a7](https://github.com/oclif/core/commit/f1925a7136408a328dbfcf3146f8eb1fbd8d04a9))



## [3.0.9](https://github.com/oclif/core/compare/3.0.8...3.0.9) (2023-10-12)


### Bug Fixes

* remove tslib ([#825](https://github.com/oclif/core/issues/825)) ([5964ca6](https://github.com/oclif/core/commit/5964ca69afeb382a4fc4306737115d73f543b5a6))



## [3.0.8](https://github.com/oclif/core/compare/3.0.7...3.0.8) (2023-10-12)


### Bug Fixes

* **deps:** bump semver from 5.7.1 to 5.7.2 ([#808](https://github.com/oclif/core/issues/808)) ([cffa115](https://github.com/oclif/core/commit/cffa115b4e76b87911c33ac0ef9928ffe1cb4d6c))



## [3.0.7](https://github.com/oclif/core/compare/3.0.6...3.0.7) (2023-10-12)


### Bug Fixes

* use _flags for linked v2 plugins ([#820](https://github.com/oclif/core/issues/820)) ([cc63720](https://github.com/oclif/core/commit/cc63720aa90163d28dda9b5fb258ccc0556b6931))



## [3.0.6](https://github.com/oclif/core/compare/3.0.5...3.0.6) (2023-10-11)


### Bug Fixes

* warn about ts-node and node 20 ([#818](https://github.com/oclif/core/issues/818)) ([00ed4fe](https://github.com/oclif/core/commit/00ed4fe7a8e232ff23b3d6dc33e6f02335d69ffa))



## [3.0.5](https://github.com/oclif/core/compare/3.0.5-dev.0...3.0.5) (2023-10-11)



## [3.0.5-dev.0](https://github.com/oclif/core/compare/3.0.4...3.0.5-dev.0) (2023-10-10)


### Bug Fixes

* avoid fs.access for checking for file existence ([c4277a9](https://github.com/oclif/core/commit/c4277a984223eae89dabef36e9bee2ed565f3616))



## [3.0.4](https://github.com/oclif/core/compare/3.0.3...3.0.4) (2023-10-09)


### Bug Fixes

* custom flags with union type ([#813](https://github.com/oclif/core/issues/813)) ([a4afa23](https://github.com/oclif/core/commit/a4afa23983b7c164f4bf16f340e0dc4f584e8289))



## [3.0.3](https://github.com/oclif/core/compare/3.0.2...3.0.3) (2023-10-05)


### Bug Fixes

* only Command.Loadable in Help ([#811](https://github.com/oclif/core/issues/811)) ([bf9110e](https://github.com/oclif/core/commit/bf9110ed9e98cce1a6c1757e568a35b027b0d275))



## [3.0.2](https://github.com/oclif/core/compare/3.0.1...3.0.2) (2023-10-05)


### Bug Fixes

* dont run postrun hook for uinstalled plugins ([#805](https://github.com/oclif/core/issues/805)) ([0c47a5c](https://github.com/oclif/core/commit/0c47a5c17ac9b9fbc94d67fa46effbd96d877db0))



## [3.0.1](https://github.com/oclif/core/compare/3.0.0...3.0.1) (2023-10-05)


### Bug Fixes

* add macos to plugin PJSON interface ([2919835](https://github.com/oclif/core/commit/2919835703778800f993efb83a4ac63e1edd59e7))



# [3.0.0](https://github.com/oclif/core/compare/2.15.0...3.0.0) (2023-10-04)



# [2.15.0](https://github.com/oclif/core/compare/2.14.0...2.15.0) (2023-09-01)


### Features

* add PluginLoader class ([#774](https://github.com/oclif/core/issues/774)) ([b31665d](https://github.com/oclif/core/commit/b31665d809f9cbaddcad0905bec466ebc738fb79))



# [2.14.0](https://github.com/oclif/core/compare/2.13.0...2.14.0) (2023-08-31)


### Features

* **perf:** remove semver, fs-extra ([#762](https://github.com/oclif/core/issues/762)) ([fdab7b4](https://github.com/oclif/core/commit/fdab7b4f7cc798384c0af8d2bf25e3792da7fcc3))



# [2.13.0](https://github.com/oclif/core/compare/2.12.0...2.13.0) (2023-08-29)


### Features

* forwards compatibility for config reload ([#773](https://github.com/oclif/core/issues/773)) ([b751bbe](https://github.com/oclif/core/commit/b751bbecbbd25ebe56ef12f462f4f02e626e804b))



# [2.12.0](https://github.com/oclif/core/compare/2.11.11...2.12.0) (2023-08-28)


### Features

* reload Config before running command ([#770](https://github.com/oclif/core/issues/770)) ([efd1f54](https://github.com/oclif/core/commit/efd1f546079d5d0c9abe26df372ab657cfd389b0))



## [2.11.11](https://github.com/oclif/core/compare/2.11.10...2.11.11) (2023-08-28)


### Bug Fixes

* use configured help class in --help ([#768](https://github.com/oclif/core/issues/768)) ([b6c69f1](https://github.com/oclif/core/commit/b6c69f1f4f1760aee119ae660128ac45d59c828e))



## [2.11.10](https://github.com/oclif/core/compare/2.11.9...2.11.10) (2023-08-23)


### Bug Fixes

* add getPluginsList to Config interface ([cba7a75](https://github.com/oclif/core/commit/cba7a755cf5d0ff4886edd0db33d911441979984))



## [2.11.9](https://github.com/oclif/core/compare/2.11.8...2.11.9) (2023-08-23)


### Bug Fixes

* add getPluginsList ([b01083f](https://github.com/oclif/core/commit/b01083fb7132f3b3b35b98a6d43996b1713ca5ef))



## [2.11.8](https://github.com/oclif/core/compare/2.11.7...2.11.8) (2023-08-08)


### Bug Fixes

* handle lack of bin (happens in UT when stubbing config) ([#758](https://github.com/oclif/core/issues/758)) ([11e4f73](https://github.com/oclif/core/commit/11e4f73cf855f71294e4fc70c9d580c75bcef6e3))



## [2.11.7](https://github.com/oclif/core/compare/2.11.6...2.11.7) (2023-08-03)


### Bug Fixes

* allow CONTENT_TYPE env to work for all oclif cmds ([71db0dc](https://github.com/oclif/core/commit/71db0dc63ad5d4a43df72ac4a040df2d92d3b0e1))



## [2.11.6](https://github.com/oclif/core/compare/2.11.5...2.11.6) (2023-08-02)


### Bug Fixes

* add note to RequiredArgsError when there are flags with multiple=true ([#754](https://github.com/oclif/core/issues/754)) ([ed359a7](https://github.com/oclif/core/commit/ed359a72012b387c3d106be443be601f51a49225))



## [2.11.5](https://github.com/oclif/core/compare/2.11.4...2.11.5) (2023-07-31)


### Bug Fixes

* set moduleResolution to Node16 ([#750](https://github.com/oclif/core/issues/750)) ([d7fdda8](https://github.com/oclif/core/commit/d7fdda8d23a20892d36ada847cfdc24ae76ca4b1))



## [2.11.4](https://github.com/oclif/core/compare/2.11.3...2.11.4) (2023-07-31)


### Bug Fixes

* add missing properties to Interfaces.PJSON ([9b607f8](https://github.com/oclif/core/commit/9b607f881a78febc849e7307b9b896ee20abaf0e))



## [2.11.3](https://github.com/oclif/core/compare/2.11.2...2.11.3) (2023-07-31)


### Bug Fixes

* node 14 stdin logic ([9c88715](https://github.com/oclif/core/commit/9c88715454e061cf4c10aab00c22bd52957a9e4c))



## [2.11.2](https://github.com/oclif/core/compare/2.11.1...2.11.2) (2023-07-31)


### Bug Fixes

* node 14 stdin logic ([dfdea4e](https://github.com/oclif/core/commit/dfdea4ec237d847b3efdcd133c18f6ec0d5ee10b))



## [2.11.1](https://github.com/oclif/core/compare/2.11.0...2.11.1) (2023-07-28)


### Bug Fixes

* fall back to scopedEnvVarKey if scopedEnvVarKeys is not defined ([#752](https://github.com/oclif/core/issues/752)) ([cc63a56](https://github.com/oclif/core/commit/cc63a56766118237e26cab54ea806625cf0bd73c))



# [2.11.0](https://github.com/oclif/core/compare/2.10.1...2.11.0) (2023-07-28)


### Features

* deprecate scopedEnvVarKey for scopedEnvVarKeys which accounts for binAliases ([#751](https://github.com/oclif/core/issues/751)) ([4787248](https://github.com/oclif/core/commit/4787248655c39aaebb83eccd02bba3109921ccf7))



## [2.10.1](https://github.com/oclif/core/compare/2.10.0...2.10.1) (2023-07-28)


### Bug Fixes

* support node 14 again ([#741](https://github.com/oclif/core/issues/741)) ([a80c4fd](https://github.com/oclif/core/commit/a80c4fd74c7c5dc7b8426e6f78fc60689c82eab7))



# [2.10.0](https://github.com/oclif/core/compare/2.9.5...2.10.0) (2023-07-25)


### Features

* add extensions to esm checking ([#694](https://github.com/oclif/core/issues/694)) ([#743](https://github.com/oclif/core/issues/743)) ([427aa5b](https://github.com/oclif/core/commit/427aa5b877047bcd248bf1dbe0969c9bb0457e36))



## [2.9.5](https://github.com/oclif/core/compare/2.9.4...2.9.5) (2023-07-25)


### Bug Fixes

* corrected return type for Command.exit ([#715](https://github.com/oclif/core/issues/715)) ([#742](https://github.com/oclif/core/issues/742)) ([dd753f0](https://github.com/oclif/core/commit/dd753f045cde58d89b209e007926d4131f925570))



## [2.9.4](https://github.com/oclif/core/compare/2.9.3...2.9.4) (2023-07-18)


### Bug Fixes

* correctly print help when only command found and passed with help ([#733](https://github.com/oclif/core/issues/733)) ([3c3b597](https://github.com/oclif/core/commit/3c3b5973903b401dbd00a4005cb9d9d289289f76))



## [2.9.3](https://github.com/oclif/core/compare/2.9.2...2.9.3) (2023-07-13)



## [2.9.2](https://github.com/oclif/core/compare/2.9.1...2.9.2) (2023-07-13)


### Bug Fixes

* **parser:** don't throw if defaultHelp func throws ([#732](https://github.com/oclif/core/issues/732)) ([7003b40](https://github.com/oclif/core/commit/7003b403a3cb9f6fe54a87de843dbc058f96be6c))



## [2.9.1](https://github.com/oclif/core/compare/2.9.0...2.9.1) (2023-07-12)


### Bug Fixes

* flags omit undefined for boolean flags ([0a7e154](https://github.com/oclif/core/commit/0a7e15415f3514a4baad064478c76f0c17e9548a))



# [2.9.0](https://github.com/oclif/core/compare/2.8.12...2.9.0) (2023-07-11)


### Features

* perf benchmarks ([9734b9f](https://github.com/oclif/core/commit/9734b9f9bce5ededc92c52c4eb14663a9e998893))



## [2.8.12](https://github.com/oclif/core/compare/2.8.11...2.8.12) (2023-07-10)


### Bug Fixes

* properly truncate table cells that contain fullwidth characters or ANSI escape sequences ([db51bf2](https://github.com/oclif/core/commit/db51bf216b4b37d6c6e1d054e64b38dff0856d6d))



## [2.8.11](https://github.com/oclif/core/compare/2.8.10...2.8.11) (2023-07-01)


### Bug Fixes

* **deps:** bump semver and @types/semver ([fe9f09f](https://github.com/oclif/core/commit/fe9f09f9e9ac301ea25116deca42d394b46f6f3e))



## [2.8.10](https://github.com/oclif/core/compare/2.8.9...2.8.10) (2023-06-27)



## [2.8.9](https://github.com/oclif/core/compare/2.8.8...2.8.9) (2023-06-27)


### Bug Fixes

* revert flag validation problem ([11cbfd4](https://github.com/oclif/core/commit/11cbfd46f6f201a064205f5bb352bbd40efb150d))



## [2.8.8](https://github.com/oclif/core/compare/2.8.7...2.8.8) (2023-06-26)


### Bug Fixes

* improve flag validation ([ca9fe38](https://github.com/oclif/core/commit/ca9fe38c0531a4058483b5baf4b44946235e9ae0))



## [2.8.7](https://github.com/oclif/core/compare/2.8.6...2.8.7) (2023-06-15)


### Bug Fixes

* correctly load legacy plugins ([ec221d3](https://github.com/oclif/core/commit/ec221d30118f6c9d9b191aec4b25e648e4bb46f6))



## [2.8.6](https://github.com/oclif/core/compare/2.8.5...2.8.6) (2023-06-13)


### Bug Fixes

* don't override noTTYOutput ([809b9c0](https://github.com/oclif/core/commit/809b9c00244343a24b71be5eaefba0775bb270b5))



## [2.8.5](https://github.com/oclif/core/compare/2.8.4...2.8.5) (2023-05-03)


### Bug Fixes

* pass flag to default function ([#691](https://github.com/oclif/core/issues/691)) ([1cb7f26](https://github.com/oclif/core/commit/1cb7f26500b98080f35b8f914fef8441c6b07dbd))



## [2.8.4](https://github.com/oclif/core/compare/2.8.3...2.8.4) (2023-05-01)


### Bug Fixes

* expose nsisCustomization property on Config ([f0210cc](https://github.com/oclif/core/commit/f0210cccf4be171dedf1ac3ad7c54668df558865))



## [2.8.3](https://github.com/oclif/core/compare/2.8.2...2.8.3) (2023-05-01)


### Bug Fixes

* add nsisCustomization entry ([#695](https://github.com/oclif/core/issues/695)) ([a749c3b](https://github.com/oclif/core/commit/a749c3b2d23fa427431a5a20d82e3ada6a29b80d))



## [2.8.2](https://github.com/oclif/core/compare/2.8.1...2.8.2) (2023-04-12)


### Bug Fixes

*  jsonEnabled not handling after pass-through ([#687](https://github.com/oclif/core/issues/687)) ([5c7e534](https://github.com/oclif/core/commit/5c7e534229197d32ffc605f19394300c6ebdf8ac))



## [2.8.1](https://github.com/oclif/core/compare/2.8.0...2.8.1) (2023-04-11)


### Bug Fixes

* default help behaves properly ([#678](https://github.com/oclif/core/issues/678)) ([8562e13](https://github.com/oclif/core/commit/8562e13f76b8d8fee0ee7ef2ddfdba98a831e3e7))
* default help behaves properly ([#678](https://github.com/oclif/core/issues/678)) ([1d86cb0](https://github.com/oclif/core/commit/1d86cb0f3edcaa7f7bf09c779d7a307c320dcff2))



# [2.8.0](https://github.com/oclif/core/compare/2.7.1...2.8.0) (2023-03-28)


### Features

* feat: add new param isWritingManifest to Plugin.load ([#675](https://github.com/oclif/core/issues/675)) ([c452981](https://github.com/oclif/core/commit/c45298132860f83b4894d9db51e3e6f76d80d8f5))



## [2.7.1](https://github.com/oclif/core/compare/2.7.0...2.7.1) (2023-03-22)


### Reverts

* Revert "feat: add param noSensitiveData to Plugin.load (#665)" (#670) ([bdcbc87](https://github.com/oclif/core/commit/bdcbc8735c1c585029217215679da34608780f08)), closes [#665](https://github.com/oclif/core/issues/665) [#670](https://github.com/oclif/core/issues/670)



# [2.7.0](https://github.com/oclif/core/compare/2.6.5...2.7.0) (2023-03-22)


### Features

* add param noSensitiveData to Plugin.load ([#665](https://github.com/oclif/core/issues/665)) ([b4a738e](https://github.com/oclif/core/commit/b4a738e40735c40dbf633546011c4a860ebff46c))



## [2.6.5](https://github.com/oclif/core/compare/2.6.4...2.6.5) (2023-03-21)


### Bug Fixes

* add flag name and short char to deprecation message ([#664](https://github.com/oclif/core/issues/664)) ([79c41ca](https://github.com/oclif/core/commit/79c41cafe58a27f22b6f7c88e1126c5fd06cb7bb))



## [2.6.4](https://github.com/oclif/core/compare/2.6.3...2.6.4) (2023-03-16)


### Bug Fixes

* pass plugin type when resolving a module path ([#659](https://github.com/oclif/core/issues/659)) ([d5f58a3](https://github.com/oclif/core/commit/d5f58a342d27e381e45fbaa86fdd7983d531f197))



## [2.6.3](https://github.com/oclif/core/compare/2.6.2...2.6.3) (2023-03-13)


### Bug Fixes

* handle undefined env.SHELL ([#657](https://github.com/oclif/core/issues/657)) ([71fc49f](https://github.com/oclif/core/commit/71fc49fb84c217ced89c12e5ad86671c49e4c1aa))



## [2.6.2](https://github.com/oclif/core/compare/2.6.1...2.6.2) (2023-03-09)


### Bug Fixes

* add version details property to config interface ([#652](https://github.com/oclif/core/issues/652)) ([378095d](https://github.com/oclif/core/commit/378095d64413a673fc3d77598a46e4f14551dc16))



## [2.6.1](https://github.com/oclif/core/compare/2.6.0...2.6.1) (2023-03-09)


### Bug Fixes

* improve Performance class ([b263fc3](https://github.com/oclif/core/commit/b263fc38fccbf100a5fdf876f84eeb01afb7501a))



# [2.6.0](https://github.com/oclif/core/compare/2.5.2...2.6.0) (2023-03-09)


### Features

* add Config.versionDetails ([#651](https://github.com/oclif/core/issues/651)) ([ddddcd9](https://github.com/oclif/core/commit/ddddcd97913822dc3774b5b6250b7a0dbcfd4111))



## [2.5.2](https://github.com/oclif/core/compare/2.5.1...2.5.2) (2023-03-08)



## [2.5.1](https://github.com/oclif/core/compare/2.5.0...2.5.1) (2023-03-07)


### Bug Fixes

* stop any unstopped markers when collecting perf results ([#649](https://github.com/oclif/core/issues/649)) ([f8ab63e](https://github.com/oclif/core/commit/f8ab63e7b0efbda7454bb34e7ab5471f50cec6cf))



# [2.5.0](https://github.com/oclif/core/compare/2.4.0...2.5.0) (2023-03-06)


### Features

* add Performance class ([#641](https://github.com/oclif/core/issues/641)) ([c808189](https://github.com/oclif/core/commit/c8081890bcd73b382ba2eb03ae13ad6cfd6b1f17))



# [2.4.0](https://github.com/oclif/core/compare/2.3.2...2.4.0) (2023-02-28)


### Features

* add option to skip oclif error printing ([#642](https://github.com/oclif/core/issues/642)) ([ca88895](https://github.com/oclif/core/commit/ca88895bcfdca2d1c1ae5eda6e879ae6b1ac4122))



## [2.3.2](https://github.com/oclif/core/compare/2.3.1...2.3.2) (2023-02-28)


### Bug Fixes

* change useable ids to set to improve search perf ([#640](https://github.com/oclif/core/issues/640)) ([a0996a4](https://github.com/oclif/core/commit/a0996a4b3b5b1d69f2bb343c1c1ed2eef9e298b4))



## [2.3.1](https://github.com/oclif/core/compare/2.3.0...2.3.1) (2023-02-25)


### Bug Fixes

* **deps:** bump cli-progress from 3.11.2 to 3.12.0 ([f59977b](https://github.com/oclif/core/commit/f59977b4c5cf2281e71b0706aadda8403dabf0ce))



# [2.3.0](https://github.com/oclif/core/compare/2.2.1...2.3.0) (2023-02-21)


### Features

* add binAliases property to Config ([#632](https://github.com/oclif/core/issues/632)) ([9384f6e](https://github.com/oclif/core/commit/9384f6e6969765b45e5e2ed61dc45cf341af6182))



## [2.2.1](https://github.com/oclif/core/compare/2.2.0...2.2.1) (2023-02-20)


### Bug Fixes

* logToStderr actually logs to stderr ([efe2c50](https://github.com/oclif/core/commit/efe2c50524f653b99a7369ae2fc7b98993f008e3))



# [2.2.0](https://github.com/oclif/core/compare/2.1.7...2.2.0) (2023-02-20)


### Features

* wrap stdout and stderr ([#629](https://github.com/oclif/core/issues/629)) ([39ea8ea](https://github.com/oclif/core/commit/39ea8ea0a9fce781da9f0a51c9487de1603375b8))



## [2.1.7](https://github.com/oclif/core/compare/2.1.6...2.1.7) (2023-02-18)


### Bug Fixes

* **deps:** bump ejs and @types/ejs ([9192de0](https://github.com/oclif/core/commit/9192de0f43106c18eaf58c53152724f79b194f5a))



## [2.1.6](https://github.com/oclif/core/compare/2.1.5...2.1.6) (2023-02-17)


### Bug Fixes

* set prioritized command to alias ([#633](https://github.com/oclif/core/issues/633)) ([7d30350](https://github.com/oclif/core/commit/7d30350a2f68bf51772d1fe46e799c36258b3c30))



## [2.1.5](https://github.com/oclif/core/compare/2.1.4...2.1.5) (2023-02-16)


### Bug Fixes

* support legacy plugins ([#631](https://github.com/oclif/core/issues/631)) ([aff9e56](https://github.com/oclif/core/commit/aff9e562ca757e01ccc6589d200dcb1661b42486))



## [2.1.4](https://github.com/oclif/core/compare/2.1.3...2.1.4) (2023-02-13)


### Bug Fixes

* pass command instance to parse context ([#628](https://github.com/oclif/core/issues/628)) ([5641de5](https://github.com/oclif/core/commit/5641de51f9598e96cc1b3ca7794f9ca12eff3f04))



## [2.1.3](https://github.com/oclif/core/compare/2.1.2...2.1.3) (2023-02-13)


### Bug Fixes

* remove brackets for required args ([#619](https://github.com/oclif/core/issues/619)) ([d461fbf](https://github.com/oclif/core/commit/d461fbf751ad9492d4fffe00c8d301040a32318f))



## [2.1.2](https://github.com/oclif/core/compare/2.1.1...2.1.2) (2023-02-11)


### Bug Fixes

* **deps:** bump cli-progress from 3.10.0 to 3.11.2 ([4d15304](https://github.com/oclif/core/commit/4d1530424ce650286cf61c3836aa587d27f2a932))



## [2.1.1](https://github.com/oclif/core/compare/2.1.0...2.1.1) (2023-02-10)


### Bug Fixes

* config runHook interface ([#620](https://github.com/oclif/core/issues/620)) ([7180b4c](https://github.com/oclif/core/commit/7180b4cac824c3a1acadabe48c2bd1faeadeb7dd))



# [2.1.0](https://github.com/oclif/core/compare/2.0.11...2.1.0) (2023-02-10)


### Features

* add param to runHook to capture errors ([#617](https://github.com/oclif/core/issues/617)) ([7e7ca96](https://github.com/oclif/core/commit/7e7ca96259674b88cc7d5ff583182b5c1cad488a))



## [2.0.11](https://github.com/oclif/core/compare/2.0.10...2.0.11) (2023-02-08)


### Bug Fixes

* **deps:** bump tslib from 2.4.1 to 2.5.0 ([8924024](https://github.com/oclif/core/commit/89240244d079cb9800e155fe8feaf4d643c1f446))



## [2.0.10](https://github.com/oclif/core/compare/2.0.9...2.0.10) (2023-02-07)


### Bug Fixes

* handling quoted strings and options validation for comma-delimited multiple-flag ([#614](https://github.com/oclif/core/issues/614)) ([c32ab9d](https://github.com/oclif/core/commit/c32ab9ddd5b866bc9493b2dbe1f9dfc30492631f))



## [2.0.9](https://github.com/oclif/core/compare/2.0.8...2.0.9) (2023-02-06)


### Bug Fixes

* update Manifest type ([32716f5](https://github.com/oclif/core/commit/32716f562c21adc5a023628e43143c47a41c326e))



## [2.0.8](https://github.com/oclif/core/compare/2.0.7...2.0.8) (2023-01-31)


### Bug Fixes

* ignore hasDynamicHelp if JIT plugin ([#607](https://github.com/oclif/core/issues/607)) ([d280fa5](https://github.com/oclif/core/commit/d280fa5f1b392aba938db79de70523774e0c6440))



## [2.0.7](https://github.com/oclif/core/compare/2.0.6...2.0.7) (2023-01-26)


### Bug Fixes

* provide more context to flag and arg parsers ([cb29ca7](https://github.com/oclif/core/commit/cb29ca732928df8e4897e240380c9fa1d632758d))



## [2.0.6](https://github.com/oclif/core/compare/2.0.5...2.0.6) (2023-01-25)


### Bug Fixes

* flag type regressions ([57c755b](https://github.com/oclif/core/commit/57c755bb395d50aae8b513c277e181865a32df5c))



## [2.0.5](https://github.com/oclif/core/compare/2.0.4...2.0.5) (2023-01-25)


### Bug Fixes

* failed flag parsing error ([d3e975f](https://github.com/oclif/core/commit/d3e975f500f152f055f1e04855bb4485df687916))



## [2.0.4](https://github.com/oclif/core/compare/2.0.3...2.0.4) (2023-01-25)


### Bug Fixes

* allow negative num args ([#601](https://github.com/oclif/core/issues/601)) ([0540835](https://github.com/oclif/core/commit/05408357b149454ec127bc83d1b1502048c04500))



## [2.0.3](https://github.com/oclif/core/compare/1.26.0...2.0.3) (2023-01-23)


### Bug Fixes

* release v2 as latest ([5a9cb16](https://github.com/oclif/core/commit/5a9cb166c4a53961a66eb1e173a73cbad5f4b3e0))



# [1.26.0](https://github.com/oclif/core/compare/1.25.0...1.26.0) (2023-01-23)


### Features

* specify flag name in parse error message ([#589](https://github.com/oclif/core/issues/589)) ([#598](https://github.com/oclif/core/issues/598)) ([70dd894](https://github.com/oclif/core/commit/70dd89492c38c73771ef9c8498faf6e6da850cf1))



# [1.25.0](https://github.com/oclif/core/compare/1.24.3...1.25.0) (2023-01-19)


### Features

* support JIT plugin installation ([#533](https://github.com/oclif/core/issues/533)) ([d1abfbc](https://github.com/oclif/core/commit/d1abfbc40067f1b26f35b167cd33f3666ef69d9f))



## [1.24.3](https://github.com/oclif/core/compare/1.24.2...1.24.3) (2023-01-19)


### Bug Fixes

* support v2 style argument definitions ([#594](https://github.com/oclif/core/issues/594)) ([bba8f65](https://github.com/oclif/core/commit/bba8f65e2b6f7c8c5f1e53510865842773c46111))



## [1.24.2](https://github.com/oclif/core/compare/1.24.1...1.24.2) (2023-01-18)


### Bug Fixes

* forwards compatiblity ([3aea844](https://github.com/oclif/core/commit/3aea84417a5240249aaa0ec00b6e43744ae6d9c6))



## [1.24.1](https://github.com/oclif/core/compare/1.24.0...1.24.1) (2023-01-18)


### Bug Fixes

* allow deprecation.version to be number ([ef4ef9d](https://github.com/oclif/core/commit/ef4ef9dba5a9fab21b711fb71521b3acd0703c4e))



# [1.24.0](https://github.com/oclif/core/compare/1.23.2...1.24.0) (2023-01-11)


### Features

* add forwards compatibility for v2 args ([#587](https://github.com/oclif/core/issues/587)) ([9bc4a92](https://github.com/oclif/core/commit/9bc4a92bf4be90499ee0aa9cba74c8de54dd1b4b))



## [1.23.2](https://github.com/oclif/core/compare/1.23.1...1.23.2) (2023-01-08)


### Bug Fixes

* **deps:** bump @oclif/screen from 3.0.3 to 3.0.4 ([17abee3](https://github.com/oclif/core/commit/17abee3b9f2467b2e36244cfb05716b91434ce88))



## [1.23.1](https://github.com/oclif/core/compare/1.23.0...1.23.1) (2022-12-31)


### Bug Fixes

* **deps:** bump json5 from 2.2.0 to 2.2.2 ([406cf04](https://github.com/oclif/core/commit/406cf046f3dc2d197bc649cb09a479e85f17ad17))



# [1.23.0](https://github.com/oclif/core/compare/1.22.0...1.23.0) (2022-12-27)


### Features

* allow flags to have false value in when ([#557](https://github.com/oclif/core/issues/557)) ([c40ce71](https://github.com/oclif/core/commit/c40ce711471ec596d417bd1c146682cde1dfbf6f))



# [1.22.0](https://github.com/oclif/core/compare/1.21.0...1.22.0) (2022-12-16)


### Features

* pjson interface has devDependencies ([#574](https://github.com/oclif/core/issues/574)) ([4378886](https://github.com/oclif/core/commit/437888610b7bf2e4469d0a09d9bc0713dcec3fc5))



# [1.21.0](https://github.com/oclif/core/compare/1.20.4...1.21.0) (2022-12-06)


### Features

* handle custom parser nested array for multiple flag ([#568](https://github.com/oclif/core/issues/568)) ([046445c](https://github.com/oclif/core/commit/046445c463c28aaae84f2b0c2f0381b718ebaba7))



## [1.20.4](https://github.com/oclif/core/compare/1.20.3...1.20.4) (2022-11-06)


### Bug Fixes

* **deps:** bump tslib from 2.3.1 to 2.4.1 ([e2d4cd3](https://github.com/oclif/core/commit/e2d4cd3120639e6db66a3062039bee9149d8aa27))



## [1.20.3](https://github.com/oclif/core/compare/1.20.2...1.20.3) (2022-11-05)


### Bug Fixes

* **deps:** bump @oclif/screen from 3.0.2 to 3.0.3 ([154ed80](https://github.com/oclif/core/commit/154ed806bf7635d641e2b28f950be3c3f426f1e5))



## [1.20.2](https://github.com/oclif/core/compare/1.20.1...1.20.2) (2022-10-31)


### Bug Fixes

* **table:** use screen from @oclif/core ([#546](https://github.com/oclif/core/issues/546)) ([be3bea7](https://github.com/oclif/core/commit/be3bea7a19ba19793370ab83680361d5ae693d90))



## [1.20.1](https://github.com/oclif/core/compare/1.20.0...1.20.1) (2022-10-31)


### Bug Fixes

* OclifUX.ux.prompt() return type ([#538](https://github.com/oclif/core/issues/538)) ([1599edb](https://github.com/oclif/core/commit/1599edbe889a5fc213b9ae65f69e54fb17d796fc))



# [1.20.0](https://github.com/oclif/core/compare/1.19.2...1.20.0) (2022-10-28)


### Features

* warn about alias deprecations ([#540](https://github.com/oclif/core/issues/540)) ([aed5db3](https://github.com/oclif/core/commit/aed5db37efeb121dd4a0b0198adc9c23771feadf))



## [1.19.2](https://github.com/oclif/core/compare/1.19.1...1.19.2) (2022-10-25)


### Bug Fixes

* add missing prop to cached command ([#537](https://github.com/oclif/core/issues/537)) ([00b086c](https://github.com/oclif/core/commit/00b086ced707cf55ed40c387dc0a45f06fc68e46))



## [1.19.1](https://github.com/oclif/core/compare/1.19.0...1.19.1) (2022-10-19)


### Bug Fixes

* help flag ([#532](https://github.com/oclif/core/issues/532)) ([31d7045](https://github.com/oclif/core/commit/31d7045a50c058608c5dc92e1516eddbad383a3a))



# [1.19.0](https://github.com/oclif/core/compare/1.18.0...1.19.0) (2022-10-17)


### Features

* make flag deprecation warnings less noisy ([#527](https://github.com/oclif/core/issues/527)) ([a5fb337](https://github.com/oclif/core/commit/a5fb337b5e2ef32c03228535c8ec661e5cd6f96a))



# [1.18.0](https://github.com/oclif/core/compare/1.17.0...1.18.0) (2022-10-14)


### Features

* support flag and command deprecations ([#511](https://github.com/oclif/core/issues/511)) ([b0bf379](https://github.com/oclif/core/commit/b0bf379b5e8a681e9161d9492dae7b714ee48e88))



# [1.17.0](https://github.com/oclif/core/compare/1.16.7...1.17.0) (2022-10-14)


### Features

* support flag aliases ([#521](https://github.com/oclif/core/issues/521)) ([63f3e0e](https://github.com/oclif/core/commit/63f3e0ea14c360d977d1821e7ecd90642aeb1734))



## [1.16.7](https://github.com/oclif/core/compare/1.16.6...1.16.7) (2022-10-13)


### Bug Fixes

* **deps:** bump minimist from 1.2.5 to 1.2.7 ([3c987c2](https://github.com/oclif/core/commit/3c987c2866fd2716abb2aa5e4c0c0974caac9f61))



## [1.16.6](https://github.com/oclif/core/compare/1.16.5...1.16.6) (2022-10-12)


### Bug Fixes

* stop inserting extra line breaks in description ([#519](https://github.com/oclif/core/issues/519)) ([76aee62](https://github.com/oclif/core/commit/76aee62d32017d4455e477e0bf7cc26f4b0e03c3))



## [1.16.5](https://github.com/oclif/core/compare/v1.16.4...1.16.5) (2022-10-07)



## [1.16.4](https://github.com/oclif/core/compare/v1.16.3...v1.16.4) (2022-09-23)


### Bug Fixes

* work with 4.8.3 ([#493](https://github.com/oclif/core/issues/493)) ([2f09a72](https://github.com/oclif/core/commit/2f09a725bb7ff7ef8b4f4d6d6f67d0d83a1ed1f8))



## [1.16.3](https://github.com/oclif/core/compare/v1.16.2...v1.16.3) (2022-09-16)



## [1.16.2](https://github.com/oclif/core/compare/v1.16.1...v1.16.2) (2022-09-16)


### Bug Fixes

* throw if unexpected argument ([#491](https://github.com/oclif/core/issues/491)) ([da6d20c](https://github.com/oclif/core/commit/da6d20c388e48f65560822cee141d4f2fc5955a5))



## [1.16.1](https://github.com/oclif/core/compare/v1.16.0...v1.16.1) (2022-09-08)


### Bug Fixes

* support environment variables for boolean flags ([#488](https://github.com/oclif/core/issues/488)) ([#490](https://github.com/oclif/core/issues/490)) ([506945c](https://github.com/oclif/core/commit/506945c6ea2f8b75f0d56ad1f6e62a3717384a42)), closes [#487](https://github.com/oclif/core/issues/487)



# [1.16.0](https://github.com/oclif/core/compare/v1.15.0...v1.16.0) (2022-08-24)


### Features

* support complex flag relationships ([#468](https://github.com/oclif/core/issues/468)) ([222d1f6](https://github.com/oclif/core/commit/222d1f67012557ac0707077d6c8840966dbf00cb))



# [1.15.0](https://github.com/oclif/core/compare/v1.14.2...v1.15.0) (2022-08-23)


### Features

* add InferredFlags type ([#473](https://github.com/oclif/core/issues/473)) ([ee5ce65](https://github.com/oclif/core/commit/ee5ce651899c0ef586d425567ef3b78468dca627))



## [1.14.2](https://github.com/oclif/core/compare/v1.14.1...v1.14.2) (2022-08-18)


### Bug Fixes

* add overloads to enum flag ([799455b](https://github.com/oclif/core/commit/799455bbb526b221c806bf8feff6b625dcf50a56))



## [1.14.1](https://github.com/oclif/core/compare/v1.14.0...v1.14.1) (2022-08-16)


### Bug Fixes

* parser doesn't validate against options parameter if the value is provided through a env var ([#474](https://github.com/oclif/core/issues/474)) ([fe6dfea](https://github.com/oclif/core/commit/fe6dfea0bcc5cae69c91962430996670decf7887))



# [1.14.0](https://github.com/oclif/core/compare/v1.13.11...v1.14.0) (2022-08-16)


### Features

* all oclif flag types support custom parsers ([ad86faf](https://github.com/oclif/core/commit/ad86faf08f7a6d7984afe356819df458aaf04674))



## [1.13.11](https://github.com/oclif/core/compare/v1.13.10...v1.13.11) (2022-08-16)


### Bug Fixes

* more custom flag type overloads ([#471](https://github.com/oclif/core/issues/471)) ([ac4baf2](https://github.com/oclif/core/commit/ac4baf260f8e87bb5618c7b790f35372d55096c7))



## [1.13.10](https://github.com/oclif/core/compare/v1.13.9...v1.13.10) (2022-08-09)



## [1.13.9](https://github.com/oclif/core/compare/v1.13.8...v1.13.9) (2022-08-09)


### Bug Fixes

* remove json flag if subclass overrides enableJsonFlag ([#467](https://github.com/oclif/core/issues/467)) ([05dd12a](https://github.com/oclif/core/commit/05dd12ad114f37d0512df2d89a8e51d0984fa3d4))



## [1.13.8](https://github.com/oclif/core/compare/v1.13.7...v1.13.8) (2022-08-09)


### Bug Fixes

* revert [#460](https://github.com/oclif/core/issues/460) ([#466](https://github.com/oclif/core/issues/466)) ([4c28acf](https://github.com/oclif/core/commit/4c28acfc2131eadbac423fa722b8cc0dc16a1b5b))



## [1.13.7](https://github.com/oclif/core/compare/v1.13.6...v1.13.7) (2022-08-08)


### Bug Fixes

* types on custom flags ([#463](https://github.com/oclif/core/issues/463)) ([2728e23](https://github.com/oclif/core/commit/2728e2310406137e0356d039a90d321daafd6578))



## [1.13.6](https://github.com/oclif/core/compare/v1.13.5...v1.13.6) (2022-08-08)


### Bug Fixes

* flush not hitting drain condition ([#448](https://github.com/oclif/core/issues/448)) ([05dd5fe](https://github.com/oclif/core/commit/05dd5fe08b57aa716c07cc51e8ed407c9e7b6aa5))



## [1.13.5](https://github.com/oclif/core/compare/v1.13.4...v1.13.5) (2022-08-08)


### Bug Fixes

* skip loadDevPlugins ([#459](https://github.com/oclif/core/issues/459)) ([21c948c](https://github.com/oclif/core/commit/21c948cd41b08b3aad4df5c3439d33e235f6979e))



## [1.13.4](https://github.com/oclif/core/compare/v1.13.3...v1.13.4) (2022-08-08)


### Bug Fixes

* retain enable json flag get/set apply flag at parse ([#460](https://github.com/oclif/core/issues/460)) ([9812937](https://github.com/oclif/core/commit/9812937e43a573cf4a10d4b03fca47555de5a1d9))



## [1.13.3](https://github.com/oclif/core/compare/v1.13.2...v1.13.3) (2022-08-06)


### Bug Fixes

* improve flag types ([6d0b4e1](https://github.com/oclif/core/commit/6d0b4e1f1761baba0e085ea8d342a7bc913e7e5d))



## [1.13.2](https://github.com/oclif/core/compare/v1.13.1...v1.13.2) (2022-08-05)


### Bug Fixes

* flag types ([#454](https://github.com/oclif/core/issues/454)) ([2938ba4](https://github.com/oclif/core/commit/2938ba4082d1b0c603a55678fe47f5beed9acbb5))



## [1.13.1](https://github.com/oclif/core/compare/v1.13.0...v1.13.1) (2022-08-02)


### Bug Fixes

* throw appropriate error in runCommand ([#455](https://github.com/oclif/core/issues/455)) ([66e9bbc](https://github.com/oclif/core/commit/66e9bbca08f9e1f4a08e1c8c144bf85c274b7f82))



# [1.13.0](https://github.com/oclif/core/compare/v1.12.1...v1.13.0) (2022-07-28)


### Features

* drop node12, use es2020 ([ac749e3](https://github.com/oclif/core/commit/ac749e32917400386f0ee4056aa5b66a52f3d0e0))
* min/max for integer flag ([7e05ef7](https://github.com/oclif/core/commit/7e05ef7195269012055f30095552e61359fad47e))
* node14/es2020 for bigint, pr feedback ([03a50b8](https://github.com/oclif/core/commit/03a50b874a8e7ef621c23d846e63864e3850ee4a))



## [1.12.1](https://github.com/oclif/core/compare/v1.12.0...v1.12.1) (2022-07-21)


### Bug Fixes

* flag setter order ([#450](https://github.com/oclif/core/issues/450)) ([a02f86c](https://github.com/oclif/core/commit/a02f86cb1094a86ba0cd8689fd82908ff3d46386))



# [1.12.0](https://github.com/oclif/core/compare/v1.11.0...v1.12.0) (2022-07-20)


### Features

* improve the instantiation of global flags ([#445](https://github.com/oclif/core/issues/445)) ([d264535](https://github.com/oclif/core/commit/d2645358ccf1cddd0bb65d236e73ecf4c5ac7c0c))



# [1.11.0](https://github.com/oclif/core/compare/v1.10.0...v1.11.0) (2022-07-18)


### Features

* print error info when module not found ([#427](https://github.com/oclif/core/issues/427)) ([223e79b](https://github.com/oclif/core/commit/223e79b363ad01da327e264244daf23810849d70))



# [1.10.0](https://github.com/oclif/core/compare/v1.9.10...v1.10.0) (2022-07-15)


### Features

* add stderr method ([#441](https://github.com/oclif/core/issues/441)) ([d9490f7](https://github.com/oclif/core/commit/d9490f77ff4cac0ee9767f1386f18c7357e0666e))



## [1.9.10](https://github.com/oclif/core/compare/v1.9.9...v1.9.10) (2022-07-15)



## [1.9.9](https://github.com/oclif/core/compare/v1.9.8...v1.9.9) (2022-07-14)


### Bug Fixes

* help for single command CLIs ([#442](https://github.com/oclif/core/issues/442)) ([44aacc1](https://github.com/oclif/core/commit/44aacc12fbc68f9909796c4ad2a1c9d45f47e653))



## [1.9.8](https://github.com/oclif/core/compare/v1.9.7...v1.9.8) (2022-07-14)



## [1.9.7](https://github.com/oclif/core/compare/v1.9.6...v1.9.7) (2022-07-14)


### Bug Fixes

* can not find module 'cli-ux' ([#403](https://github.com/oclif/core/issues/403)) ([f16b67f](https://github.com/oclif/core/commit/f16b67f8b6cd3eaaf24c26d4e7c4d490c0937ff3))



## [1.9.6](https://github.com/oclif/core/compare/v1.9.5...v1.9.6) (2022-07-14)



## [1.9.5](https://github.com/oclif/core/compare/v1.9.4...v1.9.5) (2022-06-23)



## [1.9.4](https://github.com/oclif/core/compare/v1.9.3...v1.9.4) (2022-06-23)



## [1.9.3](https://github.com/oclif/core/compare/v1.9.2...v1.9.3) (2022-06-16)



## [1.9.2](https://github.com/oclif/core/compare/v1.9.1...v1.9.2) (2022-06-14)



## [1.9.1](https://github.com/oclif/core/compare/v1.9.0...v1.9.1) (2022-06-14)


### Bug Fixes

* support CLIs with single top level command ([#426](https://github.com/oclif/core/issues/426)) ([44adb4d](https://github.com/oclif/core/commit/44adb4d387695548a017b38249b0bc3453aedbdf))



# [1.9.0](https://github.com/oclif/core/compare/v1.8.2...v1.9.0) (2022-05-20)


### Features

* support TS directory imports for ESM ([#422](https://github.com/oclif/core/issues/422)) ([4c58e78](https://github.com/oclif/core/commit/4c58e782e86dd7ecf91294bac0d2c759b4454596))



## [1.8.2](https://github.com/oclif/core/compare/v1.8.1...v1.8.2) (2022-05-18)


### Bug Fixes

* properly load index.js ES modules (cont) ([#417](https://github.com/oclif/core/issues/417)) ([77ba8b8](https://github.com/oclif/core/commit/77ba8b891f941e371bacd0dbedb32be25d6d2599))



## [1.8.1](https://github.com/oclif/core/compare/v1.8.0...v1.8.1) (2022-05-10)


### Bug Fixes

* improve algo for collating command id ([#415](https://github.com/oclif/core/issues/415)) ([1a9bfdb](https://github.com/oclif/core/commit/1a9bfdb810e13506ed8fc4138cde1912981b97e3))



# [1.8.0](https://github.com/oclif/core/compare/v1.7.0...v1.8.0) (2022-05-06)


### Features

* improve Command interface ([#416](https://github.com/oclif/core/issues/416)) ([ed625e1](https://github.com/oclif/core/commit/ed625e1554a09e578e645ddd7aa2ddb1b368c03f))



# [1.7.0](https://github.com/oclif/core/compare/v1.6.4...v1.7.0) (2022-04-11)


### Features

* move console.log to single class method ([#400](https://github.com/oclif/core/issues/400)) ([2ccb274](https://github.com/oclif/core/commit/2ccb2740912dba3b81c4d36712fbb20fd6a03c23))



## [1.6.4](https://github.com/oclif/core/compare/v1.6.3...v1.6.4) (2022-03-31)


### Bug Fixes

* dynamic help ([#395](https://github.com/oclif/core/issues/395)) ([8ecc8f4](https://github.com/oclif/core/commit/8ecc8f41ec62ef5b05bdb70a79dce09b5913d14b))



## [1.6.3](https://github.com/oclif/core/compare/v1.6.2...v1.6.3) (2022-03-23)


### Bug Fixes

* use plugin alias if available ([245d841](https://github.com/oclif/core/commit/245d84197a64e55b17524c22cbc17ec025a07c08))



## [1.6.2](https://github.com/oclif/core/compare/v1.6.1...v1.6.2) (2022-03-23)


### Bug Fixes

* load correct plugin when using dynamic help ([#394](https://github.com/oclif/core/issues/394)) ([15c1fbe](https://github.com/oclif/core/commit/15c1fbe1e870b6da1372a5786a9ffb09746ce8f6))



## [1.6.1](https://github.com/oclif/core/compare/v1.6.0...v1.6.1) (2022-03-17)


### Bug Fixes

* set id to alias when adding commands ([#390](https://github.com/oclif/core/issues/390)) ([84ab722](https://github.com/oclif/core/commit/84ab7223a2196c6a33f64a3e4ba75a050b02d1c3))



# [1.6.0](https://github.com/oclif/core/compare/v1.5.3...v1.6.0) (2022-03-14)


### Features

* POC for allowing flexible command taxonomy ([#376](https://github.com/oclif/core/issues/376)) ([c47c6c6](https://github.com/oclif/core/commit/c47c6c6fb689a92f66d40aacfa146d885f08d962))



## [1.5.3](https://github.com/oclif/core/compare/v1.5.2...v1.5.3) (2022-03-09)


### Bug Fixes

* rid core of transient refs to cli-ux ([#379](https://github.com/oclif/core/issues/379)) ([a593a27](https://github.com/oclif/core/commit/a593a2751dbdd4bcd9cf05349154d0fa6e4d7e2d))



## [1.5.2](https://github.com/oclif/core/compare/v1.5.1...v1.5.2) (2022-03-04)


### Bug Fixes

* direct styled header text thru cliux.ux.info ([#387](https://github.com/oclif/core/issues/387)) ([5ebe8de](https://github.com/oclif/core/commit/5ebe8de3adcf2e45c952dd5aeaf5b2848b928e94))



## [1.5.1](https://github.com/oclif/core/compare/v1.5.0...v1.5.1) (2022-03-03)



# [1.5.0](https://github.com/oclif/core/compare/v1.4.0...v1.5.0) (2022-03-02)


### Features

* dir and file flags that validate existence and type ([#384](https://github.com/oclif/core/issues/384)) ([44dff41](https://github.com/oclif/core/commit/44dff41c5a3ffcdcbf2f10dcefb7c1ab233bfc4f))



# [1.4.0](https://github.com/oclif/core/compare/v1.3.6...v1.4.0) (2022-03-01)


### Features

* make global flags settable ([#385](https://github.com/oclif/core/issues/385)) ([e14061c](https://github.com/oclif/core/commit/e14061ca7e6a4c288eb50e0e9954b38e042682df))



## [1.3.6](https://github.com/oclif/core/compare/v1.3.5...v1.3.6) (2022-02-28)


### Bug Fixes

* parsing the default is wrong types ([ba08723](https://github.com/oclif/core/commit/ba087237773e6f4b3649d03dc88f693a22681de9))



## [1.3.5](https://github.com/oclif/core/compare/v1.3.4...v1.3.5) (2022-02-25)


### Bug Fixes

* print valid flag values in error message when using `exactlyOne` ([#349](https://github.com/oclif/core/issues/349)) ([ddcaeb2](https://github.com/oclif/core/commit/ddcaeb2f9b690d9b92dd0ac4937b6399f606adfa))



## [1.3.4](https://github.com/oclif/core/compare/v1.3.3...v1.3.4) (2022-02-11)


### Bug Fixes

* use error type instead of record ([#371](https://github.com/oclif/core/issues/371)) ([136ffe0](https://github.com/oclif/core/commit/136ffe06fe3dc3ddb6d018ced2b2cfaa9399d943))



## [1.3.3](https://github.com/oclif/core/compare/v1.3.2...v1.3.3) (2022-02-09)


### Bug Fixes

* update isProd utility ([#368](https://github.com/oclif/core/issues/368)) ([a58315d](https://github.com/oclif/core/commit/a58315dc401071675c0f1b08a7ab82c35846ce6d))



## [1.3.2](https://github.com/oclif/core/compare/v1.3.1...v1.3.2) (2022-02-08)


### Bug Fixes

* fix default import of lodash ([#366](https://github.com/oclif/core/issues/366)) ([99fc7d1](https://github.com/oclif/core/commit/99fc7d1fdddbcd1509f649723057cd0ba7ee414c))



## [1.3.1](https://github.com/oclif/core/compare/v1.3.0...v1.3.1) (2022-02-07)



# [1.3.0](https://github.com/oclif/core/compare/v1.2.1...v1.3.0) (2022-02-01)


### Features

* add S3Manifest ([#354](https://github.com/oclif/core/issues/354)) ([ea5585d](https://github.com/oclif/core/commit/ea5585db6361f12c3c0608b05d1e33e16bc0b4b6))



## [1.2.1](https://github.com/oclif/core/compare/v1.2.0...v1.2.1) (2022-01-28)


### Bug Fixes

* module resolution of linked plugins ([#352](https://github.com/oclif/core/issues/352)) ([c7f5d34](https://github.com/oclif/core/commit/c7f5d3439e7e60b6562362c87fe0d16a99a42a08))



# [1.2.0](https://github.com/oclif/core/compare/v1.1.2...v1.2.0) (2022-01-26)


### Features

* merge cli-ux library with oclif/core ([#345](https://github.com/oclif/core/issues/345)) ([27175d6](https://github.com/oclif/core/commit/27175d6f0693533b7cfbf57de65da626168d872f)), closes [npm/cli#4234](https://github.com/npm/cli/issues/4234)



## [1.1.2](https://github.com/oclif/core/compare/v1.1.1...v1.1.2) (2022-01-10)



## [1.1.1](https://github.com/oclif/core/compare/v1.1.0...v1.1.1) (2022-01-06)


### Bug Fixes

* regenerate yarn.lock ([#340](https://github.com/oclif/core/issues/340)) ([75bf208](https://github.com/oclif/core/commit/75bf20819f2af574004cb7fe698938b51c6f2e44))



# [1.1.0](https://github.com/oclif/core/compare/v1.0.11...v1.1.0) (2022-01-05)


### Features

* add integration tests ([#339](https://github.com/oclif/core/issues/339)) ([2159c0b](https://github.com/oclif/core/commit/2159c0b970a0090f8bf21ff59e63dea1e788b5f9))



## [1.0.11](https://github.com/oclif/core/compare/v1.0.10...v1.0.11) (2021-12-17)


### Bug Fixes

* update imports in errors/cli.ts ([#325](https://github.com/oclif/core/issues/325)) ([b3d6e9b](https://github.com/oclif/core/commit/b3d6e9bf34928ac59486807576a2ee2643b22464))



## [1.0.10](https://github.com/oclif/core/compare/v1.0.9...v1.0.10) (2021-12-08)


### Bug Fixes

* bump deps ([#317](https://github.com/oclif/core/issues/317)) ([3e656e0](https://github.com/oclif/core/commit/3e656e0b6909bedb879a267bf341cfb992f4d208))



## [1.0.9](https://github.com/oclif/core/compare/v1.0.8...v1.0.9) (2021-12-08)



## [1.0.8](https://github.com/oclif/core/compare/v1.0.7...v1.0.8) (2021-12-07)


### Bug Fixes

* bump deps ([#314](https://github.com/oclif/core/issues/314)) ([e989d1c](https://github.com/oclif/core/commit/e989d1c078d24df3023f2abf61dd454435f08956))



## [1.0.7](https://github.com/oclif/core/compare/v1.0.6...v1.0.7) (2021-12-02)


### Bug Fixes

* bump cli-ux ([2334c7d](https://github.com/oclif/core/commit/2334c7d05d003a167b41375d55cc67e28403863e))



## [1.0.6](https://github.com/oclif/core/compare/v1.0.5...v1.0.6) (2021-12-01)


### Bug Fixes

* bump cli-ux version in core ([#308](https://github.com/oclif/core/issues/308)) ([ea0a457](https://github.com/oclif/core/commit/ea0a45701981dbffaa0fbeab20f4fa678a75c4e0))



## [1.0.5](https://github.com/oclif/core/compare/v1.0.4...v1.0.5) (2021-12-01)


### Bug Fixes

* bump deps ([#306](https://github.com/oclif/core/issues/306)) ([52ee252](https://github.com/oclif/core/commit/52ee25247836b80d1d0c39f8f4793049a6ccbde7))



## [1.0.4](https://github.com/oclif/core/compare/v1.0.3...v1.0.4) (2021-11-18)


### Bug Fixes

* resolve typescript compilation errors ([#290](https://github.com/oclif/core/issues/290)) ([7079932](https://github.com/oclif/core/commit/70799324b19e36c3cff5618de49083c68d0d9fc6))



## [1.0.3](https://github.com/oclif/core/compare/v1.0.2...v1.0.3) (2021-11-08)


### Bug Fixes

* remove module lodash.template in favor of lodash ([#286](https://github.com/oclif/core/issues/286)) ([caaff0b](https://github.com/oclif/core/commit/caaff0b4918ab2e01bc01cad2c0d8158c2fcc1c5))



## [1.0.2](https://github.com/oclif/core/compare/v1.0.1...v1.0.2) (2021-10-13)


### Bug Fixes

* remove ability to enable json flag globally ([#272](https://github.com/oclif/core/issues/272)) ([3c754e7](https://github.com/oclif/core/commit/3c754e7eee04ef078ff4ab08849191e6a5779ee0))



## [1.0.1](https://github.com/oclif/core/compare/v1.0.0...v1.0.1) (2021-10-08)


### Bug Fixes

* use default separator if none is configured ([#271](https://github.com/oclif/core/issues/271)) ([602cf12](https://github.com/oclif/core/commit/602cf121ec676182a71a7e87b37714670cee0bf0))



# [1.0.0](https://github.com/oclif/core/compare/v0.6.0...v1.0.0) (2021-09-29)



# [0.6.0](https://github.com/oclif/core/compare/v0.5.41...v0.6.0) (2021-09-29)



## [0.5.41](https://github.com/oclif/core/compare/v0.5.40...v0.5.41) (2021-09-29)


### Bug Fixes

* only show warnings when json is not enabled ([#260](https://github.com/oclif/core/issues/260)) ([0890917](https://github.com/oclif/core/commit/0890917f79c671c4635dc577c6821d544eef3c69))



## [0.5.40](https://github.com/oclif/core/compare/v0.5.39...v0.5.40) (2021-09-27)


### Bug Fixes

* adjust help text to new style guide ([#259](https://github.com/oclif/core/issues/259)) ([28d9d78](https://github.com/oclif/core/commit/28d9d78f5118886632a200e51cb34f7896210304))



## [0.5.39](https://github.com/oclif/core/compare/v0.5.38...v0.5.39) (2021-09-17)


### Features

* parallelize runHook ([#253](https://github.com/oclif/core/issues/253)) ([34abf7c](https://github.com/oclif/core/commit/34abf7cd80f2f8825682ca782e42f62002215ebb))



## [0.5.38](https://github.com/oclif/core/compare/v0.5.37...v0.5.38) (2021-09-15)


### Features

* have --json global flag disabled by default ([#252](https://github.com/oclif/core/issues/252)) ([c2a7799](https://github.com/oclif/core/commit/c2a7799ce036697c77917a830a12bce5db6c68a7))



## [0.5.37](https://github.com/oclif/core/compare/v0.5.36...v0.5.37) (2021-09-15)


### Bug Fixes

* don't warn on hook errors ([#246](https://github.com/oclif/core/issues/246)) ([ba4be4b](https://github.com/oclif/core/commit/ba4be4b010f5f861e44b43ac31f33ce4b749982e))



## [0.5.36](https://github.com/oclif/core/compare/v0.5.35...v0.5.36) (2021-09-14)


### Bug Fixes

* move ctor for command help class to its own function ([#244](https://github.com/oclif/core/issues/244)) ([26f2445](https://github.com/oclif/core/commit/26f24457c71276c38f86821c2b1498ecb8e4e2a4))



## [0.5.35](https://github.com/oclif/core/compare/v0.5.34...v0.5.35) (2021-09-08)


### Bug Fixes

* clear hook timeout ([#243](https://github.com/oclif/core/issues/243)) ([0c32c65](https://github.com/oclif/core/commit/0c32c65c5c30b02bc3ea6e36b0598adfc5b23ec1))



## [0.5.34](https://github.com/oclif/core/compare/v0.5.33...v0.5.34) (2021-08-30)


### Bug Fixes

* add support all properties for a command class in manifest ([deb0765](https://github.com/oclif/core/commit/deb0765f81dbea54c831beba0b608b1a8cd0ecdb))



## [0.5.33](https://github.com/oclif/core/compare/v0.5.32...v0.5.33) (2021-08-30)


### Bug Fixes

* improve Hooks interface ([#234](https://github.com/oclif/core/issues/234)) ([32d0d62](https://github.com/oclif/core/commit/32d0d62ed30c65cdbca7c6da630b5542b38ab3b1))



## [0.5.32](https://github.com/oclif/core/compare/v0.5.31...v0.5.32) (2021-08-23)


### Bug Fixes

* account for aliases when converting spaced commands to commandID ([#232](https://github.com/oclif/core/issues/232)) ([b8ee9b2](https://github.com/oclif/core/commit/b8ee9b209ddacdf95f164a05473a05d1b6c53d6b))



## [0.5.31](https://github.com/oclif/core/compare/v0.5.30...v0.5.31) (2021-08-18)


### Bug Fixes

* command name parsing when flag=value present ([#231](https://github.com/oclif/core/issues/231)) ([6497514](https://github.com/oclif/core/commit/64975145085b6a9e287dd146a7fda8d3accfab58))



## [0.5.30](https://github.com/oclif/core/compare/v0.5.29...v0.5.30) (2021-08-16)


### Bug Fixes

* update collateSpacedCmdIDFromArgs ([#230](https://github.com/oclif/core/issues/230)) ([4687287](https://github.com/oclif/core/commit/46872871cb8c7e8749298344a575751638ab2c04))



## [0.5.29](https://github.com/oclif/core/compare/v0.5.28...v0.5.29) (2021-08-10)


### Bug Fixes

* don't put multiple newlines between flag summaries in help output ([#225](https://github.com/oclif/core/issues/225)) ([bfbd15c](https://github.com/oclif/core/commit/bfbd15c7c60f663b9a17f02d4f5a1e8798b4d613))
* switch ci to main ([849aeee](https://github.com/oclif/core/commit/849aeee378761f2edf52e7e9f44d4a0deab9cb3b))


### Features

* support multiple examples commands under a single description ([#229](https://github.com/oclif/core/issues/229)) ([b7ad583](https://github.com/oclif/core/commit/b7ad5838adcc2e3f274a563b302090b697afc96a))



## [0.5.28](https://github.com/oclif/core/compare/v0.5.27...v0.5.28) (2021-08-03)


### Features

* add state property ([#206](https://github.com/oclif/core/issues/206)) ([07f9092](https://github.com/oclif/core/commit/07f9092128f979e3e4e22aeee07bf4d4caa3024c))



## [0.5.27](https://github.com/oclif/core/compare/v0.5.26...v0.5.27) (2021-07-29)


### Bug Fixes

* restore short flags for --help and --version ([#205](https://github.com/oclif/core/issues/205)) ([67dadd4](https://github.com/oclif/core/commit/67dadd413dfbdd7742a3cd91e7ce1d5dfc7421da))



## [0.5.26](https://github.com/oclif/core/compare/v0.5.25...v0.5.26) (2021-07-22)


### Bug Fixes

* set exitCode on --json errors ([67f5eea](https://github.com/oclif/core/commit/67f5eea6e43345203ba7a79f5d27aeb65e7c2bab))



## [0.5.25](https://github.com/oclif/core/compare/v0.5.24...v0.5.25) (2021-07-22)


### Bug Fixes

* remove default flags ([403e5d8](https://github.com/oclif/core/commit/403e5d89351d2f9bc2494179e1514f0ed7500384))



## [0.5.24](https://github.com/oclif/core/compare/v0.5.23...v0.5.24) (2021-07-22)


### Bug Fixes

* set this.flags to empty object by default ([8f5d5ed](https://github.com/oclif/core/commit/8f5d5ed1f691ed442d88c19087bc50e0dadda88b))



## [0.5.23](https://github.com/oclif/core/compare/v0.5.22...v0.5.23) (2021-07-19)


### Bug Fixes

* make findCommand deterministic ([#204](https://github.com/oclif/core/issues/204)) ([3a37a8c](https://github.com/oclif/core/commit/3a37a8c7c5ab20da781a6682e41952b482622413))



## [0.5.22](https://github.com/oclif/core/compare/v0.5.21...v0.5.22) (2021-07-14)


### Bug Fixes

* respect variable args when using spaces ([#203](https://github.com/oclif/core/issues/203)) ([d458dfd](https://github.com/oclif/core/commit/d458dfd602bcdd8bfdf0ee920ff710a59b5d831a))



## [0.5.21](https://github.com/oclif/core/compare/v0.5.20...v0.5.21) (2021-07-07)


### Bug Fixes

* update cli-ux ([6608e12](https://github.com/oclif/core/commit/6608e12f488fa260ba952aa54ced780b1dfc4470))



## [0.5.20](https://github.com/oclif/core/compare/v0.5.19...v0.5.20) (2021-07-01)


### Bug Fixes

* allow for no args on top level topic ([1231eae](https://github.com/oclif/core/commit/1231eae78310d0da064ed74b53ad58e10e6905b6))



## [0.5.19](https://github.com/oclif/core/compare/v0.5.18...v0.5.19) (2021-06-30)


### Bug Fixes

* jsonEnabled when json is disabled ([4575be8](https://github.com/oclif/core/commit/4575be87f40622c13ed8060765d341365bc8bd6e))



## [0.5.18](https://github.com/oclif/core/compare/v0.5.17...v0.5.18) (2021-06-28)


### Features

* add docopts ([#188](https://github.com/oclif/core/issues/188)) ([4f38877](https://github.com/oclif/core/commit/4f38877b1e9abb1a19a3bcecde17945f80b2d52d))



## [0.5.17](https://github.com/oclif/core/compare/v0.5.16...v0.5.17) (2021-06-28)


### Bug Fixes

* simplify toSuccessJson ([442195e](https://github.com/oclif/core/commit/442195eb6ee5e7728fe0bb4e9e1d8ecb5633f105))



## [0.5.16](https://github.com/oclif/core/compare/v0.5.15...v0.5.16) (2021-06-28)


### Features

* return results from runHook ([#187](https://github.com/oclif/core/issues/187)) ([5355203](https://github.com/oclif/core/commit/535520326a354e3d12abc77ba9148a314fa957ba))



## [0.5.15](https://github.com/oclif/core/compare/v0.5.14...v0.5.15) (2021-06-24)


### Bug Fixes

* return type on toSuccessJson ([e2a9751](https://github.com/oclif/core/commit/e2a9751c84d5582ff4f0b3e24b12b198c0318dd1))



## [0.5.14](https://github.com/oclif/core/compare/v0.5.13...v0.5.14) (2021-06-17)


### Features

* help improvements and customizability ([#184](https://github.com/oclif/core/issues/184)) ([cb2109b](https://github.com/oclif/core/commit/cb2109b113864534ceb08978ae1b209be7ae70d8))



## [0.5.13](https://github.com/oclif/core/compare/v0.5.12...v0.5.13) (2021-06-09)



## [0.5.12](https://github.com/oclif/core/compare/v0.5.11...v0.5.12) (2021-06-07)



## [0.5.11](https://github.com/oclif/core/compare/v0.5.10...v0.5.11) (2021-06-07)



## [0.5.10](https://github.com/oclif/core/compare/v0.5.9...v0.5.10) (2021-05-28)



## [0.5.9](https://github.com/oclif/core/compare/v0.5.8...v0.5.9) (2021-05-27)



## [0.5.8](https://github.com/oclif/core/compare/v0.5.7...v0.5.8) (2021-05-26)


### Features

* strengthened ModuleLoader & unit tests; now supports mixed ESM / CJS plugins ([#163](https://github.com/oclif/core/issues/163)) ([788bf17](https://github.com/oclif/core/commit/788bf175b7e39b7d61fc07279e5cedca2fdbd540))



## [0.5.7](https://github.com/oclif/core/compare/v0.5.6...v0.5.7) (2021-05-17)


### Bug Fixes

* conversion of spaced commands to colon commands ([#164](https://github.com/oclif/core/issues/164)) ([9503d32](https://github.com/oclif/core/commit/9503d323d6e0dffe98a0a7005f676daeebd9ec44))



## [0.5.6](https://github.com/oclif/core/compare/v0.5.5...v0.5.6) (2021-05-13)


### Features

* integrate ESM loading of commands & hooks ([#160](https://github.com/oclif/core/issues/160)) ([ff47444](https://github.com/oclif/core/commit/ff47444b549566e40015d33f29d2687b74a980f4))



## [0.5.5](https://github.com/oclif/core/compare/v0.5.4...v0.5.5) (2021-04-26)



## [0.5.4](https://github.com/oclif/core/compare/v0.5.3...v0.5.4) (2021-04-20)



## [0.5.3](https://github.com/oclif/core/compare/v0.5.2...v0.5.3) (2021-04-19)



## [0.5.2](https://github.com/oclif/core/compare/v0.5.1...v0.5.2) (2021-04-19)



## [0.5.1](https://github.com/oclif/core/compare/v0.5.0...v0.5.1) (2021-04-15)


### Features

* support misspelled spaced commands ([#143](https://github.com/oclif/core/issues/143)) ([50c1789](https://github.com/oclif/core/commit/50c1789120a4d73703c0ce560a6a312d391f594a))



# [0.5.0](https://github.com/oclif/core/compare/v0.4.0...v0.5.0) (2021-04-08)


### Bug Fixes

* don't resolve lib to src in development mode ([#129](https://github.com/oclif/core/issues/129)) ([abd10fd](https://github.com/oclif/core/commit/abd10fdbb313c25170f4492cc8dfea8ffa3a9928))



# [0.4.0](https://github.com/oclif/core/compare/v0.3.0...v0.4.0) (2021-03-01)


### Features

* add topic separator option ([#111](https://github.com/oclif/core/issues/111)) ([b3ca07f](https://github.com/oclif/core/commit/b3ca07f4e6f7e6e87e675a9de0dbce611a9f1950))



# [0.3.0](https://github.com/oclif/core/compare/v0.2.0...v0.3.0) (2021-02-01)


### Bug Fixes

* default ExitError to exit error code 1 ([#95](https://github.com/oclif/core/issues/95)) ([2005c5f](https://github.com/oclif/core/commit/2005c5f092dc60c0cfafcb1d5c90fd62c2048dca))
* filter help argvs before invoking ([#103](https://github.com/oclif/core/issues/103)) ([698125d](https://github.com/oclif/core/commit/698125d602de9bc085b4080768a564a7b01fe27d))
* only --version & --help are special global flags ([#96](https://github.com/oclif/core/issues/96)) ([364d6dd](https://github.com/oclif/core/commit/364d6dd8fd5a54334a6e77255cd6b3a5e7321632))


### Features

* add default command (rm root cmd) ([#97](https://github.com/oclif/core/issues/97)) ([fbf1a0f](https://github.com/oclif/core/commit/fbf1a0f827208da75c77009fedd48b8886a00520))
* args read stdin ([#100](https://github.com/oclif/core/issues/100)) ([caea554](https://github.com/oclif/core/commit/caea55484c0cdf6803b9fa472f9fa8a622f57a80))
* parse async ([#99](https://github.com/oclif/core/issues/99)) ([57924df](https://github.com/oclif/core/commit/57924df5c168b677df9d1d1f43155a89e9cb2c98))
* rm duplicate ts-node registering ([#102](https://github.com/oclif/core/issues/102)) ([b8b5333](https://github.com/oclif/core/commit/b8b5333047eb939e79c8cadf460e3c76ff751460))
* run single & multi cmd clis with same invoking/runner ([#98](https://github.com/oclif/core/issues/98)) ([8828ca9](https://github.com/oclif/core/commit/8828ca9d05f87bc321bbd2394191b194764bba7a))



# [0.2.0](https://github.com/oclif/core/compare/v0.1.2...v0.2.0) (2020-09-18)


### Bug Fixes

* capitalize Flags module export ([#41](https://github.com/oclif/core/issues/41)) ([9b1d2a8](https://github.com/oclif/core/commit/9b1d2a8f8bae42f2b5e1115db42adc6d159e351b))
* config debug scope ([#38](https://github.com/oclif/core/issues/38)) ([be0d001](https://github.com/oclif/core/commit/be0d0018637d3809e487fb750a1e7166a49f70bd))
* export TSConfig in Interfaces ([#43](https://github.com/oclif/core/issues/43)) ([187f5b8](https://github.com/oclif/core/commit/187f5b8a8f98e6e743ebd5cd45cae2f36a1b0781))


### Features

* export Config, Plugin at root & namespace interfaces ([#40](https://github.com/oclif/core/issues/40)) ([0817fc0](https://github.com/oclif/core/commit/0817fc0133859ddf98b4d85f29839d5dadc7ec6e))
* export HelpOptions in Interfaces ([#45](https://github.com/oclif/core/issues/45)) ([5d4212f](https://github.com/oclif/core/commit/5d4212f6a3f8f56c66b6eeb4680da0ad0c944325))
* export OclifError & PrettyPrintableError in Interfaces ([#44](https://github.com/oclif/core/issues/44)) ([766b6f5](https://github.com/oclif/core/commit/766b6f553f3861e247258142005a8ca035c209af))
* export parser interfaces in Interfaces ([#46](https://github.com/oclif/core/issues/46)) ([d5ad46d](https://github.com/oclif/core/commit/d5ad46db55f9510e5cd3235111fe93bfa4a4c1c4))
* mv Command & flag export to root ([#37](https://github.com/oclif/core/issues/37)) ([70ea6e1](https://github.com/oclif/core/commit/70ea6e16ada0ce18ebbeb52ed9802d3a1536276d))
* mv getHelpClass, Help & HelpBase export to root ([#39](https://github.com/oclif/core/issues/39)) ([3d272d8](https://github.com/oclif/core/commit/3d272d8a5308e1063326bcfc1eb8998c2a4f8585))



## [0.1.2](https://github.com/oclif/core/compare/v0.1.1...v0.1.2) (2020-09-11)


### Bug Fixes

* export run ([#36](https://github.com/oclif/core/issues/36)) ([0a2fa9a](https://github.com/oclif/core/commit/0a2fa9a9e90baebd41d15f6b70a11f5ad75dc6c7))



## [0.1.1](https://github.com/oclif/core/compare/v0.1.0...v0.1.1) (2020-09-09)


### Bug Fixes

* accept integer 0 as valid arg input ([#34](https://github.com/oclif/core/issues/34)) ([36eb02f](https://github.com/oclif/core/commit/36eb02f168eaa179e260010443fd33e526a94763))
* support src/commands/index cmd ([#35](https://github.com/oclif/core/issues/35)) ([2c14c3c](https://github.com/oclif/core/commit/2c14c3c0987e9cf97ff1d34648cf4a0a90e595d2))



# 0.1.0 (2020-09-02)
````

## File: CONRTIBUTING.md
````markdown
# Contributing

## Reporting Bugs

When submitting a new bug report, please first [search](https://github.com/oclif/core/issues) for an existing or similar report & then use one of our existing [issue templates](https://github.com/oclif/core/issues/new/choose) if you believe you've come across a unique problem. Duplicate issues, or issues that don't use one of our templates may get closed without a response.

## Development

**1. Clone this repository...**

```bash
$ git clone git@github.com:oclif/core.git
```

**2. Navigate into project & install development-specific dependencies...**

```bash
$ cd ./core && yarn
```

**3. Write some code &/or add some tests...**

```bash
...
```

**4. Run tests & ensure they pass...**

```
$ yarn test
```

**5. Open a [Pull Request](https://github.com/oclif/core/pulls) for your work & become the newest contributor to `@oclif/core`! ðŸŽ‰**

## Pull Request Conventions

We use [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/). When opening a pull request, please be sure that either the pull request title, or each commit in the pull request, has one of the following prefixes:

- `feat`: For when introducing a new feature. The result will be a new semver minor version of the package when it is next published.
- `fix`: For bug fixes. The result will be a new semver patch version of the package when it is next published.
- `docs`: For documentation updates. The result will be a new semver patch version of the package when it is next published.
- `chore`: For changes that do not affect the published module. Often these are changes to tests. The result will be _no_ change to the version of the package when it is next published (as the commit does not affect the published version).

## What _not_ to contribute?

### Dependencies

It should be noted that our team does not accept third-party dependency updates/PRs. We use dependabot to ensure dependencies are staying up-to-date & will ship security patches for CVEs as they occur. If you submit a PR trying to update our dependencies we will close it with or without a reference to these contribution guidelines.

### Tools/Automation

Our core team is responsible for the maintenance of the tooling/automation in this project & we ask collaborators to kindly not make changes to these when contributing (ex. `.github/*`, `.eslintrc.json`, package.json `scripts`, etc.)
````

## File: eslint.config.mjs
````
import {includeIgnoreFile} from '@eslint/compat'
import oclif from 'eslint-config-oclif'
import prettier from 'eslint-config-prettier'
import path from 'node:path'
import {fileURLToPath} from 'node:url'

const gitignorePath = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '.gitignore')

export default [
  includeIgnoreFile(gitignorePath),
  ...oclif,
  prettier,
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-namespace': 'off',
      '@typescript-eslint/no-require-imports': 'off',
      'import/no-named-as-default-member': 'off',
      'no-useless-constructor': 'off',
      'perfectionist/sort-intersection-types': 'off',
      'perfectionist/sort-object-types': 'off',
      'perfectionist/sort-union-types': 'off',
      'unicorn/no-array-reduce': 'off',
      'unicorn/prefer-module': 'off',
    },
  },
  {
    files: ['test/**/*'],
    rules: {
      '@stylistic/lines-between-class-members': 'off',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/ban-ts-ignore': 'off',
      '@typescript-eslint/no-empty-function': 'off',
      'max-lines': 'off',
      'mocha/max-top-level-suites': ['warn', {limit: 8}],
      'no-import-assign': 'off',
      'perfectionist/sort-classes': 'off',
      'perfectionist/sort-objects': 'off',
      'unicorn/consistent-function-scoping': 'off',
      'unicorn/no-abusive-eslint-disable': 'off',
      'unicorn/no-static-only-class': 'off',
      'unicorn/no-useless-undefined': 'off',
    },
  },
  {
    files: ['test/integration/*'],
    rules: {
      '@typescript-eslint/no-unused-expressions': 'off',
      'mocha/no-nested-tests': 'off',
      'mocha/no-sibling-hooks': 'off',
      'mocha/no-top-level-hooks': 'off',
      'unicorn/prefer-object-from-entries': 'off',
      'unicorn/prefer-top-level-await': 'off',
    },
  },
  {
    files: ['test/module-loader/fixtures/**/*'],
    rules: {
      '@typescript-eslint/no-unused-expressions': 'off',
      camelcase: 'off',
      'no-undef': 'off',
      'unicorn/filename-case': 'off',
    },
  },
]
````

## File: LICENSE
````
MIT License

Copyright (c) 2018 Salesforce.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
````

## File: package.json
````json
{
  "name": "@oclif/core",
  "description": "base library for oclif CLIs",
  "version": "4.4.1",
  "author": "Salesforce",
  "bugs": "https://github.com/oclif/core/issues",
  "dependencies": {
    "ansi-escapes": "^4.3.2",
    "ansis": "^3.17.0",
    "clean-stack": "^3.0.1",
    "cli-spinners": "^2.9.2",
    "debug": "^4.4.0",
    "ejs": "^3.1.10",
    "get-package-type": "^0.1.0",
    "indent-string": "^4.0.0",
    "is-wsl": "^2.2.0",
    "lilconfig": "^3.1.3",
    "minimatch": "^9.0.5",
    "semver": "^7.6.3",
    "string-width": "^4.2.3",
    "supports-color": "^8",
    "tinyglobby": "^0.2.14",
    "widest-line": "^3.1.0",
    "wordwrap": "^1.0.0",
    "wrap-ansi": "^7.0.0"
  },
  "devDependencies": {
    "@commitlint/config-conventional": "^19",
    "@eslint/compat": "^1.3.1",
    "@oclif/plugin-help": "^6",
    "@oclif/plugin-plugins": "^5",
    "@oclif/prettier-config": "^0.2.1",
    "@oclif/test": "^4",
    "@types/benchmark": "^2.1.5",
    "@types/chai": "^4.3.16",
    "@types/chai-as-promised": "^7.1.8",
    "@types/clean-stack": "^2.1.1",
    "@types/debug": "^4.1.10",
    "@types/ejs": "^3.1.5",
    "@types/indent-string": "^4.0.1",
    "@types/mocha": "^10.0.10",
    "@types/node": "^18",
    "@types/pnpapi": "^0.0.5",
    "@types/sinon": "^17.0.3",
    "@types/supports-color": "^8.1.3",
    "@types/wordwrap": "^1.0.3",
    "@types/wrap-ansi": "^3.0.0",
    "benchmark": "^2.1.4",
    "chai": "^4.5.0",
    "chai-as-promised": "^7.1.2",
    "commitlint": "^19",
    "cross-env": "^7.0.3",
    "eslint": "^9",
    "eslint-config-oclif": "^6",
    "eslint-config-prettier": "^10",
    "husky": "^9.1.7",
    "lint-staged": "^15",
    "madge": "^6.1.0",
    "mocha": "^10.8.2",
    "nyc": "^15.1.0",
    "prettier": "^3.6.2",
    "shx": "^0.4.0",
    "sinon": "^18",
    "ts-node": "^10.9.2",
    "tsd": "^0.32.0",
    "typescript": "^5"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "files": [
    "/lib"
  ],
  "homepage": "https://github.com/oclif/core",
  "keywords": [
    "oclif",
    "cli",
    "command",
    "command line",
    "parser",
    "args",
    "argv"
  ],
  "license": "MIT",
  "exports": {
    ".": "./lib/index.js",
    "./args": "./lib/args.js",
    "./command": "./lib/command.js",
    "./config": "./lib/config/index.js",
    "./errors": "./lib/errors/index.js",
    "./execute": "./lib/execute.js",
    "./flags": "./lib/flags.js",
    "./flush": "./lib/flush.js",
    "./handle": "./lib/errors/handle.js",
    "./help": "./lib/help/index.js",
    "./hooks": "./lib/interfaces/hooks.js",
    "./interfaces": "./lib/interfaces/index.js",
    "./logger": "./lib/logger.js",
    "./package.json": "./package.json",
    "./parser": "./lib/parser/index.js",
    "./performance": "./lib/performance.js",
    "./run": "./lib/main.js",
    "./settings": "./lib/settings.js",
    "./util/ids": "./lib/util/ids.js",
    "./ux": "./lib/ux/index.js"
  },
  "repository": "oclif/core",
  "oclif": {
    "bin": "oclif",
    "devPlugins": [
      "@oclif/plugin-help",
      "@oclif/plugin-plugins"
    ]
  },
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "build": "shx rm -rf lib && tsc",
    "compile": "tsc",
    "format": "prettier --write \"+(src|test)/**/*.+(ts|js|json)\"",
    "lint": "eslint",
    "posttest": "yarn lint && yarn test:circular-deps",
    "prepack": "yarn run build",
    "prepare": "husky",
    "test:circular-deps": "yarn build && madge lib/ -c",
    "test:debug": "nyc mocha --debug-brk --inspect \"test/**/*.test.ts\"",
    "test:integration": "mocha --forbid-only \"test/**/*.integration.ts\" --parallel --timeout 1200000",
    "test:interoperability": "cross-env DEBUG=integration:* ts-node test/integration/interop.ts",
    "test:perf": "ts-node test/perf/parser.perf.ts",
    "test": "nyc mocha --forbid-only \"test/**/*.test.ts\" --parallel"
  },
  "types": "lib/index.d.ts"
}
````

## File: README.md
````markdown
<img src="https://user-images.githubusercontent.com/449385/38243295-e0a47d58-372e-11e8-9bc0-8c02a6f4d2ac.png" width="260" height="73">

# oclif: Node.JS Open CLI Framework

[![Version](https://img.shields.io/npm/v/@oclif/core.svg)](https://npmjs.org/package/@oclif/core)
[![Downloads/week](https://img.shields.io/npm/dw/@oclif/core.svg)](https://npmjs.org/package/@oclif/core)
[![License](https://img.shields.io/npm/l/@oclif/core.svg)](https://github.com/oclif/core/blob/main/LICENSE)

# ðŸ—’ Description

This is a framework for building CLIs in Node.js. This framework was built out of the [Salesforce CLI](https://github.com/salesforcecli/cli) but generalized to build any custom CLI. It's designed both for single-file CLIs with a few flag options (like `cat` or `ls`), or for very complex CLIs that have subcommands (like `git` or `heroku`).

[See the docs for more information](http://oclif.io/docs/introduction).

# ðŸš€ Getting Started Tutorial

The [Getting Started tutorial](http://oclif.io/docs/introduction) is a step-by-step guide to introduce you to oclif. If you have not developed anything in a command line before, this tutorial is a great place to get started.

# âœ¨ Features

- **Flag/Argument parsing** - No CLI framework would be complete without a flag parser. We've built a custom one from years of experimentation that we feel consistently handles user input flexible enough for the user to be able to use the CLI in ways they expect, but without compromising strictness guarantees to the developer.
- **Super Speed** - The overhead for running an oclif CLI command is almost nothing. [It requires very few dependencies](https://www.npmjs.com/package/@oclif/core?activeTab=dependencies) (only 28 dependencies in a minimal setupâ€”including all transitive dependencies). Also, only the command to be executed will be required with node. So large CLIs with many commands will load equally as fast as a small one with a single command.
- **CLI Generator** - Run a single command to scaffold out a fully functional CLI and get started quickly. See [Getting Started Tutorial](<[#-usage](https://oclif.io/docs/introduction.html)>).
- **Testing Helpers** - We've put a lot of work into making commands easier to test and mock out stdout/stderr. The generator will automatically create [scaffolded tests](https://github.com/oclif/hello-world/blob/main/test/commands/hello.test.ts).
- **Auto-documentation** - By default you can pass `--help` to the CLI to get help such as flag options and argument information. This information is also automatically placed in the README whenever the npm package of the CLI is published. See the [hello-world CLI example](https://github.com/oclif/hello-world)
- **Plugins** - Using [plugins](https://oclif.io/docs/plugins), users of the CLI can extend it with new functionality, a CLI can be split into modular components, and functionality can be shared amongst multiple CLIs. See [Building your own plugin](https://oclif.io/docs/plugins#building-your-own-plugin).
- **Hooks** - Use lifecycle hooks to run functionality any time a CLI starts, or on custom triggers. Use this whenever custom functionality needs to be shared between various components of the CLI.
- **TypeScript** - Everything in the core of oclif is written in TypeScript and the generator will build fully configured TypeScript CLIs. If you use plugins support, the CLI will automatically use `ts-node` to run the plugins enabling you to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
- **Auto-updating Installers** - oclif can package your CLI into [different installers](https://oclif.io/docs/releasing) that will not require the user to already have node installed on the machine. These can be made auto-updatable by using [plugin-update](https://github.com/oclif/plugin-update).
- **Everything is Customizable** - Pretty much anything can be swapped out and replaced inside oclif if neededâ€”including the arg/flag parser.
- **Autocomplete** - Automatically include autocomplete for your CLI. This includes not only command names and flag names, but flag values as well. For example, it's possible to configure the Heroku CLI to have completions for Heroku app names:

```
$ heroku info --app=<tab><tab> # will complete with all the Heroku apps a user has in their account
```

# ðŸ“Œ Requirements

Currently, Node 18+ is supported. We support the [LTS versions](https://nodejs.org/en/about/releases) of Node. You can add the [node](https://www.npmjs.com/package/node) package to your CLI to ensure users are running a specific version of Node.

# ðŸ“Œ Migrating

See the [v3 migration guide](./guides/V3_MIGRATION.md) for an overview of breaking changes that occurred between v2 and v3.

See the [v2 migration guide](./guides/V2_MIGRATION.md) for an overview of breaking changes that occurred between v1 and v2.

Migrating from `@oclif/config` and `@oclif/command`? See the [v1 migration guide](./guides/PRE_CORE_MIGRATION.md).

# ðŸ“Œ Documentation

The official oclif website, [oclif.io](https://oclif.io/), contains all the documentation you need for developing a CLI with oclif.

If there's anything you'd like to see in the documentation, please submit an issue on the [oclif.github.io repo](https://github.com/oclif/oclif.github.io).

# ðŸš€ Standalone Usage

We strongly encourage you generate an oclif CLI using the [oclif cli](https://github.com/oclif/oclif). The generator will generate an npm package with `@oclif/core` as a dependency.

You can, however, use `@oclif/core` in a standalone script like this:

```typescript
#!/usr/bin/env -S node --loader ts-node/esm --no-warnings=ExperimentalWarning

import * as fs from 'fs'
import {Command, Flags, flush, handle} from '@oclif/core'

class LS extends Command {
  static description = 'List the files in a directory.'
  static flags = {
    version: Flags.version(),
    help: Flags.help(),
    dir: Flags.string({
      char: 'd',
      default: process.cwd(),
    }),
  }

  async run() {
    const {flags} = await this.parse(LS)
    const files = fs.readdirSync(flags.dir)
    for (const f of files) {
      this.log(f)
    }
  }
}

LS.run(process.argv.slice(2), {
  root: import.meta.dirname,
  // Tell oclif what the contents of the package.json are.
  // You could also set these in your package.json but specifying
  // them here is useful if you're attempting to bundle your CLI
  // without a package.json
  pjson: {
    name: 'ls',
    version: '0.0.1',
    oclif: {
      // Tell oclif that this is a single command CLI
      // See: https://oclif.io/docs/command_discovery_strategies
      commands: {
        strategy: 'single',
        target: 'index.js',
      },
    },
  },
}).then(
  async () => {
    await flush()
  },
  async (err) => {
    await handle(err)
  },
)
```

Then run it like this:

```sh-session
$ ts-node myscript.ts
...files in current dir...
```

You can also use oclif's `Parser` separately:

```javascript
// index.js
import {Args, Flags, Parser} from '@oclif/core'

const {args, flags} = await Parser.parse(process.argv.slice(2), {
  args: {
    name: Args.string({required: true}),
  },
  flags: {
    from: Flags.string({char: 'f', default: 'oclif'}),
  },
})

console.log(`hello ${args.name} from ${flags.from}`)
```

```
$ node index.js world --from oclif

hello world from oclif
```

**NOTE** If you're using the `Parser` class, you will not be able to use the builtin `help` and `version` flags since those require the context of an oclif project.

ðŸš€ Contributing

See the [contributing guide](./CONRTIBUTING.md).
````

## File: tsconfig.json
````json
{
  "compilerOptions": {
    "declaration": true,
    "forceConsistentCasingInFileNames": true,
    "module": "Node16",
    "outDir": "./lib",
    "pretty": true,
    "rootDirs": ["./src"],
    "strict": true,
    "target": "ES2022",
    "allowSyntheticDefaultImports": true,
    "exactOptionalPropertyTypes": true,
    "noErrorTruncation": true,
    "moduleResolution": "Node16"
  },
  "include": ["./src/**/*"]
}
````
